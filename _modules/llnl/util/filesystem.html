

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>llnl.util.filesystem &mdash; Spack 0.23.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=5f00b823" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />

  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=832b3b9f"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-S0PQ7WV75K"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-S0PQ7WV75K');
  </script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html">
            
              <img src="../../../_static/spack-logo-white-text.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../features.html">Feature Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basic_usage.html">Basic Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../replace_conda_homebrew.html">Spack for Homebrew/Conda Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../frequently_asked_questions.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://spack-tutorial.readthedocs.io">Tutorial (spack-tutorial.rtfd.io)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://packages.spack.io">Packages (packages.spack.io)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://cache.spack.io">Binaries (binaries.spack.io)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../configuration.html">Configuration Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../config_yaml.html">Spack Settings (config.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../packages_yaml.html">Package Settings (packages.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../build_settings.html">Concretization Settings (concretizer.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../environments.html">Environments (spack.yaml, spack.lock)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../containers.html">Container Images</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mirrors.html">Mirrors (mirrors.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_file_support.html">Modules (modules.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../repositories.html">Package Repositories (repos.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../binary_caches.html">Build Caches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bootstrapping.html">Bootstrapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../command_index.html">Command Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../chain.html">Chaining Spack Installations (upstreams.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extensions.html">Custom Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pipelines.html">CI Pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../signing.html">Spack Package Signing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gpu_configuration.html">Using External GPU Support</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contribution_guide.html">Contribution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../packaging_guide.html">Packaging Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../build_systems.html">Build Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide.html">Developer Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../spack.html">Spack API Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../llnl.html">LLNL API Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Spack</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">llnl.util.filesystem</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for llnl.util.filesystem</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2013-2024 Lawrence Livermore National Security, LLC and other</span>
<span class="c1"># Spack Project Developers. See the top-level COPYRIGHT file for details.</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier: (Apache-2.0 OR MIT)</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">fnmatch</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">posixpath</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">stat</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">accumulate</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Deque</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Generator</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Match</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">llnl.util.symlink</span>
<span class="kn">from</span> <span class="nn">llnl.util</span> <span class="kn">import</span> <span class="n">tty</span>
<span class="kn">from</span> <span class="nn">llnl.util.lang</span> <span class="kn">import</span> <span class="n">dedupe</span><span class="p">,</span> <span class="n">fnmatch_translate_multiple</span><span class="p">,</span> <span class="n">memoized</span>
<span class="kn">from</span> <span class="nn">llnl.util.symlink</span> <span class="kn">import</span> <span class="n">islink</span><span class="p">,</span> <span class="n">readlink</span><span class="p">,</span> <span class="n">resolve_link_target_relative_to_the_link</span><span class="p">,</span> <span class="n">symlink</span>

<span class="kn">from</span> <span class="nn">..path</span> <span class="kn">import</span> <span class="n">path_to_os_path</span><span class="p">,</span> <span class="n">system_path_filter</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">grp</span>
    <span class="kn">import</span> <span class="nn">pwd</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">win32security</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;FileFilter&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FileList&quot;</span><span class="p">,</span>
    <span class="s2">&quot;HeaderList&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LibraryList&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ancestor&quot;</span><span class="p">,</span>
    <span class="s2">&quot;can_access&quot;</span><span class="p">,</span>
    <span class="s2">&quot;change_sed_delimiter&quot;</span><span class="p">,</span>
    <span class="s2">&quot;copy_mode&quot;</span><span class="p">,</span>
    <span class="s2">&quot;filter_file&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find_first&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find_headers&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find_all_headers&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find_libraries&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find_system_libraries&quot;</span><span class="p">,</span>
    <span class="s2">&quot;force_remove&quot;</span><span class="p">,</span>
    <span class="s2">&quot;force_symlink&quot;</span><span class="p">,</span>
    <span class="s2">&quot;getuid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chgrp&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chmod_x&quot;</span><span class="p">,</span>
    <span class="s2">&quot;copy&quot;</span><span class="p">,</span>
    <span class="s2">&quot;install&quot;</span><span class="p">,</span>
    <span class="s2">&quot;copy_tree&quot;</span><span class="p">,</span>
    <span class="s2">&quot;install_tree&quot;</span><span class="p">,</span>
    <span class="s2">&quot;is_exe&quot;</span><span class="p">,</span>
    <span class="s2">&quot;join_path&quot;</span><span class="p">,</span>
    <span class="s2">&quot;last_modification_time_recursive&quot;</span><span class="p">,</span>
    <span class="s2">&quot;library_extensions&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mkdirp&quot;</span><span class="p">,</span>
    <span class="s2">&quot;partition_path&quot;</span><span class="p">,</span>
    <span class="s2">&quot;prefixes&quot;</span><span class="p">,</span>
    <span class="s2">&quot;remove_dead_links&quot;</span><span class="p">,</span>
    <span class="s2">&quot;remove_directory_contents&quot;</span><span class="p">,</span>
    <span class="s2">&quot;remove_if_dead_link&quot;</span><span class="p">,</span>
    <span class="s2">&quot;remove_linked_tree&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rename&quot;</span><span class="p">,</span>
    <span class="s2">&quot;set_executable&quot;</span><span class="p">,</span>
    <span class="s2">&quot;set_install_permissions&quot;</span><span class="p">,</span>
    <span class="s2">&quot;touch&quot;</span><span class="p">,</span>
    <span class="s2">&quot;touchp&quot;</span><span class="p">,</span>
    <span class="s2">&quot;traverse_tree&quot;</span><span class="p">,</span>
    <span class="s2">&quot;unset_executable_mode&quot;</span><span class="p">,</span>
    <span class="s2">&quot;working_dir&quot;</span><span class="p">,</span>
    <span class="s2">&quot;keep_modification_time&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BaseDirectoryVisitor&quot;</span><span class="p">,</span>
    <span class="s2">&quot;visit_directory_tree&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">Path</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">]</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
    <span class="c1"># monkeypatch shutil.copystat to fix PermissionError when copying read-only</span>
    <span class="c1"># files on Lustre when using Python &lt; 3.7.4</span>

    <span class="k">def</span> <span class="nf">copystat</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">follow_symlinks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy file metadata</span>
<span class="sd">        Copy the permission bits, last access time, last modification time, and</span>
<span class="sd">        flags from `src` to `dst`. On Linux, copystat() also copies the &quot;extended</span>
<span class="sd">        attributes&quot; where possible. The file contents, owner, and group are</span>
<span class="sd">        unaffected. `src` and `dst` are path names given as strings.</span>
<span class="sd">        If the optional flag `follow_symlinks` is not set, symlinks aren&#39;t</span>
<span class="sd">        followed if and only if both `src` and `dst` are symlinks.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_nop</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">follow_symlinks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="c1"># follow symlinks (aka don&#39;t not follow symlinks)</span>
        <span class="n">follow</span> <span class="o">=</span> <span class="n">follow_symlinks</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">islink</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="ow">and</span> <span class="n">islink</span><span class="p">(</span><span class="n">dst</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">follow</span><span class="p">:</span>
            <span class="c1"># use the real function if it exists</span>
            <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">_nop</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use the real function only if it exists</span>
            <span class="c1"># *and* it supports follow_symlinks</span>
            <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">_nop</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">supports_follow_symlinks</span><span class="p">:</span>  <span class="c1"># novermin</span>
                        <span class="k">return</span> <span class="n">fn</span>
                <span class="k">return</span> <span class="n">_nop</span>

        <span class="n">st</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="s2">&quot;stat&quot;</span><span class="p">)(</span><span class="n">src</span><span class="p">,</span> <span class="n">follow_symlinks</span><span class="o">=</span><span class="n">follow</span><span class="p">)</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IMODE</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span>
        <span class="n">lookup</span><span class="p">(</span><span class="s2">&quot;utime&quot;</span><span class="p">)(</span><span class="n">dst</span><span class="p">,</span> <span class="n">ns</span><span class="o">=</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">st_atime_ns</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">st_mtime_ns</span><span class="p">),</span> <span class="n">follow_symlinks</span><span class="o">=</span><span class="n">follow</span><span class="p">)</span>

        <span class="c1"># We must copy extended attributes before the file is (potentially)</span>
        <span class="c1"># chmod()&#39;ed read-only, otherwise setxattr() will error with -EACCES.</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">_copyxattr</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">follow_symlinks</span><span class="o">=</span><span class="n">follow</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">lookup</span><span class="p">(</span><span class="s2">&quot;chmod&quot;</span><span class="p">)(</span><span class="n">dst</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">follow_symlinks</span><span class="o">=</span><span class="n">follow</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="c1"># if we got a NotImplementedError, it&#39;s because</span>
            <span class="c1">#   * follow_symlinks=False,</span>
            <span class="c1">#   * lchown() is unavailable, and</span>
            <span class="c1">#   * either</span>
            <span class="c1">#       * fchownat() is unavailable or</span>
            <span class="c1">#       * fchownat() doesn&#39;t implement AT_SYMLINK_NOFOLLOW.</span>
            <span class="c1">#         (it returned ENOSUP.)</span>
            <span class="c1"># therefore we&#39;re out of options--we simply cannot chown the</span>
            <span class="c1"># symlink.  give up, suppress the error.</span>
            <span class="c1"># (which is what shutil always did in this circumstance.)</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="s2">&quot;st_flags&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lookup</span><span class="p">(</span><span class="s2">&quot;chflags&quot;</span><span class="p">)(</span><span class="n">dst</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">st_flags</span><span class="p">,</span> <span class="n">follow_symlinks</span><span class="o">=</span><span class="n">follow</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">why</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="s2">&quot;EOPNOTSUPP&quot;</span><span class="p">,</span> <span class="s2">&quot;ENOTSUP&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">errno</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span> <span class="ow">and</span> <span class="n">why</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">errno</span><span class="p">,</span> <span class="n">err</span><span class="p">):</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

    <span class="n">shutil</span><span class="o">.</span><span class="n">copystat</span> <span class="o">=</span> <span class="n">copystat</span>


<span class="k">def</span> <span class="nf">polite_path</span><span class="p">(</span><span class="n">components</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of strings which are intended to be path components,</span>
<span class="sd">    generate a path, and format each component to avoid generating extra</span>
<span class="sd">    path entries.</span>

<span class="sd">    For example all &quot;/&quot;, &quot;\&quot;, and &quot;:&quot; characters will be replaced with</span>
<span class="sd">    &quot;_&quot;. Other characters like &quot;=&quot; will also be replaced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">polite_filename</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">components</span><span class="p">])</span>


<span class="nd">@memoized</span>
<span class="k">def</span> <span class="nf">_polite_antipattern</span><span class="p">():</span>
    <span class="c1"># A regex of all the characters we don&#39;t want in a filename</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[^A-Za-z0-9_+.-]&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">polite_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace generally problematic filename characters with underscores.</span>

<span class="sd">    This differs from sanitize_filename in that it is more aggressive in</span>
<span class="sd">    changing characters in the name. For example it removes &quot;=&quot; which can</span>
<span class="sd">    confuse path parsing in external tools.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This character set applies for both Windows and Linux. It does not</span>
    <span class="c1"># account for reserved filenames in Windows.</span>
    <span class="k">return</span> <span class="n">_polite_antipattern</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>


<div class="viewcode-block" id="getuid">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.getuid">[docs]</a>
<span class="k">def</span> <span class="nf">getuid</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns os getuid on non Windows</span>
<span class="sd">    On Windows returns 0 for admin users, login string otherwise</span>
<span class="sd">    This is in line with behavior from get_owner_uid which</span>
<span class="sd">    always returns the login string on Windows</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">ctypes</span>

        <span class="c1"># If not admin, use the string name of the login as a unique ID</span>
        <span class="k">if</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">windll</span><span class="o">.</span><span class="n">shell32</span><span class="o">.</span><span class="n">IsUserAnAdmin</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">getlogin</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">getuid</span><span class="p">()</span></div>



<span class="k">def</span> <span class="nf">_win_rename</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
    <span class="c1"># os.replace will still fail if on Windows (but not POSIX) if the dst</span>
    <span class="c1"># is a symlink to a directory (all other cases have parity Windows &lt;-&gt; Posix)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">islink</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">dst</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">samefile</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
            <span class="c1"># src and dst are the same</span>
            <span class="c1"># do nothing and exit early</span>
            <span class="k">return</span>
        <span class="c1"># If dst exists and is a symlink to a directory</span>
        <span class="c1"># we need to remove dst and then perform rename/replace</span>
        <span class="c1"># this is safe to do as there&#39;s no chance src == dst now</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>


<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">msdos_escape_parens</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;MS-DOS interprets parens as grouping parameters even in a quoted string&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;^(&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;^)&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path</span>


<div class="viewcode-block" id="rename">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.rename">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
    <span class="c1"># On Windows, os.rename will fail if the destination file already exists</span>
    <span class="c1"># os.replace is the same as os.rename on POSIX and is MoveFileExW w/</span>
    <span class="c1"># the MOVEFILE_REPLACE_EXISTING flag on Windows</span>
    <span class="c1"># Windows invocation is abstracted behind additonal logic handling</span>
    <span class="c1"># remaining cases of divergent behavior accross platforms</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="n">_win_rename</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span></div>



<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">path_contains_subdirectory</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="n">norm_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">root</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span>
    <span class="n">norm_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span>
    <span class="k">return</span> <span class="n">norm_path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">norm_root</span><span class="p">)</span>


<span class="c1">#: This generates the library filenames that may appear on any OS.</span>
<span class="n">library_extensions</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;la&quot;</span><span class="p">,</span> <span class="s2">&quot;so&quot;</span><span class="p">,</span> <span class="s2">&quot;tbd&quot;</span><span class="p">,</span> <span class="s2">&quot;dylib&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">possible_library_filenames</span><span class="p">(</span><span class="n">library_names</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a collection of library names like &#39;libfoo&#39;, generate the set of</span>
<span class="sd">    library filenames that may be found on the system (e.g. libfoo.so).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lib_extensions</span> <span class="o">=</span> <span class="n">library_extensions</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span>
        <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">lib</span><span class="p">,</span> <span class="n">extension</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">lib</span><span class="p">,</span> <span class="n">extension</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">library_names</span><span class="p">,</span> <span class="n">lib_extensions</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">paths_containing_libs</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">library_names</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a collection of filesystem paths, return the list of paths that</span>
<span class="sd">    which include one or more of the specified libraries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">required_lib_fnames</span> <span class="o">=</span> <span class="n">possible_library_filenames</span><span class="p">(</span><span class="n">library_names</span><span class="p">)</span>

    <span class="n">rpaths_to_include</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="n">path_to_os_path</span><span class="p">(</span><span class="o">*</span><span class="n">paths</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="n">fnames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fnames</span> <span class="o">&amp;</span> <span class="n">required_lib_fnames</span><span class="p">:</span>
            <span class="n">rpaths_to_include</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rpaths_to_include</span>


<div class="viewcode-block" id="filter_file">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.filter_file">[docs]</a>
<span class="k">def</span> <span class="nf">filter_file</span><span class="p">(</span>
    <span class="n">regex</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">repl</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Match</span><span class="p">],</span> <span class="nb">str</span><span class="p">]],</span>
    <span class="o">*</span><span class="n">filenames</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">string</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">backup</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">ignore_absent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">start_at</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">stop_at</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">encoding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Like sed, but uses python regular expressions.</span>

<span class="sd">    Filters every line of each file through regex and replaces the file with a filtered version.</span>
<span class="sd">    Preserves mode of filtered files.</span>

<span class="sd">    As with re.sub, ``repl`` can be either a string or a callable. If it is a callable, it is</span>
<span class="sd">    passed the match object and should return a suitable replacement string.  If it is a string, it</span>
<span class="sd">    can contain ``\1``, ``\2``, etc. to represent back-substitution as sed would allow.</span>

<span class="sd">    Args:</span>
<span class="sd">        regex: The regular expression to search for</span>
<span class="sd">        repl: The string to replace matches with</span>
<span class="sd">        *filenames: One or more files to search and replace string: Treat regex as a plain string.</span>
<span class="sd">            Default it False backup: Make backup file(s) suffixed with ``~``. Default is False</span>
<span class="sd">        ignore_absent: Ignore any files that don&#39;t exist. Default is False</span>
<span class="sd">        start_at: Marker used to start applying the replacements. If a text line matches this</span>
<span class="sd">            marker filtering is started at the next line. All contents before the marker and the</span>
<span class="sd">            marker itself are copied verbatim. Default is to start filtering from the first line of</span>
<span class="sd">            the file.</span>
<span class="sd">        stop_at: Marker used to stop scanning the file further. If a text line matches this marker</span>
<span class="sd">            filtering is stopped and the rest of the file is copied verbatim. Default is to filter</span>
<span class="sd">            until the end of the file.</span>
<span class="sd">        encoding: The encoding to use when reading and writing the files. Default is None, which</span>
<span class="sd">            uses the system&#39;s default encoding.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Allow strings to use \1, \2, etc. for replacement, like sed</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">repl</span><span class="p">):</span>
        <span class="n">unescaped</span> <span class="o">=</span> <span class="n">repl</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">replace_groups_with_groupid</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">Match</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">groupid_to_group</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>

            <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">([1-9])&quot;</span><span class="p">,</span> <span class="n">groupid_to_group</span><span class="p">,</span> <span class="n">unescaped</span><span class="p">)</span>

        <span class="n">repl</span> <span class="o">=</span> <span class="n">replace_groups_with_groupid</span>

    <span class="k">if</span> <span class="n">string</span><span class="p">:</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
    <span class="n">regex_compiled</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">path_to_os_path</span><span class="p">(</span><span class="o">*</span><span class="n">filenames</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ignore_absent</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;FILTER FILE: file &quot;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s1">&quot; not found. Skipping to next file.&#39;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;FILTER FILE: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s1"> [replacing &quot;</span><span class="si">{</span><span class="n">regex</span><span class="si">}</span><span class="s1">&quot;]&#39;</span><span class="p">)</span>

        <span class="n">fd</span><span class="p">,</span> <span class="n">temp_path</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span>
            <span class="n">prefix</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>

        <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">temp_path</span><span class="p">)</span>
        <span class="n">errored</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Open as a text file and filter until the end of the file is reached, or we found a</span>
            <span class="c1"># marker in the line if it was specified. To avoid translating line endings (\n to</span>
            <span class="c1"># \r\n and vice-versa) use newline=&quot;&quot;.</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span>
                <span class="n">temp_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;surrogateescape&quot;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">input_file</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span>
                <span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;surrogateescape&quot;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">start_at</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop_at</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># common case, avoids branching in loop</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">input_file</span><span class="p">:</span>
                        <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">regex_compiled</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># state is -1 before start_at; 0 between; 1 after stop_at</span>
                    <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">start_at</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">input_file</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">stop_at</span> <span class="o">==</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                                <span class="n">state</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">line</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">regex_compiled</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">start_at</span> <span class="o">==</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                            <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="c1"># restore the original file</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">temp_path</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
            <span class="n">errored</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">raise</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">errored</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">backup</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">temp_path</span><span class="p">)</span></div>



<div class="viewcode-block" id="FileFilter">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.FileFilter">[docs]</a>
<span class="k">class</span> <span class="nc">FileFilter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convenience class for calling ``filter_file`` a lot.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">filenames</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filenames</span> <span class="o">=</span> <span class="n">filenames</span>

<div class="viewcode-block" id="FileFilter.filter">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.FileFilter.filter">[docs]</a>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">regex</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">repl</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Match</span><span class="p">],</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">string</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">backup</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_absent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">start_at</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stop_at</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">filter_file</span><span class="p">(</span>
            <span class="n">regex</span><span class="p">,</span>
            <span class="n">repl</span><span class="p">,</span>
            <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">filenames</span><span class="p">,</span>
            <span class="n">string</span><span class="o">=</span><span class="n">string</span><span class="p">,</span>
            <span class="n">backup</span><span class="o">=</span><span class="n">backup</span><span class="p">,</span>
            <span class="n">ignore_absent</span><span class="o">=</span><span class="n">ignore_absent</span><span class="p">,</span>
            <span class="n">start_at</span><span class="o">=</span><span class="n">start_at</span><span class="p">,</span>
            <span class="n">stop_at</span><span class="o">=</span><span class="n">stop_at</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="change_sed_delimiter">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.change_sed_delimiter">[docs]</a>
<span class="k">def</span> <span class="nf">change_sed_delimiter</span><span class="p">(</span><span class="n">old_delim</span><span class="p">,</span> <span class="n">new_delim</span><span class="p">,</span> <span class="o">*</span><span class="n">filenames</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find all sed search/replace commands and change the delimiter.</span>

<span class="sd">    e.g., if the file contains seds that look like ``&#39;s///&#39;``, you can</span>
<span class="sd">    call ``change_sed_delimiter(&#39;/&#39;, &#39;@&#39;, file)`` to change the</span>
<span class="sd">    delimiter to ``&#39;@&#39;``.</span>

<span class="sd">    Note that this routine will fail if the delimiter is ``&#39;`` or ``&quot;``.</span>
<span class="sd">    Handling those is left for future work.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        old_delim (str): The delimiter to search for</span>
<span class="sd">        new_delim (str): The delimiter to replace with</span>
<span class="sd">        *filenames: One or more files to search and replace</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_delim</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_delim</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="c1"># TODO: handle these cases one day?</span>
    <span class="k">assert</span> <span class="n">old_delim</span> <span class="o">!=</span> <span class="s1">&#39;&quot;&#39;</span>
    <span class="k">assert</span> <span class="n">old_delim</span> <span class="o">!=</span> <span class="s2">&quot;&#39;&quot;</span>
    <span class="k">assert</span> <span class="n">new_delim</span> <span class="o">!=</span> <span class="s1">&#39;&quot;&#39;</span>
    <span class="k">assert</span> <span class="n">new_delim</span> <span class="o">!=</span> <span class="s2">&quot;&#39;&quot;</span>

    <span class="n">whole_lines</span> <span class="o">=</span> <span class="s2">&quot;^s@([^@]*)@(.*)@[gIp]$&quot;</span>
    <span class="n">whole_lines</span> <span class="o">=</span> <span class="n">whole_lines</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">,</span> <span class="n">old_delim</span><span class="p">)</span>

    <span class="n">single_quoted</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&#39;s@((?:</span><span class="se">\\</span><span class="s2">&#39;|[^@&#39;])*)@((?:</span><span class="se">\\</span><span class="s2">&#39;|[^&#39;])*)@[gIp]?&#39;&quot;</span>
    <span class="n">single_quoted</span> <span class="o">=</span> <span class="n">single_quoted</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">,</span> <span class="n">old_delim</span><span class="p">)</span>

    <span class="n">double_quoted</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&quot;s@((?:</span><span class="se">\\</span><span class="s1">&quot;|[^@&quot;])*)@((?:</span><span class="se">\\</span><span class="s1">&quot;|[^&quot;])*)@[gIp]?&quot;&#39;</span>
    <span class="n">double_quoted</span> <span class="o">=</span> <span class="n">double_quoted</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">,</span> <span class="n">old_delim</span><span class="p">)</span>

    <span class="n">repl</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;s@\1@\2@g&quot;</span>
    <span class="n">repl</span> <span class="o">=</span> <span class="n">repl</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">,</span> <span class="n">new_delim</span><span class="p">)</span>
    <span class="n">filenames</span> <span class="o">=</span> <span class="n">path_to_os_path</span><span class="p">(</span><span class="o">*</span><span class="n">filenames</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
        <span class="n">filter_file</span><span class="p">(</span><span class="n">whole_lines</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">filter_file</span><span class="p">(</span><span class="n">single_quoted</span><span class="p">,</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">repl</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">filter_file</span><span class="p">(</span><span class="n">double_quoted</span><span class="p">,</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">repl</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>



<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">exploding_archive_catch</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
    <span class="c1"># Check for an exploding tarball, i.e. one that doesn&#39;t expand to</span>
    <span class="c1"># a single directory.  If the tarball *didn&#39;t* explode, move its</span>
    <span class="c1"># contents to the staging source directory &amp; remove the container</span>
    <span class="c1"># directory.  If the tarball did explode, just rename the tarball</span>
    <span class="c1"># directory to the staging source directory.</span>
    <span class="c1">#</span>
    <span class="c1"># NOTE: The tar program on Mac OS X will encode HFS metadata in</span>
    <span class="c1"># hidden files, which can end up *alongside* a single top-level</span>
    <span class="c1"># directory.  We initially ignore presence of hidden files to</span>
    <span class="c1"># accomodate these &quot;semi-exploding&quot; tarballs but ensure the files</span>
    <span class="c1"># are copied to the source directory.</span>

    <span class="c1"># Expand all tarballs in their own directory to contain</span>
    <span class="c1"># exploding tarballs.</span>
    <span class="n">tarball_container</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stage</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;spack-expanded-archive&quot;</span><span class="p">)</span>
    <span class="n">mkdirp</span><span class="p">(</span><span class="n">tarball_container</span><span class="p">)</span>
    <span class="n">orig_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">tarball_container</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
        <span class="c1"># catch an exploding archive on sucessful extraction</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">orig_dir</span><span class="p">)</span>
        <span class="n">exploding_archive_handler</span><span class="p">(</span><span class="n">tarball_container</span><span class="p">,</span> <span class="n">stage</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># return current directory context to previous on failure</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">orig_dir</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">e</span>


<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">exploding_archive_handler</span><span class="p">(</span><span class="n">tarball_container</span><span class="p">,</span> <span class="n">stage</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        tarball_container: where the archive was expanded to</span>
<span class="sd">        stage: Stage object referencing filesystem location</span>
<span class="sd">            where archive is being expanded</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">tarball_container</span><span class="p">)</span>
    <span class="n">non_hidden</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_hidden</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tarball_container</span><span class="p">,</span> <span class="n">non_hidden</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="n">stage</span><span class="o">.</span><span class="n">srcdir</span> <span class="o">=</span> <span class="n">non_hidden</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">stage</span><span class="o">.</span><span class="n">source_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">files</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">non_hidden</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                    <span class="n">src</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tarball_container</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                    <span class="n">dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stage</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">tarball_container</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is a non-directory entry (e.g., a patch file) so simply</span>
            <span class="c1"># rename the tarball container to be the source path.</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">tarball_container</span><span class="p">,</span> <span class="n">stage</span><span class="o">.</span><span class="n">source_path</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">tarball_container</span><span class="p">,</span> <span class="n">stage</span><span class="o">.</span><span class="n">source_path</span><span class="p">)</span>


<span class="nd">@system_path_filter</span><span class="p">(</span><span class="n">arg_slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">get_owner_uid</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns owner UID of path destination</span>
<span class="sd">    On non Windows this is the value of st_uid</span>
<span class="sd">    On Windows this is the login string associated with the</span>
<span class="sd">     owning user.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="n">mkdirp</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">stat</span><span class="o">.</span><span class="n">S_IRWXU</span><span class="p">)</span>

        <span class="n">p_stat</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p_stat</span><span class="o">.</span><span class="n">st_mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IRWXU</span> <span class="o">!=</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IRWXU</span><span class="p">:</span>
            <span class="n">tty</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Expected </span><span class="si">{0}</span><span class="s2"> to support mode </span><span class="si">{1}</span><span class="s2">, but it is </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">path</span><span class="p">,</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IRWXU</span><span class="p">,</span> <span class="n">p_stat</span><span class="o">.</span><span class="n">st_mode</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EACCES</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="k">if</span> <span class="n">err_msg</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_stat</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="n">owner_uid</span> <span class="o">=</span> <span class="n">p_stat</span><span class="o">.</span><span class="n">st_uid</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sid</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span>
            <span class="n">path</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">OWNER_SECURITY_INFORMATION</span>
        <span class="p">)</span><span class="o">.</span><span class="n">GetSecurityDescriptorOwner</span><span class="p">()</span>
        <span class="n">owner_uid</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">LookupAccountSid</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">sid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">owner_uid</span>


<div class="viewcode-block" id="set_install_permissions">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.set_install_permissions">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">set_install_permissions</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set appropriate permissions on the installed file.&quot;&quot;&quot;</span>
    <span class="c1"># If this points to a file maintained in a Spack prefix, it is assumed that</span>
    <span class="c1"># this function will be invoked on the target. If the file is outside a</span>
    <span class="c1"># Spack-maintained prefix, the permissions should not be modified.</span>
    <span class="k">if</span> <span class="n">islink</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mo">0o755</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mo">0o644</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">group_ids</span><span class="p">(</span><span class="n">uid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get group ids that a uid is a member of.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        uid (int): id of user, or None for current user</span>

<span class="sd">    Returns:</span>
<span class="sd">        (list of int): gids of groups the user is a member of</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="n">tty</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Function is not supported on Windows&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">uid</span> <span class="o">=</span> <span class="n">getuid</span><span class="p">()</span>

    <span class="n">pwd_entry</span> <span class="o">=</span> <span class="n">pwd</span><span class="o">.</span><span class="n">getpwuid</span><span class="p">(</span><span class="n">uid</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">pwd_entry</span><span class="o">.</span><span class="n">pw_name</span>

    <span class="c1"># user&#39;s primary group id may not be listed in grp (i.e. /etc/group)</span>
    <span class="c1"># you have to check pwd for that, so start the list with that</span>
    <span class="n">gids</span> <span class="o">=</span> <span class="p">[</span><span class="n">pwd_entry</span><span class="o">.</span><span class="n">pw_gid</span><span class="p">]</span>

    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">gids</span> <span class="o">+</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">gr_gid</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">getgrall</span><span class="p">()</span> <span class="k">if</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">gr_mem</span><span class="p">]))</span>


<div class="viewcode-block" id="chgrp">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.chgrp">[docs]</a>
<span class="nd">@system_path_filter</span><span class="p">(</span><span class="n">arg_slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">chgrp</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">follow_symlinks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implement the bash chgrp function on a single path&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Function &#39;chgrp&#39; is not supported on Windows&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">gid</span> <span class="o">=</span> <span class="n">grp</span><span class="o">.</span><span class="n">getgrnam</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="o">.</span><span class="n">gr_gid</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gid</span> <span class="o">=</span> <span class="n">group</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_gid</span> <span class="o">==</span> <span class="n">gid</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">follow_symlinks</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chown</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">gid</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">lchown</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">gid</span><span class="p">)</span></div>



<div class="viewcode-block" id="chmod_x">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.chmod_x">[docs]</a>
<span class="nd">@system_path_filter</span><span class="p">(</span><span class="n">arg_slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">chmod_x</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">perms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements chmod, treating all executable bits as set using the chmod</span>
<span class="sd">    utility&#39;s `+X` option.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">S_IXUSR</span> <span class="o">|</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXGRP</span> <span class="o">|</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXOTH</span><span class="p">):</span>
            <span class="n">perms</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">stat</span><span class="o">.</span><span class="n">S_IXUSR</span>
            <span class="n">perms</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">stat</span><span class="o">.</span><span class="n">S_IXGRP</span>
            <span class="n">perms</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">stat</span><span class="o">.</span><span class="n">S_IXOTH</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">perms</span><span class="p">)</span></div>



<div class="viewcode-block" id="copy_mode">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.copy_mode">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">copy_mode</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the mode of dest to that of src unless it is a link.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">islink</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="n">src_mode</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span>
    <span class="n">dest_mode</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span>
    <span class="k">if</span> <span class="n">src_mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXUSR</span><span class="p">:</span>
        <span class="n">dest_mode</span> <span class="o">|=</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXUSR</span>
    <span class="k">if</span> <span class="n">src_mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXGRP</span><span class="p">:</span>
        <span class="n">dest_mode</span> <span class="o">|=</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXGRP</span>
    <span class="k">if</span> <span class="n">src_mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXOTH</span><span class="p">:</span>
        <span class="n">dest_mode</span> <span class="o">|=</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXOTH</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">dest_mode</span><span class="p">)</span></div>



<div class="viewcode-block" id="unset_executable_mode">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.unset_executable_mode">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">unset_executable_mode</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span>
    <span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">stat</span><span class="o">.</span><span class="n">S_IXUSR</span>
    <span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">stat</span><span class="o">.</span><span class="n">S_IXGRP</span>
    <span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">stat</span><span class="o">.</span><span class="n">S_IXOTH</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>



<div class="viewcode-block" id="copy">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.copy">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">_permissions</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Copy the file(s) *src* to the file or directory *dest*.</span>

<span class="sd">    If *dest* specifies a directory, the file will be copied into *dest*</span>
<span class="sd">    using the base filename from *src*.</span>

<span class="sd">    *src* may contain glob characters.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        src (str): the file(s) to copy</span>
<span class="sd">        dest (str): the destination file or directory</span>
<span class="sd">        _permissions (bool): for internal use only</span>

<span class="sd">    Raises:</span>
<span class="sd">        IOError: if *src* does not match any files or directories</span>
<span class="sd">        ValueError: if *src* matches multiple files but *dest* is</span>
<span class="sd">            not a directory</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_permissions</span><span class="p">:</span>
        <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Installing </span><span class="si">{0}</span><span class="s2"> to </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Copying </span><span class="si">{0}</span><span class="s2"> to </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">))</span>

    <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">files</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;No such file or directory: &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;&#39;</span><span class="si">{0}</span><span class="s2">&#39; matches multiple files but &#39;</span><span class="si">{1}</span><span class="s2">&#39; is not a directory&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="c1"># Expand dest to its eventual full path if it is a directory.</span>
        <span class="n">dst</span> <span class="o">=</span> <span class="n">dest</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
            <span class="n">dst</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>

        <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_permissions</span><span class="p">:</span>
            <span class="n">set_install_permissions</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>
            <span class="n">copy_mode</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span></div>



<div class="viewcode-block" id="install">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.install">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">install</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Install the file(s) *src* to the file or directory *dest*.</span>

<span class="sd">    Same as :py:func:`copy` with the addition of setting proper</span>
<span class="sd">    permissions on the installed file.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        src (str): the file(s) to install</span>
<span class="sd">        dest (str): the destination file or directory</span>

<span class="sd">    Raises:</span>
<span class="sd">        IOError: if *src* does not match any files or directories</span>
<span class="sd">        ValueError: if *src* matches multiple files but *dest* is</span>
<span class="sd">            not a directory</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">copy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">_permissions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



<div class="viewcode-block" id="copy_tree">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.copy_tree">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">copy_tree</span><span class="p">(</span>
    <span class="n">src</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">symlinks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">ignore</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">_permissions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recursively copy an entire directory tree rooted at *src*.</span>

<span class="sd">    If the destination directory *dest* does not already exist, it will</span>
<span class="sd">    be created as well as missing parent directories.</span>

<span class="sd">    *src* may contain glob characters.</span>

<span class="sd">    If *symlinks* is true, symbolic links in the source tree are represented</span>
<span class="sd">    as symbolic links in the new tree and the metadata of the original links</span>
<span class="sd">    will be copied as far as the platform allows; if false, the contents and</span>
<span class="sd">    metadata of the linked files are copied to the new tree.</span>

<span class="sd">    If *ignore* is set, then each path relative to *src* will be passed to</span>
<span class="sd">    this function; the function returns whether that path should be skipped.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        src (str): the directory to copy</span>
<span class="sd">        dest (str): the destination directory</span>
<span class="sd">        symlinks (bool): whether or not to preserve symlinks</span>
<span class="sd">        ignore (typing.Callable): function indicating which files to ignore</span>
<span class="sd">        _permissions (bool): for internal use only</span>

<span class="sd">    Raises:</span>
<span class="sd">        IOError: if *src* does not match any files or directories</span>
<span class="sd">        ValueError: if *src* is a parent directory of *dest*</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_permissions</span><span class="p">:</span>
        <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Installing </span><span class="si">{0}</span><span class="s2"> to </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Copying </span><span class="si">{0}</span><span class="s2"> to </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">))</span>

    <span class="n">abs_dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">abs_dest</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">):</span>
        <span class="n">abs_dest</span> <span class="o">+=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span>

    <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">files</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;No such file or directory: &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>

    <span class="c1"># For Windows hard-links and junctions, the source path must exist to make a symlink. Add</span>
    <span class="c1"># all symlinks to this list while traversing the tree, then when finished, make all</span>
    <span class="c1"># symlinks at the end.</span>
    <span class="n">links</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="n">abs_src</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">abs_src</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">):</span>
            <span class="n">abs_src</span> <span class="o">+=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span>

        <span class="c1"># Stop early to avoid unnecessary recursion if being asked to copy</span>
        <span class="c1"># from a parent directory.</span>
        <span class="k">if</span> <span class="n">abs_dest</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">abs_src</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot copy ancestor directory </span><span class="si">{0}</span><span class="s2"> into </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">abs_src</span><span class="p">,</span> <span class="n">abs_dest</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">mkdirp</span><span class="p">(</span><span class="n">abs_dest</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">traverse_tree</span><span class="p">(</span>
            <span class="n">abs_src</span><span class="p">,</span>
            <span class="n">abs_dest</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="s2">&quot;pre&quot;</span><span class="p">,</span>
            <span class="n">follow_links</span><span class="o">=</span><span class="ow">not</span> <span class="n">symlinks</span><span class="p">,</span>
            <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">,</span>
            <span class="n">follow_nonexisting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">islink</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">link_target</span> <span class="o">=</span> <span class="n">resolve_link_target_relative_to_the_link</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">symlinks</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">readlink</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>

                        <span class="k">def</span> <span class="nf">escaped_path</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                            <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>

                        <span class="n">new_target</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">escaped_path</span><span class="p">(</span><span class="n">abs_src</span><span class="p">),</span> <span class="n">escaped_path</span><span class="p">(</span><span class="n">abs_dest</span><span class="p">),</span> <span class="n">target</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">new_target</span> <span class="o">!=</span> <span class="n">target</span><span class="p">:</span>
                            <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Redirecting link </span><span class="si">{0}</span><span class="s2"> to </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">new_target</span><span class="p">))</span>
                            <span class="n">target</span> <span class="o">=</span> <span class="n">new_target</span>

                    <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">target</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
                    <span class="k">continue</span>

                <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">link_target</span><span class="p">):</span>
                    <span class="n">mkdirp</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="n">mkdirp</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">copy2</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">_permissions</span><span class="p">:</span>
                <span class="n">set_install_permissions</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">copy_mode</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="n">symlink</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_permissions</span><span class="p">:</span>
            <span class="n">set_install_permissions</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">copy_mode</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span></div>



<div class="viewcode-block" id="install_tree">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.install_tree">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">install_tree</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">symlinks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recursively install an entire directory tree rooted at *src*.</span>

<span class="sd">    Same as :py:func:`copy_tree` with the addition of setting proper</span>
<span class="sd">    permissions on the installed files and directories.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        src (str): the directory to install</span>
<span class="sd">        dest (str): the destination directory</span>
<span class="sd">        symlinks (bool): whether or not to preserve symlinks</span>
<span class="sd">        ignore (typing.Callable): function indicating which files to ignore</span>

<span class="sd">    Raises:</span>
<span class="sd">        IOError: if *src* does not match any files or directories</span>
<span class="sd">        ValueError: if *src* is a parent directory of *dest*</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">copy_tree</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">symlinks</span><span class="o">=</span><span class="n">symlinks</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">,</span> <span class="n">_permissions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



<div class="viewcode-block" id="is_exe">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.is_exe">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">is_exe</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;True if path is an executable file.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">X_OK</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">has_shebang</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns whether a path has a shebang line. Returns False if the file cannot be opened.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">&quot;#!&quot;</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">is_nonsymlink_exe_with_shebang</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns whether the path is an executable regular file with a shebang. Returns False too</span>
<span class="sd">    when the path is a symlink to a script, and also when the file cannot be opened.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">lstat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Should not be a symlink</span>
    <span class="k">if</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">st_mode</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Should be executable</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="o">.</span><span class="n">st_mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">S_IXUSR</span> <span class="o">|</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXGRP</span> <span class="o">|</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXOTH</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">has_shebang</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>


<span class="nd">@system_path_filter</span><span class="p">(</span><span class="n">arg_slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">chgrp_if_not_world_writable</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;chgrp path to group if path is not world writable&quot;&quot;&quot;</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IWOTH</span><span class="p">:</span>
        <span class="n">chgrp</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>


<div class="viewcode-block" id="mkdirp">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.mkdirp">[docs]</a>
<span class="k">def</span> <span class="nf">mkdirp</span><span class="p">(</span>
    <span class="o">*</span><span class="n">paths</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">group</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">default_perms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a directory, as well as parent directories if needed.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        paths: paths to create with mkdirp</span>
<span class="sd">        mode: optional permissions to set on the created directory -- use OS default</span>
<span class="sd">            if not provided</span>
<span class="sd">        group: optional group for permissions of final created directory -- use OS</span>
<span class="sd">            default if not provided. Only used if world write permissions are not set</span>
<span class="sd">        default_perms: one of &#39;parents&#39; or &#39;args&#39;. The default permissions that are set for</span>
<span class="sd">            directories that are not themselves an argument for mkdirp. &#39;parents&#39; means</span>
<span class="sd">            intermediate directories get the permissions of their direct parent directory,</span>
<span class="sd">            &#39;args&#39; means intermediate get the same permissions specified in the arguments to</span>
<span class="sd">            mkdirp -- default value is &#39;args&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">default_perms</span> <span class="o">=</span> <span class="n">default_perms</span> <span class="ow">or</span> <span class="s2">&quot;args&quot;</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="n">path_to_os_path</span><span class="p">(</span><span class="o">*</span><span class="n">paths</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">last_parent</span><span class="p">,</span> <span class="n">intermediate_folders</span> <span class="o">=</span> <span class="n">longest_existing_parent</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

                <span class="c1"># create folders</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

                <span class="c1"># leaf folder permissions</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">group</span><span class="p">:</span>
                    <span class="n">chgrp_if_not_world_writable</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>  <span class="c1"># reset sticky grp bit post chgrp</span>

                <span class="c1"># for intermediate folders, change mode just for newly created</span>
                <span class="c1"># ones and if mode_intermediate has been specified, otherwise</span>
                <span class="c1"># intermediate folders list is not populated at all and default</span>
                <span class="c1"># OS mode will be used</span>
                <span class="k">if</span> <span class="n">default_perms</span> <span class="o">==</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span>
                    <span class="n">intermediate_mode</span> <span class="o">=</span> <span class="n">mode</span>
                    <span class="n">intermediate_group</span> <span class="o">=</span> <span class="n">group</span>
                <span class="k">elif</span> <span class="n">default_perms</span> <span class="o">==</span> <span class="s2">&quot;parents&quot;</span><span class="p">:</span>
                    <span class="n">stat_info</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">last_parent</span><span class="p">)</span>
                    <span class="n">intermediate_mode</span> <span class="o">=</span> <span class="n">stat_info</span><span class="o">.</span><span class="n">st_mode</span>
                    <span class="n">intermediate_group</span> <span class="o">=</span> <span class="n">stat_info</span><span class="o">.</span><span class="n">st_gid</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid value: &#39;</span><span class="si">%s</span><span class="s2">&#39;. &quot;</span> <span class="o">%</span> <span class="n">default_perms</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;Choose from &#39;args&#39; or &#39;parents&#39;.&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">intermediate_path</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">intermediate_folders</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">intermediate_mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">intermediate_path</span><span class="p">,</span> <span class="n">intermediate_mode</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">intermediate_group</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">chgrp_if_not_world_writable</span><span class="p">(</span><span class="n">intermediate_path</span><span class="p">,</span> <span class="n">intermediate_group</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">intermediate_mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span>
                                <span class="n">intermediate_path</span><span class="p">,</span> <span class="n">intermediate_mode</span>
                            <span class="p">)</span>  <span class="c1"># reset sticky bit after</span>

            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">EEXIST</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">e</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EEXIST</span><span class="p">,</span> <span class="s2">&quot;File already exists&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">longest_existing_parent</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the last existing parent and a list of all intermediate directories</span>
<span class="sd">    to be created for the directory passed as input.</span>

<span class="sd">    Args:</span>
<span class="sd">        path: directory to be created</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># detect missing intermediate folders</span>
    <span class="n">intermediate_folders</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">last_parent</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">intermediate_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">intermediate_path</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">lexists</span><span class="p">(</span><span class="n">intermediate_path</span><span class="p">):</span>
            <span class="n">last_parent</span> <span class="o">=</span> <span class="n">intermediate_path</span>
            <span class="k">break</span>

        <span class="n">intermediate_folders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intermediate_path</span><span class="p">)</span>
        <span class="n">intermediate_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">intermediate_path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">last_parent</span><span class="p">,</span> <span class="n">intermediate_folders</span>


<div class="viewcode-block" id="force_remove">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.force_remove">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">force_remove</span><span class="p">(</span><span class="o">*</span><span class="n">paths</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove files without printing errors.  Like ``rm -f``, does NOT</span>
<span class="sd">    remove directories.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">pass</span></div>



<div class="viewcode-block" id="working_dir">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.working_dir">[docs]</a>
<span class="nd">@contextmanager</span>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">working_dir</span><span class="p">(</span><span class="n">dirname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">create</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">create</span><span class="p">:</span>
        <span class="n">mkdirp</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>

    <span class="n">orig_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">orig_dir</span><span class="p">)</span></div>



<span class="k">class</span> <span class="nc">CouldNotRestoreDirectoryBackup</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inner_exception</span><span class="p">,</span> <span class="n">outer_exception</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner_exception</span> <span class="o">=</span> <span class="n">inner_exception</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_exception</span> <span class="o">=</span> <span class="n">outer_exception</span>


<span class="nd">@contextmanager</span>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">replace_directory_transaction</span><span class="p">(</span><span class="n">directory_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Temporarily renames a directory in the same parent dir. If the operations</span>
<span class="sd">    executed within the context manager don&#39;t raise an exception, the renamed directory</span>
<span class="sd">    is deleted. If there is an exception, the move is undone.</span>

<span class="sd">    Args:</span>
<span class="sd">        directory_name (path): absolute path of the directory name</span>

<span class="sd">    Returns:</span>
<span class="sd">        temporary directory where ``directory_name`` has been moved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check the input is indeed a directory with absolute path.</span>
    <span class="c1"># Raise before anything is done to avoid moving the wrong directory</span>
    <span class="n">directory_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">directory_name</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">directory_name</span><span class="p">),</span> <span class="s2">&quot;Not a directory: &quot;</span> <span class="o">+</span> <span class="n">directory_name</span>

    <span class="c1"># Note: directory_name is normalized here, meaning the trailing slash is dropped,</span>
    <span class="c1"># so dirname is the directory&#39;s parent not the directory itself.</span>
    <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">directory_name</span><span class="p">),</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;.backup&quot;</span><span class="p">)</span>

    <span class="c1"># We have to jump through hoops to support Windows, since</span>
    <span class="c1"># os.rename(directory_name, tmpdir) errors there.</span>
    <span class="n">backup_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span> <span class="s2">&quot;backup&quot;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">directory_name</span><span class="p">,</span> <span class="n">backup_dir</span><span class="p">)</span>
    <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Directory moved [src=</span><span class="si">{0}</span><span class="s2">, dest=</span><span class="si">{1}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">directory_name</span><span class="p">,</span> <span class="n">backup_dir</span><span class="p">))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">backup_dir</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">Exception</span><span class="p">,</span> <span class="ne">KeyboardInterrupt</span><span class="p">,</span> <span class="ne">SystemExit</span><span class="p">)</span> <span class="k">as</span> <span class="n">inner_exception</span><span class="p">:</span>
        <span class="c1"># Try to recover the original directory, if this fails, raise a</span>
        <span class="c1"># composite exception.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Delete what was there, before copying back the original content</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">directory_name</span><span class="p">):</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">directory_name</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">backup_dir</span><span class="p">,</span> <span class="n">directory_name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">outer_exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CouldNotRestoreDirectoryBackup</span><span class="p">(</span><span class="n">inner_exception</span><span class="p">,</span> <span class="n">outer_exception</span><span class="p">)</span>

        <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Directory recovered [</span><span class="si">{0}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">directory_name</span><span class="p">))</span>
        <span class="k">raise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise delete the temporary directory</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Temporary directory deleted [</span><span class="si">{0}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">))</span>


<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">hash_directory</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Hashes recursively the content of a directory.</span>

<span class="sd">    Args:</span>
<span class="sd">        directory (path): path to a directory to be hashed</span>

<span class="sd">    Returns:</span>
<span class="sd">        hash of the directory content</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">directory</span><span class="p">),</span> <span class="s1">&#39;&quot;directory&quot; must be a directory!&#39;</span>

    <span class="n">md5_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>

    <span class="c1"># Adapted from https://stackoverflow.com/a/3431835/771663</span>
    <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">:</span>
                <span class="c1"># TODO: if caching big files becomes an issue, convert this to</span>
                <span class="c1"># TODO: read in chunks. Currently it&#39;s used only for testing</span>
                <span class="c1"># TODO: purposes.</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">md5_hash</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">md5_hash</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>


<span class="nd">@contextmanager</span>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">write_tmp_and_move</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write to a temporary file, then move into place.&quot;&quot;&quot;</span>
    <span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s2">&quot;.</span><span class="si">%s</span><span class="s2">.tmp&quot;</span> <span class="o">%</span> <span class="n">basename</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">f</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>


<div class="viewcode-block" id="touch">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.touch">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">touch</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates an empty file at the specified path.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="n">perms</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">O_CREAT</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">perms</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">O_NONBLOCK</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">O_NOCTTY</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">perms</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">utime</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span></div>



<div class="viewcode-block" id="touchp">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.touchp">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">touchp</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Like ``touch``, but creates any parent directories needed for the file.&quot;&quot;&quot;</span>
    <span class="n">mkdirp</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="n">touch</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>



<div class="viewcode-block" id="force_symlink">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.force_symlink">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">force_symlink</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">symlink</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
        <span class="n">symlink</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span></div>



<div class="viewcode-block" id="join_path">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.join_path">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">join_path</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">elt</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">path</span></div>



<div class="viewcode-block" id="ancestor">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.ancestor">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">ancestor</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the nth ancestor of a directory.&quot;&quot;&quot;</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parent</span></div>



<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">get_single_file</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
    <span class="n">fnames</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected exactly 1 file, got </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fnames</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">fnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">windows_sfn</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns 8.3 Filename (SFN) representation of</span>
<span class="sd">    path</span>

<span class="sd">    8.3 Filenames (SFN or short filename) is a file</span>
<span class="sd">    naming convention used prior to Win95 that Windows</span>
<span class="sd">    still (and will continue to) support. This convention</span>
<span class="sd">    caps filenames at 8 characters, and most importantly</span>
<span class="sd">    does not allow for spaces in addition to other specifications.</span>
<span class="sd">    The scheme is generally the same as a normal Windows</span>
<span class="sd">    file scheme, but all spaces are removed and the filename</span>
<span class="sd">    is capped at 6 characters. The remaining characters are</span>
<span class="sd">    replaced with ~N where N is the number file in a directory</span>
<span class="sd">    that a given file represents i.e. Program Files and Program Files (x86)</span>
<span class="sd">    would be PROGRA~1 and PROGRA~2 respectively.</span>
<span class="sd">    Further, all file/directory names are all caps (although modern Windows</span>
<span class="sd">    is case insensitive in practice).</span>
<span class="sd">    Conversion is accomplished by fileapi.h GetShortPathNameW</span>

<span class="sd">    Returns paths in 8.3 Filename form</span>

<span class="sd">    Note: this method is a no-op on Linux</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Path to be transformed into SFN (8.3 filename) format</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This should not be run-able on linux/macos</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path</span>
    <span class="n">path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">ctypes</span>

    <span class="n">k32</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">WinDLL</span><span class="p">(</span><span class="s2">&quot;kernel32&quot;</span><span class="p">,</span> <span class="n">use_last_error</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Method with null values returns size of short path name</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">k32</span><span class="o">.</span><span class="n">GetShortPathNameW</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># stub Windows types TCHAR[LENGTH]</span>
    <span class="n">TCHAR_arr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_wchar</span> <span class="o">*</span> <span class="n">sz</span>
    <span class="n">ret_str</span> <span class="o">=</span> <span class="n">TCHAR_arr</span><span class="p">()</span>
    <span class="n">k32</span><span class="o">.</span><span class="n">GetShortPathNameW</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">ret_str</span><span class="p">),</span> <span class="n">sz</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret_str</span><span class="o">.</span><span class="n">value</span>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">temp_cwd</span><span class="p">():</span>
    <span class="n">tmp_dir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">working_dir</span><span class="p">(</span><span class="n">tmp_dir</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">tmp_dir</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;ignore_errors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;onerror&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">readonly_file_handler</span><span class="p">(</span><span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">tmp_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="can_access">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.can_access">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">can_access</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;True if we have read/write access to the file.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">R_OK</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">W_OK</span><span class="p">)</span></div>



<div class="viewcode-block" id="traverse_tree">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.traverse_tree">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">traverse_tree</span><span class="p">(</span>
    <span class="n">source_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">dest_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">rel_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="n">ignore</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">follow_nonexisting</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">follow_links</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Traverse two filesystem trees simultaneously.</span>

<span class="sd">    Walks the LinkTree directory in pre or post order.  Yields each</span>
<span class="sd">    file in the source directory with a matching path from the dest</span>
<span class="sd">    directory, along with whether the file is a directory.</span>
<span class="sd">    e.g., for this tree::</span>

<span class="sd">        root/</span>
<span class="sd">          a/</span>
<span class="sd">            file1</span>
<span class="sd">            file2</span>
<span class="sd">          b/</span>
<span class="sd">            file3</span>

<span class="sd">    When called on dest, this yields::</span>

<span class="sd">        (&#39;root&#39;,         &#39;dest&#39;)</span>
<span class="sd">        (&#39;root/a&#39;,       &#39;dest/a&#39;)</span>
<span class="sd">        (&#39;root/a/file1&#39;, &#39;dest/a/file1&#39;)</span>
<span class="sd">        (&#39;root/a/file2&#39;, &#39;dest/a/file2&#39;)</span>
<span class="sd">        (&#39;root/b&#39;,       &#39;dest/b&#39;)</span>
<span class="sd">        (&#39;root/b/file3&#39;, &#39;dest/b/file3&#39;)</span>

<span class="sd">    Keyword Arguments:</span>
<span class="sd">        order (str): Whether to do pre- or post-order traversal. Accepted</span>
<span class="sd">            values are &#39;pre&#39; and &#39;post&#39;</span>
<span class="sd">        ignore (typing.Callable): function indicating which files to ignore. This will also</span>
<span class="sd">            ignore symlinks if they point to an ignored file (regardless of whether the symlink</span>
<span class="sd">            is explicitly ignored); note this only supports one layer of indirection (i.e. if</span>
<span class="sd">            you have x -&gt; y -&gt; z, and z is ignored but x/y are not, then y would be ignored</span>
<span class="sd">            but not x). To avoid this, make sure the ignore function also ignores the symlink</span>
<span class="sd">            paths too.</span>
<span class="sd">        follow_nonexisting (bool): Whether to descend into directories in</span>
<span class="sd">            ``src`` that do not exit in ``dest``. Default is True</span>
<span class="sd">        follow_links (bool): Whether to descend into symlinks in ``src``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">order</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;pre&quot;</span><span class="p">,</span> <span class="s2">&quot;post&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Order must be &#39;pre&#39; or &#39;post&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># List of relative paths to ignore under the src root.</span>
    <span class="n">ignore</span> <span class="o">=</span> <span class="n">ignore</span> <span class="ow">or</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">filename</span><span class="p">:</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Don&#39;t descend into ignored directories</span>
    <span class="k">if</span> <span class="n">ignore</span><span class="p">(</span><span class="n">rel_path</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="n">source_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source_root</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">)</span>
    <span class="n">dest_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dest_root</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">)</span>

    <span class="c1"># preorder yields directories before children</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;pre&quot;</span><span class="p">:</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">source_path</span><span class="p">,</span> <span class="n">dest_path</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">source_path</span><span class="p">):</span>
        <span class="n">source_child</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source_path</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">dest_child</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dest_path</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">rel_child</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rel_path</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

        <span class="c1"># If the source path is a link and the link&#39;s source is ignored, then ignore the link too,</span>
        <span class="c1"># but only do this if the ignore is defined.</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">islink</span><span class="p">(</span><span class="n">source_child</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">follow_links</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">readlink</span><span class="p">(</span><span class="n">source_child</span><span class="p">)</span>
                <span class="n">all_parents</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ignore</span><span class="p">,</span> <span class="n">all_parents</span><span class="p">)):</span>
                    <span class="n">tty</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">source_path</span><span class="si">}</span><span class="s2"> because the source or a part of the source&#39;s &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;path is included in the ignores.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>

        <span class="c1"># Treat as a directory</span>
        <span class="c1"># TODO: for symlinks, os.path.isdir looks for the link target. If the</span>
        <span class="c1"># target is relative to the link, then that may not resolve properly</span>
        <span class="c1"># relative to our cwd - see resolve_link_target_relative_to_the_link</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">source_child</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">follow_links</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">islink</span><span class="p">(</span><span class="n">source_child</span><span class="p">)):</span>
            <span class="c1"># When follow_nonexisting isn&#39;t set, don&#39;t descend into dirs</span>
            <span class="c1"># in source that do not exist in dest</span>
            <span class="k">if</span> <span class="n">follow_nonexisting</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest_child</span><span class="p">):</span>
                <span class="n">tuples</span> <span class="o">=</span> <span class="n">traverse_tree</span><span class="p">(</span>
                    <span class="n">source_root</span><span class="p">,</span>
                    <span class="n">dest_root</span><span class="p">,</span>
                    <span class="n">rel_child</span><span class="p">,</span>
                    <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                    <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">,</span>
                    <span class="n">follow_nonexisting</span><span class="o">=</span><span class="n">follow_nonexisting</span><span class="p">,</span>
                    <span class="n">follow_links</span><span class="o">=</span><span class="n">follow_links</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tuples</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">t</span>

        <span class="c1"># Treat as a file.</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">ignore</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rel_path</span><span class="p">,</span> <span class="n">f</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">source_child</span><span class="p">,</span> <span class="n">dest_child</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;post&quot;</span><span class="p">:</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">source_path</span><span class="p">,</span> <span class="n">dest_path</span><span class="p">)</span></div>



<div class="viewcode-block" id="BaseDirectoryVisitor">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.BaseDirectoryVisitor">[docs]</a>
<span class="k">class</span> <span class="nc">BaseDirectoryVisitor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class and interface for :py:func:`visit_directory_tree`.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="BaseDirectoryVisitor.visit_file">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.BaseDirectoryVisitor.visit_file">[docs]</a>
    <span class="k">def</span> <span class="nf">visit_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handle the non-symlink file at ``os.path.join(root, rel_path)``</span>

<span class="sd">        Parameters:</span>
<span class="sd">            root: root directory</span>
<span class="sd">            rel_path: relative path to current file from ``root``</span>
<span class="sd">            depth (int): depth of current file from the ``root`` directory&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="BaseDirectoryVisitor.visit_symlinked_file">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.BaseDirectoryVisitor.visit_symlinked_file">[docs]</a>
    <span class="k">def</span> <span class="nf">visit_symlinked_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handle the symlink to a file at ``os.path.join(root, rel_path)``. Note: ``rel_path`` is</span>
<span class="sd">        the location of the symlink, not to what it is pointing to. The symlink may be dangling.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            root: root directory</span>
<span class="sd">            rel_path: relative path to current symlink from ``root``</span>
<span class="sd">            depth: depth of current symlink from the ``root`` directory&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="BaseDirectoryVisitor.before_visit_dir">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.BaseDirectoryVisitor.before_visit_dir">[docs]</a>
    <span class="k">def</span> <span class="nf">before_visit_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True from this function to recurse into the directory at</span>
<span class="sd">        os.path.join(root, rel_path). Return False in order not to recurse further.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            root: root directory</span>
<span class="sd">            rel_path: relative path to current directory from ``root``</span>
<span class="sd">            depth: depth of current directory from the ``root`` directory</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` when the directory should be recursed into. ``False`` when</span>
<span class="sd">            not&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="BaseDirectoryVisitor.before_visit_symlinked_dir">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.BaseDirectoryVisitor.before_visit_symlinked_dir">[docs]</a>
    <span class="k">def</span> <span class="nf">before_visit_symlinked_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``True`` to recurse into the symlinked directory and ``False`` in order not to.</span>
<span class="sd">        Note: ``rel_path`` is the path to the symlink itself. Following symlinked directories</span>
<span class="sd">        blindly can cause infinite recursion due to cycles.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            root: root directory</span>
<span class="sd">            rel_path: relative path to current symlink from ``root``</span>
<span class="sd">            depth: depth of current symlink from the ``root`` directory</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` when the directory should be recursed into. ``False`` when</span>
<span class="sd">            not&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="BaseDirectoryVisitor.after_visit_dir">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.BaseDirectoryVisitor.after_visit_dir">[docs]</a>
    <span class="k">def</span> <span class="nf">after_visit_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Called after recursion into ``rel_path`` finished. This function is not called when</span>
<span class="sd">        ``rel_path`` was not recursed into.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            root: root directory</span>
<span class="sd">            rel_path: relative path to current directory from ``root``</span>
<span class="sd">            depth: depth of current directory from the ``root`` directory&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="BaseDirectoryVisitor.after_visit_symlinked_dir">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.BaseDirectoryVisitor.after_visit_symlinked_dir">[docs]</a>
    <span class="k">def</span> <span class="nf">after_visit_symlinked_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Called after recursion into ``rel_path`` finished. This function is not called when</span>
<span class="sd">        ``rel_path`` was not recursed into.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            root: root directory</span>
<span class="sd">            rel_path: relative path to current symlink from ``root``</span>
<span class="sd">            depth: depth of current symlink from the ``root`` directory&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
</div>



<div class="viewcode-block" id="visit_directory_tree">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.visit_directory_tree">[docs]</a>
<span class="k">def</span> <span class="nf">visit_directory_tree</span><span class="p">(</span>
    <span class="n">root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">visitor</span><span class="p">:</span> <span class="n">BaseDirectoryVisitor</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recurses the directory root depth-first through a visitor pattern using the interface from</span>
<span class="sd">    :py:class:`BaseDirectoryVisitor`</span>

<span class="sd">    Parameters:</span>
<span class="sd">        root: path of directory to recurse into</span>
<span class="sd">        visitor: what visitor to use</span>
<span class="sd">        rel_path: current relative path from the root</span>
<span class="sd">        depth: current depth from the root</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">)</span>
    <span class="n">dir_entries</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">scandir</span><span class="p">(</span><span class="nb">dir</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">dir_entries</span><span class="p">:</span>
        <span class="n">rel_child</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rel_path</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">islink</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">is_symlink</span><span class="p">()</span>
        <span class="c1"># On Windows, symlinks to directories are distinct from symlinks to files, and it is</span>
        <span class="c1"># possible to create a broken symlink to a directory (e.g. using os.symlink without</span>
        <span class="c1"># `target_is_directory=True`), invoking `isdir` on a symlink on Windows that is broken in</span>
        <span class="c1"># this manner will result in an error. In this case we can work around the issue by reading</span>
        <span class="c1"># the target and resolving the directory ourselves</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">isdir</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">is_dir</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="s2">&quot;winerror&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">winerror</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">and</span> <span class="n">islink</span><span class="p">:</span>
                <span class="c1"># if path is a symlink, determine destination and evaluate file vs directory</span>
                <span class="n">link_target</span> <span class="o">=</span> <span class="n">resolve_link_target_relative_to_the_link</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="c1"># link_target might be relative but resolve_link_target_relative_to_the_link</span>
                <span class="c1"># will ensure that if so, that it is relative to the CWD and therefore makes sense</span>
                <span class="n">isdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">link_target</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">islink</span><span class="p">:</span>
            <span class="c1"># handle non-symlink files</span>
            <span class="n">visitor</span><span class="o">.</span><span class="n">visit_file</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rel_child</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">:</span>
            <span class="n">visitor</span><span class="o">.</span><span class="n">visit_symlinked_file</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rel_child</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">islink</span> <span class="ow">and</span> <span class="n">visitor</span><span class="o">.</span><span class="n">before_visit_dir</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rel_child</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
            <span class="c1"># Handle ordinary directories</span>
            <span class="n">visit_directory_tree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">visitor</span><span class="p">,</span> <span class="n">rel_child</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">visitor</span><span class="o">.</span><span class="n">after_visit_dir</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rel_child</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">islink</span> <span class="ow">and</span> <span class="n">visitor</span><span class="o">.</span><span class="n">before_visit_symlinked_dir</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rel_child</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
            <span class="c1"># Handle symlinked directories</span>
            <span class="n">visit_directory_tree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">visitor</span><span class="p">,</span> <span class="n">rel_child</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">visitor</span><span class="o">.</span><span class="n">after_visit_symlinked_dir</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rel_child</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span></div>



<div class="viewcode-block" id="set_executable">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.set_executable">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">set_executable</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IRUSR</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">|=</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXUSR</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IRGRP</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">|=</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXGRP</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IROTH</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">|=</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXOTH</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>



<div class="viewcode-block" id="last_modification_time_recursive">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.last_modification_time_recursive">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">last_modification_time_recursive</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mtime</span><span class="p">]</span>
    <span class="n">times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">lstat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span><span class="o">.</span><span class="n">st_mtime</span>
        <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dirs</span> <span class="o">+</span> <span class="n">files</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">times</span><span class="p">)</span></div>



<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">remove_empty_directories</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ascend up from the leaves accessible from `root` and remove empty</span>
<span class="sd">    directories.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        root (str): path where to search for empty directories</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">subdirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">topdown</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">subdirs</span><span class="p">:</span>
            <span class="n">sdp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">sdp</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">pass</span>


<div class="viewcode-block" id="remove_dead_links">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.remove_dead_links">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">remove_dead_links</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recursively removes any dead link that is present in root.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        root (str): path where to search for dead links</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">subdirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">topdown</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="n">remove_if_dead_link</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>



<div class="viewcode-block" id="remove_if_dead_link">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.remove_if_dead_link">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">remove_if_dead_link</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes the argument if it is a dead link.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        path (str): The potential dead link</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">islink</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">readonly_file_handler</span><span class="p">(</span><span class="n">ignore_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># TODO: generate stages etc. with write permissions wherever</span>
    <span class="c1"># so this callback is no-longer required</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate callback for shutil.rmtree to handle permissions errors on</span>
<span class="sd">    Windows. Some files may unexpectedly lack write permissions even</span>
<span class="sd">    though they were generated by Spack on behalf of the user (e.g. the</span>
<span class="sd">    stage), so this callback will detect such cases and modify the</span>
<span class="sd">    permissions if that is the issue. For other errors, the fallback</span>
<span class="sd">    is either to raise (if ignore_errors is False) or ignore (if</span>
<span class="sd">    ignore_errors is True). This is only intended for Windows systems</span>
<span class="sd">    and will raise a separate error if it is ever invoked (by accident)</span>
<span class="sd">    on a non-Windows system.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">error_remove_readonly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;This method should only be invoked on Windows&quot;</span><span class="p">)</span>
        <span class="n">excvalue</span> <span class="o">=</span> <span class="n">exc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span>
            <span class="ow">and</span> <span class="n">func</span> <span class="ow">in</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">excvalue</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EACCES</span>
        <span class="p">):</span>
            <span class="c1"># change the file to be readable,writable,executable: 0777</span>
            <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IRWXU</span> <span class="o">|</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IRWXG</span> <span class="o">|</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IRWXO</span><span class="p">)</span>
            <span class="c1"># retry</span>
            <span class="n">func</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">ignore_errors</span><span class="p">:</span>
            <span class="k">raise</span>

    <span class="k">return</span> <span class="n">error_remove_readonly</span>


<div class="viewcode-block" id="remove_linked_tree">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.remove_linked_tree">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">remove_linked_tree</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes a directory and its contents.</span>

<span class="sd">    If the directory is a symlink, follows the link and removes the real</span>
<span class="sd">    directory before removing the link.</span>

<span class="sd">    This method will force-delete files on Windows</span>

<span class="sd">    Parameters:</span>
<span class="sd">        path (str): Directory to be removed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ignore_errors&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

    <span class="c1"># Windows readonly files cannot be removed by Python</span>
    <span class="c1"># directly.</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;ignore_errors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;onerror&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">readonly_file_handler</span><span class="p">(</span><span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">islink</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
                <span class="c1"># Adding this prefix allows shutil to remove long paths on windows</span>
                <span class="c1"># https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry</span>
                <span class="n">long_path_pfx</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">?</span><span class="se">\\</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">long_path_pfx</span><span class="p">):</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">long_path_pfx</span> <span class="o">+</span> <span class="n">path</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<span class="nd">@contextmanager</span>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">safe_remove</span><span class="p">(</span><span class="o">*</span><span class="n">files_or_dirs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context manager to remove the files passed as input, but restore</span>
<span class="sd">    them in case any exception is raised in the context block.</span>

<span class="sd">    Args:</span>
<span class="sd">        *files_or_dirs: glob expressions for files or directories</span>
<span class="sd">            to be removed</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dictionary that maps deleted files to their temporary copy</span>
<span class="sd">        within the context block.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find all the files or directories that match</span>
    <span class="n">glob_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">files_or_dirs</span><span class="p">]</span>
    <span class="c1"># Sort them so that shorter paths like &quot;/foo/bar&quot; come before</span>
    <span class="c1"># nested paths like &quot;/foo/bar/baz.yaml&quot;. This simplifies the</span>
    <span class="c1"># handling of temporary copies below</span>
    <span class="n">sorted_matches</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">glob_matches</span><span class="p">)],</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>

    <span class="c1"># Copy files and directories in a temporary location</span>
    <span class="n">removed</span><span class="p">,</span> <span class="n">dst_root</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">file_or_dir</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_matches</span><span class="p">):</span>
            <span class="c1"># The glob expression at the top ensures that the file/dir exists</span>
            <span class="c1"># at the time we enter the loop. Double check here since it might</span>
            <span class="c1"># happen that a previous iteration of the loop already removed it.</span>
            <span class="c1"># This is the case, for instance, if we remove the directory</span>
            <span class="c1"># &quot;/foo/bar&quot; before the file &quot;/foo/bar/baz.yaml&quot;.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file_or_dir</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># The monotonic ID is a simple way to make the filename</span>
            <span class="c1"># or directory name unique in the temporary folder</span>
            <span class="n">basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file_or_dir</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
            <span class="n">temporary_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst_root</span><span class="p">,</span> <span class="n">basename</span><span class="p">)</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">file_or_dir</span><span class="p">,</span> <span class="n">temporary_path</span><span class="p">)</span>
            <span class="n">removed</span><span class="p">[</span><span class="n">file_or_dir</span><span class="p">]</span> <span class="o">=</span> <span class="n">temporary_path</span>
        <span class="k">yield</span> <span class="n">removed</span>
    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="c1"># Restore the files that were removed</span>
        <span class="k">for</span> <span class="n">original_path</span><span class="p">,</span> <span class="n">temporary_path</span> <span class="ow">in</span> <span class="n">removed</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">temporary_path</span><span class="p">,</span> <span class="n">original_path</span><span class="p">)</span>
        <span class="k">raise</span>


<div class="viewcode-block" id="find_first">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.find_first">[docs]</a>
<span class="k">def</span> <span class="nf">find_first</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">files</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span> <span class="n">bfs_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the first file matching a pattern.</span>

<span class="sd">    The following</span>

<span class="sd">    .. code-block:: console</span>

<span class="sd">       $ find /usr -name &#39;abc*&#39; -o -name &#39;def*&#39; -quit</span>

<span class="sd">    is equivalent to:</span>

<span class="sd">    &gt;&gt;&gt; find_first(&quot;/usr&quot;, [&quot;abc*&quot;, &quot;def*&quot;])</span>

<span class="sd">    Any glob pattern supported by fnmatch can be used.</span>

<span class="sd">    The search order of this method is breadth-first over directories,</span>
<span class="sd">    until depth bfs_depth, after which depth-first search is used.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        root (str): The root directory to start searching from</span>
<span class="sd">        files (str or Iterable): File pattern(s) to search for</span>
<span class="sd">        bfs_depth (int): (advanced) parameter that specifies at which</span>
<span class="sd">            depth to switch to depth-first search.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str or None: The matching file or None when no file is found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">files</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">FindFirstFile</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">*</span><span class="n">files</span><span class="p">,</span> <span class="n">bfs_depth</span><span class="o">=</span><span class="n">bfs_depth</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">()</span></div>



<div class="viewcode-block" id="find">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.find">[docs]</a>
<span class="k">def</span> <span class="nf">find</span><span class="p">(</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Path</span><span class="p">]],</span>
    <span class="n">files</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">max_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finds all files matching the patterns from ``files`` starting from ``root``. This function</span>
<span class="sd">    returns a deterministic result for the same input and directory structure when run multiple</span>
<span class="sd">    times. Symlinked directories are followed, and unique directories are searched only once. Each</span>
<span class="sd">    matching file is returned only once at lowest depth in case multiple paths exist due to</span>
<span class="sd">    symlinked directories.</span>

<span class="sd">    Accepts any glob characters accepted by fnmatch:</span>

<span class="sd">    ==========  ====================================</span>
<span class="sd">    Pattern     Meaning</span>
<span class="sd">    ==========  ====================================</span>
<span class="sd">    ``*``       matches one or more characters</span>
<span class="sd">    ``?``       matches any single character</span>
<span class="sd">    ``[seq]``   matches any character in ``seq``</span>
<span class="sd">    ``[!seq]``  matches any character not in ``seq``</span>
<span class="sd">    ==========  ====================================</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; find(&quot;/usr&quot;, &quot;*.txt&quot;, recursive=True, max_depth=2)</span>

<span class="sd">    finds all files with the extension ``.txt`` in the directory ``/usr`` and subdirectories up to</span>
<span class="sd">    depth 2.</span>

<span class="sd">    &gt;&gt;&gt; find([&quot;/usr&quot;, &quot;/var&quot;], [&quot;*.txt&quot;, &quot;*.log&quot;], recursive=True)</span>

<span class="sd">    finds all files with the extension ``.txt`` or ``.log`` in the directories ``/usr`` and</span>
<span class="sd">    ``/var`` at any depth.</span>

<span class="sd">    &gt;&gt;&gt; find(&quot;/usr&quot;, &quot;GL/*.h&quot;, recursive=True)</span>

<span class="sd">    finds all header files in a directory GL at any depth in the directory ``/usr``.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        root: One or more root directories to start searching from</span>
<span class="sd">        files: One or more filename patterns to search for</span>
<span class="sd">        recursive: if False search only root, if True descends from roots. Defaults to True.</span>
<span class="sd">        max_depth: if set, don&#39;t search below this depth. Cannot be set if recursive is False</span>

<span class="sd">    Returns a list of absolute, matching file paths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">)):</span>
        <span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;root&#39; arg must be a path or a sequence of paths, not &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">root</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;]&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">files</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;files&#39; arg must be str or a sequence of str, not &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">files</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;]&quot;</span><span class="p">)</span>

    <span class="c1"># If recursive is false, max_depth can only be None or 0</span>
    <span class="k">if</span> <span class="n">max_depth</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">recursive</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_depth (</span><span class="si">{</span><span class="n">max_depth</span><span class="si">}</span><span class="s2">) cannot be set if recursive is False&quot;</span><span class="p">)</span>

    <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Find (max depth = </span><span class="si">{</span><span class="n">max_depth</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">root</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">files</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">recursive</span><span class="p">:</span>
        <span class="n">max_depth</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">max_depth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_depth</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_find_max_depth</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">)</span>
    <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Find complete: </span><span class="si">{</span><span class="n">root</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">files</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>



<span class="k">def</span> <span class="nf">_log_file_access_issue</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="ne">OSError</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">errno_name</span> <span class="o">=</span> <span class="n">errno</span><span class="o">.</span><span class="n">errorcode</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">errno</span><span class="p">,</span> <span class="s2">&quot;UNKNOWN&quot;</span><span class="p">)</span>
    <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;find must skip </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">errno_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_file_id</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">stat_result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="c1"># Note: on windows, st_ino is the file index and st_dev is the volume serial number. See</span>
    <span class="c1"># https://github.com/python/cpython/blob/3.9/Python/fileutils.c</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">st_ino</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">st_dev</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_dedupe_files</span><span class="p">(</span><span class="n">paths</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deduplicate files by inode and device, dropping files that cannot be accessed.&quot;&quot;&quot;</span>
    <span class="n">unique_files</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># tuple of (inode, device) for each file without following symlinks</span>
    <span class="n">visited</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">stat_info</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">lstat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">_log_file_access_issue</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">file_id</span> <span class="o">=</span> <span class="n">_file_id</span><span class="p">(</span><span class="n">stat_info</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">file_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">unique_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">file_id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unique_files</span>


<span class="k">def</span> <span class="nf">_find_max_depth</span><span class="p">(</span>
    <span class="n">roots</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Path</span><span class="p">],</span> <span class="n">globs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">max_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See ``find`` for the public API.&quot;&quot;&quot;</span>
    <span class="c1"># We optimize for the common case of simple filename only patterns: a single, combined regex</span>
    <span class="c1"># is used. For complex patterns that include path components, we use a slower glob call from</span>
    <span class="c1"># every directory we visit within max_depth.</span>
    <span class="n">filename_only_patterns</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sa">f</span><span class="s2">&quot;pattern_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normcase</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">globs</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;/&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span>
    <span class="p">}</span>
    <span class="n">complex_patterns</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;pattern_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">globs</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;/&quot;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">}</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">fnmatch_translate_multiple</span><span class="p">(</span><span class="n">filename_only_patterns</span><span class="p">))</span>
    <span class="c1"># Ordered dictionary that keeps track of what pattern found which files</span>
    <span class="n">matched_paths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;pattern_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">globs</span><span class="p">)}</span>
    <span class="c1"># Ensure returned paths are always absolute</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">]</span>
    <span class="c1"># Breadth-first search queue. Each element is a tuple of (depth, dir)</span>
    <span class="n">dir_queue</span><span class="p">:</span> <span class="n">Deque</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
    <span class="c1"># Set of visited directories. Each element is a tuple of (inode, device)</span>
    <span class="n">visited_dirs</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">stat_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">_log_file_access_issue</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">dir_id</span> <span class="o">=</span> <span class="n">_file_id</span><span class="p">(</span><span class="n">stat_root</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dir_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_dirs</span><span class="p">:</span>
            <span class="n">dir_queue</span><span class="o">.</span><span class="n">appendleft</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">root</span><span class="p">))</span>
            <span class="n">visited_dirs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dir_id</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">dir_queue</span><span class="p">:</span>
        <span class="n">depth</span><span class="p">,</span> <span class="n">curr_dir</span> <span class="o">=</span> <span class="n">dir_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dir_iter</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">scandir</span><span class="p">(</span><span class="n">curr_dir</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">_log_file_access_issue</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">curr_dir</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Use glob.glob for complex patterns.</span>
        <span class="k">for</span> <span class="n">pattern_name</span><span class="p">,</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">complex_patterns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">matched_paths</span><span class="p">[</span><span class="n">pattern_name</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">path</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">curr_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="c1"># List of subdirectories by path and (inode, device) tuple</span>
        <span class="n">subdirs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">with</span> <span class="n">dir_iter</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dir_entry</span> <span class="ow">in</span> <span class="n">dir_iter</span><span class="p">:</span>

                <span class="c1"># Match filename only patterns</span>
                <span class="k">if</span> <span class="n">filename_only_patterns</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normcase</span><span class="p">(</span><span class="n">dir_entry</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">pattern_name</span> <span class="ow">in</span> <span class="n">filename_only_patterns</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pattern_name</span><span class="p">):</span>
                                <span class="n">matched_paths</span><span class="p">[</span><span class="n">pattern_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dir_entry</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                                <span class="k">break</span>

                <span class="c1"># Collect subdirectories</span>
                <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;=</span> <span class="n">max_depth</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">dir_entry</span><span class="o">.</span><span class="n">is_dir</span><span class="p">(</span><span class="n">follow_symlinks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
                        <span class="c1"># Note: st_ino/st_dev on DirEntry.stat are not set on Windows, so we have</span>
                        <span class="c1"># to call os.stat</span>
                        <span class="n">stat_info</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">dir_entry</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">follow_symlinks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stat_info</span> <span class="o">=</span> <span class="n">dir_entry</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">follow_symlinks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="c1"># Possible permission issue, or a symlink that cannot be resolved (ELOOP).</span>
                    <span class="n">_log_file_access_issue</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">dir_entry</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">subdirs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dir_entry</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">_file_id</span><span class="p">(</span><span class="n">stat_info</span><span class="p">)))</span>

        <span class="c1"># Enqueue subdirectories in a deterministic order</span>
        <span class="k">if</span> <span class="n">subdirs</span><span class="p">:</span>
            <span class="n">subdirs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">subdir</span><span class="p">,</span> <span class="n">subdir_id</span> <span class="ow">in</span> <span class="n">subdirs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">subdir_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_dirs</span><span class="p">:</span>
                    <span class="n">dir_queue</span><span class="o">.</span><span class="n">appendleft</span><span class="p">((</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">subdir</span><span class="p">))</span>
                    <span class="n">visited_dirs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">subdir_id</span><span class="p">)</span>

    <span class="c1"># Sort the matched paths for deterministic output</span>
    <span class="k">for</span> <span class="n">paths</span> <span class="ow">in</span> <span class="n">matched_paths</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">paths</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">all_matching_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span> <span class="k">for</span> <span class="n">paths</span> <span class="ow">in</span> <span class="n">matched_paths</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">]</span>

    <span class="c1"># We only dedupe files if we have any complex patterns, since only they can match the same file</span>
    <span class="c1"># multiple times</span>
    <span class="k">return</span> <span class="n">_dedupe_files</span><span class="p">(</span><span class="n">all_matching_paths</span><span class="p">)</span> <span class="k">if</span> <span class="n">complex_patterns</span> <span class="k">else</span> <span class="n">all_matching_paths</span>


<span class="c1"># Utilities for libraries and headers</span>


<div class="viewcode-block" id="FileList">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.FileList">[docs]</a>
<span class="k">class</span> <span class="nc">FileList</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sequence of absolute paths to files.</span>

<span class="sd">    Provides a few convenience methods to manipulate file paths.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">files</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dedupe</span><span class="p">(</span><span class="n">files</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">directories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stable de-duplication of the directories where the files reside.</span>

<span class="sd">        &gt;&gt;&gt; l = LibraryList([&#39;/dir1/liba.a&#39;, &#39;/dir2/libb.a&#39;, &#39;/dir1/libc.a&#39;])</span>
<span class="sd">        &gt;&gt;&gt; l.directories</span>
<span class="sd">        [&#39;/dir1&#39;, &#39;/dir2&#39;]</span>
<span class="sd">        &gt;&gt;&gt; h = HeaderList([&#39;/dir1/a.h&#39;, &#39;/dir1/b.h&#39;, &#39;/dir2/c.h&#39;])</span>
<span class="sd">        &gt;&gt;&gt; h.directories</span>
<span class="sd">        [&#39;/dir1&#39;, &#39;/dir2&#39;]</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of directories</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">dedupe</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">basenames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stable de-duplication of the base-names in the list</span>

<span class="sd">        &gt;&gt;&gt; l = LibraryList([&#39;/dir1/liba.a&#39;, &#39;/dir2/libb.a&#39;, &#39;/dir3/liba.a&#39;])</span>
<span class="sd">        &gt;&gt;&gt; l.basenames</span>
<span class="sd">        [&#39;liba.a&#39;, &#39;libb.a&#39;]</span>
<span class="sd">        &gt;&gt;&gt; h = HeaderList([&#39;/dir1/a.h&#39;, &#39;/dir2/b.h&#39;, &#39;/dir3/a.h&#39;])</span>
<span class="sd">        &gt;&gt;&gt; h.basenames</span>
<span class="sd">        [&#39;a.h&#39;, &#39;b.h&#39;]</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of base-names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">dedupe</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">dedupe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">files</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">)</span>

<div class="viewcode-block" id="FileList.joined">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.FileList.joined">[docs]</a>
    <span class="k">def</span> <span class="nf">joined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">joined</span><span class="p">()</span></div>



<div class="viewcode-block" id="HeaderList">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.HeaderList">[docs]</a>
<span class="k">class</span> <span class="nc">HeaderList</span><span class="p">(</span><span class="n">FileList</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sequence of absolute paths to headers.</span>

<span class="sd">    Provides a few convenience methods to manipulate header paths and get</span>
<span class="sd">    commonly used compiler flags or names.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make sure to only match complete words, otherwise path components such</span>
    <span class="c1"># as &quot;xinclude&quot; will cause false matches.</span>
    <span class="c1"># Avoid matching paths such as &lt;prefix&gt;/include/something/detail/include,</span>
    <span class="c1"># e.g. in the CUDA Toolkit which ships internal libc++ headers.</span>
    <span class="n">include_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(.*?)(\binclude\b)(.*)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_macro_definitions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_directories</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">directories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Directories to be searched for header files.&quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_directories</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_directories</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">dedupe</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

    <span class="nd">@directories</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">directories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="c1"># Accept a single directory as input</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_directories</span> <span class="o">=</span> <span class="p">[</span><span class="n">path_to_os_path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_default_directories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Default computation of directories based on the list of</span>
<span class="sd">        header files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dir_list</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">directories</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dir_list</span><span class="p">:</span>
            <span class="c1"># If the path contains a subdirectory named &#39;include&#39; then stop</span>
            <span class="c1"># there and don&#39;t add anything else to the path.</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="k">if</span> <span class="n">m</span> <span class="k">else</span> <span class="n">d</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">headers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stable de-duplication of the headers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of header files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stable de-duplication of header names in the list without extensions</span>

<span class="sd">        &gt;&gt;&gt; h = HeaderList([&#39;/dir1/a.h&#39;, &#39;/dir2/b.h&#39;, &#39;/dir3/a.h&#39;])</span>
<span class="sd">        &gt;&gt;&gt; h.names</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;]</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of files without extensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basenames</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">x</span>

            <span class="c1"># Valid extensions include: [&#39;.cuh&#39;, &#39;.hpp&#39;, &#39;.hh&#39;, &#39;.h&#39;]</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;.cuh&quot;</span><span class="p">,</span> <span class="s2">&quot;.hpp&quot;</span><span class="p">,</span> <span class="s2">&quot;.hh&quot;</span><span class="p">,</span> <span class="s2">&quot;.h&quot;</span><span class="p">]:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No valid extension, should we still include it?</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">dedupe</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">include_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Include flags</span>

<span class="sd">        &gt;&gt;&gt; h = HeaderList([&#39;/dir1/a.h&#39;, &#39;/dir1/b.h&#39;, &#39;/dir2/c.h&#39;])</span>
<span class="sd">        &gt;&gt;&gt; h.include_flags</span>
<span class="sd">        &#39;-I/dir1 -I/dir2&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: A joined list of include flags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;-I&quot;</span> <span class="o">+</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">directories</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">macro_definitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Macro definitions</span>

<span class="sd">        &gt;&gt;&gt; h = HeaderList([&#39;/dir1/a.h&#39;, &#39;/dir1/b.h&#39;, &#39;/dir2/c.h&#39;])</span>
<span class="sd">        &gt;&gt;&gt; h.add_macro(&#39;-DBOOST_LIB_NAME=boost_regex&#39;)</span>
<span class="sd">        &gt;&gt;&gt; h.add_macro(&#39;-DBOOST_DYN_LINK&#39;)</span>
<span class="sd">        &gt;&gt;&gt; h.macro_definitions</span>
<span class="sd">        &#39;-DBOOST_LIB_NAME=boost_regex -DBOOST_DYN_LINK&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: A joined list of macro definitions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_macro_definitions</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cpp_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Include flags + macro definitions</span>

<span class="sd">        &gt;&gt;&gt; h = HeaderList([&#39;/dir1/a.h&#39;, &#39;/dir1/b.h&#39;, &#39;/dir2/c.h&#39;])</span>
<span class="sd">        &gt;&gt;&gt; h.cpp_flags</span>
<span class="sd">        &#39;-I/dir1 -I/dir2&#39;</span>
<span class="sd">        &gt;&gt;&gt; h.add_macro(&#39;-DBOOST_DYN_LINK&#39;)</span>
<span class="sd">        &gt;&gt;&gt; h.cpp_flags</span>
<span class="sd">        &#39;-I/dir1 -I/dir2 -DBOOST_DYN_LINK&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: A joined list of include flags and macro definitions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cpp_flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_flags</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">macro_definitions</span><span class="p">:</span>
            <span class="n">cpp_flags</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">macro_definitions</span>
        <span class="k">return</span> <span class="n">cpp_flags</span>

<div class="viewcode-block" id="HeaderList.add_macro">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.HeaderList.add_macro">[docs]</a>
    <span class="k">def</span> <span class="nf">add_macro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">macro</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a macro definition</span>

<span class="sd">        Parameters:</span>
<span class="sd">            macro (str): The macro to add</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_macro_definitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">macro</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="find_headers">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.find_headers">[docs]</a>
<span class="k">def</span> <span class="nf">find_headers</span><span class="p">(</span><span class="n">headers</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns an iterable object containing a list of full paths to</span>
<span class="sd">    headers if found.</span>

<span class="sd">    Accepts any glob characters accepted by fnmatch:</span>

<span class="sd">    =======  ====================================</span>
<span class="sd">    Pattern  Meaning</span>
<span class="sd">    =======  ====================================</span>
<span class="sd">    *        matches everything</span>
<span class="sd">    ?        matches any single character</span>
<span class="sd">    [seq]    matches any character in ``seq``</span>
<span class="sd">    [!seq]   matches any character not in ``seq``</span>
<span class="sd">    =======  ====================================</span>

<span class="sd">    Parameters:</span>
<span class="sd">        headers (str or list): Header name(s) to search for</span>
<span class="sd">        root (str): The root directory to start searching from</span>
<span class="sd">        recursive (bool): if False search only root folder,</span>
<span class="sd">            if True descends top-down from the root. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HeaderList: The headers that have been found</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">headers</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="n">headers</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">headers</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> expects a string or sequence of strings as the &quot;</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;first argument [got </span><span class="si">{1}</span><span class="s2"> instead]&quot;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">find_headers</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">headers</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="c1"># Construct the right suffix for the headers</span>
    <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># C</span>
        <span class="s2">&quot;h&quot;</span><span class="p">,</span>
        <span class="c1"># C++</span>
        <span class="s2">&quot;hpp&quot;</span><span class="p">,</span>
        <span class="s2">&quot;hxx&quot;</span><span class="p">,</span>
        <span class="s2">&quot;hh&quot;</span><span class="p">,</span>
        <span class="s2">&quot;H&quot;</span><span class="p">,</span>
        <span class="s2">&quot;txx&quot;</span><span class="p">,</span>
        <span class="s2">&quot;tcc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;icc&quot;</span><span class="p">,</span>
        <span class="c1"># Fortran</span>
        <span class="s2">&quot;mod&quot;</span><span class="p">,</span>
        <span class="s2">&quot;inc&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># List of headers we are searching with suffixes</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span> <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">headers</span> <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">suffixes</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">HeaderList</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">recursive</span><span class="p">))</span></div>



<div class="viewcode-block" id="find_all_headers">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.find_all_headers">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">find_all_headers</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convenience function that returns the list of all headers found</span>
<span class="sd">    in the directory passed as argument.</span>

<span class="sd">    Args:</span>
<span class="sd">        root (str): directory where to look recursively for header files</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of all headers found in ``root`` and subdirectories.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">find_headers</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



<div class="viewcode-block" id="LibraryList">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.LibraryList">[docs]</a>
<span class="k">class</span> <span class="nc">LibraryList</span><span class="p">(</span><span class="n">FileList</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sequence of absolute paths to libraries</span>

<span class="sd">    Provides a few convenience methods to manipulate library paths and get</span>
<span class="sd">    commonly used compiler flags or names</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">libraries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stable de-duplication of library files.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of library files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stable de-duplication of library names in the list</span>

<span class="sd">        &gt;&gt;&gt; l = LibraryList([&#39;/dir1/liba.a&#39;, &#39;/dir2/libb.a&#39;, &#39;/dir3/liba.so&#39;])</span>
<span class="sd">        &gt;&gt;&gt; l.names</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;]</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of library names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basenames</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;lib&quot;</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>

            <span class="c1"># Valid extensions include: [&#39;.dylib&#39;, &#39;.so&#39;, &#39;.a&#39;]</span>
            <span class="c1"># on non Windows platform</span>
            <span class="c1"># Windows valid library extensions are:</span>
            <span class="c1"># [&#39;.dll&#39;, &#39;.lib&#39;]</span>
            <span class="n">valid_exts</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;.dll&quot;</span><span class="p">,</span> <span class="s2">&quot;.lib&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;.dylib&quot;</span><span class="p">,</span> <span class="s2">&quot;.so&quot;</span><span class="p">,</span> <span class="s2">&quot;.a&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">valid_exts</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No valid extension, should we still include it?</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">dedupe</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">search_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Search flags for the libraries</span>

<span class="sd">        &gt;&gt;&gt; l = LibraryList([&#39;/dir1/liba.a&#39;, &#39;/dir2/libb.a&#39;, &#39;/dir1/liba.so&#39;])</span>
<span class="sd">        &gt;&gt;&gt; l.search_flags</span>
<span class="sd">        &#39;-L/dir1 -L/dir2&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: A joined list of search flags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;-L&quot;</span> <span class="o">+</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">directories</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">link_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Link flags for the libraries</span>

<span class="sd">        &gt;&gt;&gt; l = LibraryList([&#39;/dir1/liba.a&#39;, &#39;/dir2/libb.a&#39;, &#39;/dir1/liba.so&#39;])</span>
<span class="sd">        &gt;&gt;&gt; l.link_flags</span>
<span class="sd">        &#39;-la -lb&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: A joined list of link flags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;-l&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ld_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Search flags + link flags</span>

<span class="sd">        &gt;&gt;&gt; l = LibraryList([&#39;/dir1/liba.a&#39;, &#39;/dir2/libb.a&#39;, &#39;/dir1/liba.so&#39;])</span>
<span class="sd">        &gt;&gt;&gt; l.ld_flags</span>
<span class="sd">        &#39;-L/dir1 -L/dir2 -la -lb&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: A joined list of search flags and link flags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_flags</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">link_flags</span></div>



<div class="viewcode-block" id="find_system_libraries">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.find_system_libraries">[docs]</a>
<span class="k">def</span> <span class="nf">find_system_libraries</span><span class="p">(</span><span class="n">libraries</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Searches the usual system library locations for ``libraries``.</span>

<span class="sd">    Search order is as follows:</span>

<span class="sd">    1. ``/lib64``</span>
<span class="sd">    2. ``/lib``</span>
<span class="sd">    3. ``/usr/lib64``</span>
<span class="sd">    4. ``/usr/lib``</span>
<span class="sd">    5. ``/usr/local/lib64``</span>
<span class="sd">    6. ``/usr/local/lib``</span>

<span class="sd">    Accepts any glob characters accepted by fnmatch:</span>

<span class="sd">    =======  ====================================</span>
<span class="sd">    Pattern  Meaning</span>
<span class="sd">    =======  ====================================</span>
<span class="sd">    *        matches everything</span>
<span class="sd">    ?        matches any single character</span>
<span class="sd">    [seq]    matches any character in ``seq``</span>
<span class="sd">    [!seq]   matches any character not in ``seq``</span>
<span class="sd">    =======  ====================================</span>

<span class="sd">    Parameters:</span>
<span class="sd">        libraries (str or list): Library name(s) to search for</span>
<span class="sd">        shared (bool): if True searches for shared libraries,</span>
<span class="sd">            otherwise for static. Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LibraryList: The libraries that have been found</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">libraries</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="n">libraries</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">libraries</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> expects a string or sequence of strings as the &quot;</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;first argument [got </span><span class="si">{1}</span><span class="s2"> instead]&quot;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">find_system_libraries</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">libraries</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="n">libraries_found</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">search_locations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;/lib64&quot;</span><span class="p">,</span>
        <span class="s2">&quot;/lib&quot;</span><span class="p">,</span>
        <span class="s2">&quot;/usr/lib64&quot;</span><span class="p">,</span>
        <span class="s2">&quot;/usr/lib&quot;</span><span class="p">,</span>
        <span class="s2">&quot;/usr/local/lib64&quot;</span><span class="p">,</span>
        <span class="s2">&quot;/usr/local/lib&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">library</span> <span class="ow">in</span> <span class="n">libraries</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">search_locations</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">find_libraries</span><span class="p">(</span><span class="n">library</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">libraries_found</span> <span class="o">+=</span> <span class="n">result</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">libraries_found</span></div>



<div class="viewcode-block" id="find_libraries">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.find_libraries">[docs]</a>
<span class="k">def</span> <span class="nf">find_libraries</span><span class="p">(</span>
    <span class="n">libraries</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns an iterable of full paths to libraries found in a root dir.</span>

<span class="sd">    Accepts any glob characters accepted by fnmatch:</span>

<span class="sd">    =======  ====================================</span>
<span class="sd">    Pattern  Meaning</span>
<span class="sd">    =======  ====================================</span>
<span class="sd">    *        matches everything</span>
<span class="sd">    ?        matches any single character</span>
<span class="sd">    [seq]    matches any character in ``seq``</span>
<span class="sd">    [!seq]   matches any character not in ``seq``</span>
<span class="sd">    =======  ====================================</span>

<span class="sd">    Parameters:</span>
<span class="sd">        libraries (str or list): Library name(s) to search for</span>
<span class="sd">        root (str): The root directory to start searching from</span>
<span class="sd">        shared (bool): if True searches for shared libraries,</span>
<span class="sd">            otherwise for static. Defaults to True.</span>
<span class="sd">        recursive (bool): if False search only root folder,</span>
<span class="sd">            if True descends top-down from the root. Defaults to False.</span>
<span class="sd">        max_depth (int): if set, don&#39;t search below this depth. Cannot be set</span>
<span class="sd">            if recursive is False</span>
<span class="sd">        runtime (bool): Windows only option, no-op elsewhere. If true,</span>
<span class="sd">            search for runtime shared libs (.DLL), otherwise, search</span>
<span class="sd">            for .Lib files. If shared is false, this has no meaning.</span>
<span class="sd">            Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LibraryList: The libraries that have been found</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">libraries</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="n">libraries</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">libraries</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> expects a string or sequence of strings as the &quot;</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;first argument [got </span><span class="si">{1}</span><span class="s2"> instead]&quot;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">find_libraries</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">libraries</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="n">static_ext</span> <span class="o">=</span> <span class="s2">&quot;lib&quot;</span>
        <span class="c1"># For linking (runtime=False) you need the .lib files regardless of</span>
        <span class="c1"># whether you are doing a shared or static link</span>
        <span class="n">shared_ext</span> <span class="o">=</span> <span class="s2">&quot;dll&quot;</span> <span class="k">if</span> <span class="n">runtime</span> <span class="k">else</span> <span class="s2">&quot;lib&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Used on both Linux and macOS</span>
        <span class="n">static_ext</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>
        <span class="n">shared_ext</span> <span class="o">=</span> <span class="s2">&quot;so&quot;</span>

    <span class="c1"># Construct the right suffix for the library</span>
    <span class="k">if</span> <span class="n">shared</span><span class="p">:</span>
        <span class="c1"># Used on both Linux and macOS</span>
        <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shared_ext</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;darwin&quot;</span><span class="p">:</span>
            <span class="c1"># Only used on macOS</span>
            <span class="n">suffixes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;dylib&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">static_ext</span><span class="p">]</span>

    <span class="c1"># List of libraries we are searching with suffixes</span>
    <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lib</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span> <span class="k">for</span> <span class="n">lib</span> <span class="ow">in</span> <span class="n">libraries</span> <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">suffixes</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">recursive</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_depth</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_depth (</span><span class="si">{</span><span class="n">max_depth</span><span class="si">}</span><span class="s2">) cannot be set if recursive is False&quot;</span><span class="p">)</span>
        <span class="c1"># If not recursive, look for the libraries directly in root</span>
        <span class="k">return</span> <span class="n">LibraryList</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">libraries</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

    <span class="c1"># To speedup the search for external packages configured e.g. in /usr,</span>
    <span class="c1"># perform first non-recursive search in root/lib then in root/lib64 and</span>
    <span class="c1"># finally search all of root recursively. The search stops when the first</span>
    <span class="c1"># match is found.</span>
    <span class="n">common_lib_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lib&quot;</span><span class="p">,</span> <span class="s2">&quot;lib64&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="n">common_lib_dirs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;bin&quot;</span><span class="p">,</span> <span class="s2">&quot;Lib&quot;</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">subdir</span> <span class="ow">in</span> <span class="n">common_lib_dirs</span><span class="p">:</span>
        <span class="n">dirname</span> <span class="o">=</span> <span class="n">join_path</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subdir</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">found_libs</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">libraries</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">found_libs</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">found_libs</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">libraries</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">LibraryList</span><span class="p">(</span><span class="n">found_libs</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">find_all_shared_libraries</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convenience function that returns the list of all shared libraries found</span>
<span class="sd">    in the directory passed as argument.</span>

<span class="sd">    See documentation for `llnl.util.filesystem.find_libraries` for more information</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">find_libraries</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="n">runtime</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">find_all_static_libraries</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convenience function that returns the list of all static libraries found</span>
<span class="sd">    in the directory passed as argument.</span>

<span class="sd">    See documentation for `llnl.util.filesystem.find_libraries` for more information</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">find_libraries</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">find_all_libraries</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convenience function that returns the list of all libraries found</span>
<span class="sd">    in the directory passed as argument.</span>

<span class="sd">    See documentation for `llnl.util.filesystem.find_libraries` for more information</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">find_all_shared_libraries</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">)</span> <span class="o">+</span> <span class="n">find_all_static_libraries</span><span class="p">(</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">WindowsSimulatedRPath</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class representing Windows filesystem rpath analog</span>

<span class="sd">    One instance of this class is associated with a package (only on Windows)</span>
<span class="sd">    For each lib/binary directory in an associated package, this class introduces</span>
<span class="sd">    a symlink to any/all dependent libraries/binaries. This includes the packages</span>
<span class="sd">    own bin/lib directories, meaning the libraries are linked to the bianry directory</span>
<span class="sd">    and vis versa.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">package</span><span class="p">,</span> <span class="n">link_install_prefix</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            package (spack.package_base.PackageBase): Package requiring links</span>
<span class="sd">            link_install_prefix (bool): Link against package&#39;s own install or stage root.</span>
<span class="sd">                Packages that run their own executables during build and require rpaths to</span>
<span class="sd">                the build directory during build time require this option. Default: install</span>
<span class="sd">                root</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pkg</span> <span class="o">=</span> <span class="n">package</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_addl_rpaths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">link_install_prefix</span> <span class="o">=</span> <span class="n">link_install_prefix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_additional_library_dependents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">library_dependents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set of directories where package binaries/libraries are located.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pkg</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">bin</span><span class="p">)])</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_additional_library_dependents</span>

    <span class="k">def</span> <span class="nf">add_library_dependent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">dest</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add paths to directories or libraries/binaries to set of</span>
<span class="sd">        common paths that need to link against other libraries</span>

<span class="sd">        Specified paths should fall outside of a package&#39;s common</span>
<span class="sd">        link paths, i.e. the bin</span>
<span class="sd">        directories.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">pth</span> <span class="ow">in</span> <span class="n">dest</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">pth</span><span class="p">):</span>
                <span class="n">new_pth</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">pth</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_pth</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">pth</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_additional_library_dependents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_pth</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rpaths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set of libraries this package needs to link against during runtime</span>
<span class="sd">        These packages will each be symlinked into the packages lib and binary dir</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dependent_libs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pkg</span><span class="o">.</span><span class="n">rpath</span><span class="p">:</span>
            <span class="n">dependent_libs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">find_all_shared_libraries</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">extra_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addl_rpaths</span><span class="p">:</span>
            <span class="n">dependent_libs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">find_all_shared_libraries</span><span class="p">(</span><span class="n">extra_path</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dependent_libs</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">add_rpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">paths</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add libraries found at the root of provided paths to runtime linking</span>

<span class="sd">        These are libraries found outside of the typical scope of rpath linking</span>
<span class="sd">        that require manual inclusion in a runtime linking scheme.</span>
<span class="sd">        These links are unidirectional, and are only</span>
<span class="sd">        intended to bring outside dependencies into this package</span>

<span class="sd">        Args:</span>
<span class="sd">            *paths (str): arbitrary number of paths to be added to runtime linking</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_addl_rpaths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addl_rpaths</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">,</span> <span class="n">dest_dir</span><span class="p">:</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform link step of simulated rpathing, installing</span>
<span class="sd">        simlinks of file in path to the dest_dir</span>
<span class="sd">        location. This method deliberately prevents</span>
<span class="sd">        the case where a path points to a file inside the dest_dir.</span>
<span class="sd">        This is because it is both meaningless from an rpath</span>
<span class="sd">        perspective, and will cause an error when Developer</span>
<span class="sd">        mode is not enabled&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">report_already_linked</span><span class="p">():</span>
            <span class="c1"># We have either already symlinked or we are encoutering a naming clash</span>
            <span class="c1"># either way, we don&#39;t want to overwrite existing libraries</span>
            <span class="n">already_linked</span> <span class="o">=</span> <span class="n">islink</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dest_file</span><span class="p">))</span>
            <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Linking library </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2"> failed, &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">dest_file</span><span class="p">))</span>
                <span class="o">+</span> <span class="s2">&quot;already linked.&quot;</span>
                <span class="k">if</span> <span class="n">already_linked</span>
                <span class="k">else</span> <span class="s2">&quot;library with name </span><span class="si">%s</span><span class="s2"> already exists at location </span><span class="si">%s</span><span class="s2">.&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">file_name</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">dest_dir</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="n">file_name</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">name</span>
        <span class="n">dest_file</span> <span class="o">=</span> <span class="n">dest_dir</span> <span class="o">/</span> <span class="n">file_name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dest_file</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span> <span class="ow">and</span> <span class="n">dest_dir</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dest_file</span> <span class="o">==</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">symlink</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">dest_file</span><span class="p">))</span>
            <span class="c1"># For py2 compatibility, we have to catch the specific Windows error code</span>
            <span class="c1"># associate with trying to create a file that already exists (winerror 183)</span>
            <span class="c1"># Catch OSErrors missed by the SymlinkError checks</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">winerror</span> <span class="o">==</span> <span class="mi">183</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EEXIST</span><span class="p">):</span>
                    <span class="n">report_already_linked</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>
            <span class="c1"># catch errors we raise ourselves from Spack</span>
            <span class="k">except</span> <span class="n">llnl</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">symlink</span><span class="o">.</span><span class="n">AlreadyExistsError</span><span class="p">:</span>
                <span class="n">report_already_linked</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">establish_link</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (sym)link packages to runtime dependencies based on RPath configuration for</span>
<span class="sd">        Windows heuristics</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># from build_environment.py:463</span>
        <span class="c1"># The top-level package is always RPATHed. It hasn&#39;t been installed yet</span>
        <span class="c1"># so the RPATHs are added unconditionally</span>

        <span class="c1"># for each binary install dir in self.pkg (i.e. pkg.prefix.bin, pkg.prefix.lib)</span>
        <span class="c1"># install a symlink to each dependent library</span>

        <span class="c1"># do not rpath for system libraries included in the dag</span>
        <span class="c1"># we should not be modifying libraries managed by the Windows system</span>
        <span class="c1"># as this will negatively impact linker behavior and can result in permission</span>
        <span class="c1"># errors if those system libs are not modifiable by Spack</span>
        <span class="k">if</span> <span class="s2">&quot;windows-system&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pkg</span><span class="p">,</span> <span class="s2">&quot;tags&quot;</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">for</span> <span class="n">library</span><span class="p">,</span> <span class="n">lib_dir</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rpaths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">library_dependents</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="p">(</span><span class="n">library</span><span class="p">,</span> <span class="n">lib_dir</span><span class="p">)</span>


<span class="nd">@system_path_filter</span>
<span class="nd">@memoized</span>
<span class="k">def</span> <span class="nf">can_access_dir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns True if the argument is an accessible directory.</span>

<span class="sd">    Args:</span>
<span class="sd">        path: path to be tested</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if ``path`` is an accessible directory, else False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">R_OK</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">X_OK</span><span class="p">)</span>


<span class="nd">@system_path_filter</span>
<span class="nd">@memoized</span>
<span class="k">def</span> <span class="nf">can_write_to_dir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return True if the argument is a directory in which we can write.</span>

<span class="sd">    Args:</span>
<span class="sd">        path: path to be tested</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if ``path`` is an writeable directory, else False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">R_OK</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">X_OK</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">W_OK</span><span class="p">)</span>


<span class="nd">@system_path_filter</span>
<span class="nd">@memoized</span>
<span class="k">def</span> <span class="nf">files_in</span><span class="p">(</span><span class="o">*</span><span class="n">search_paths</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns all the files in paths passed as arguments.</span>

<span class="sd">    Caller must ensure that each path in ``search_paths`` is a directory.</span>

<span class="sd">    Args:</span>
<span class="sd">        *search_paths: directories to be searched</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of (file, full_path) tuples with all the files found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">can_access_dir</span><span class="p">,</span> <span class="n">search_paths</span><span class="p">):</span>
        <span class="n">files</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[(</span><span class="n">f</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">files</span>


<span class="k">def</span> <span class="nf">is_readable_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return True if the path passed as argument is readable&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">R_OK</span><span class="p">)</span>


<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">search_paths_for_executables</span><span class="p">(</span><span class="o">*</span><span class="n">path_hints</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a list of path hints returns a list of paths where</span>
<span class="sd">    to search for an executable.</span>

<span class="sd">    Args:</span>
<span class="sd">        *path_hints (list of paths): list of paths taken into</span>
<span class="sd">            consideration for a search</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list containing the real path of every existing directory</span>
<span class="sd">        in `path_hints` and its `bin` subdirectory if it exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">executable_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">path_hints</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">executable_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="n">bin_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;bin&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">bin_dir</span><span class="p">):</span>
            <span class="n">executable_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_dir</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">executable_paths</span>


<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">search_paths_for_libraries</span><span class="p">(</span><span class="o">*</span><span class="n">path_hints</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a list of path hints returns a list of paths where</span>
<span class="sd">    to search for a shared library.</span>

<span class="sd">    Args:</span>
<span class="sd">        *path_hints (list of paths): list of paths taken into</span>
<span class="sd">            consideration for a search</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list containing the real path of every existing directory</span>
<span class="sd">        in `path_hints` and its `lib` and `lib64` subdirectory if it exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">library_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">path_hints</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">library_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="n">lib_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;lib&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">lib_dir</span><span class="p">):</span>
            <span class="n">library_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lib_dir</span><span class="p">)</span>

        <span class="n">lib64_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;lib64&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">lib64_dir</span><span class="p">):</span>
            <span class="n">library_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lib64_dir</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">library_paths</span>


<div class="viewcode-block" id="partition_path">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.partition_path">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">partition_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split the prefixes of the path at the first occurrence of entry and</span>
<span class="sd">    return a 3-tuple containing a list of the prefixes before the entry, a</span>
<span class="sd">    string of the prefix ending with the entry, and a list of the prefixes</span>
<span class="sd">    after the entry.</span>

<span class="sd">    If the entry is not a node in the path, the result will be the prefix list</span>
<span class="sd">    followed by an empty string and an empty list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="n">prefixes</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Derive the index of entry within paths, which will correspond to</span>
        <span class="c1"># the location of the entry in within the path.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span>
            <span class="n">entries</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">):</span>
                <span class="c1"># Handle drive letters e.g. C:/ on Windows</span>
                <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sep</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">entries</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;&quot;</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">paths</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">paths</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">return</span> <span class="n">paths</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="p">[]</span></div>



<div class="viewcode-block" id="prefixes">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.prefixes">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">prefixes</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list containing the path and its ancestors, top-to-bottom.</span>

<span class="sd">    The list for an absolute path will not include an ``os.sep`` entry.</span>
<span class="sd">    For example, assuming ``os.sep`` is ``/``, given path ``/ab/cd/efg``</span>
<span class="sd">    the resulting paths will be, in order: ``/ab``, ``/ab/cd``, and</span>
<span class="sd">    ``/ab/cd/efg``</span>

<span class="sd">    The list for a relative path starting ``./`` will not include ``.``.</span>
<span class="sd">    For example, path ``./hi/jkl/mn`` results in a list with the following</span>
<span class="sd">    paths, in order: ``./hi``, ``./hi/jkl``, and ``./hi/jkl/mn``.</span>

<span class="sd">    On Windows, paths will be normalized to use ``/`` and ``/`` will always</span>
<span class="sd">    be used as the separator instead of ``os.sep``.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        path (str): the string used to derive ancestor paths</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list containing ancestor paths in order and ending with the path</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">sep</span><span class="p">):</span>
        <span class="n">parts</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">):</span>
        <span class="c1"># Handle drive letters e.g. C:/ on Windows</span>
        <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sep</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">parts</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">))]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">paths</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">paths</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">paths</span></div>



<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">md5sum</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the MD5 sum of a file.</span>

<span class="sd">    Args:</span>
<span class="sd">        file (str): file to be checksummed</span>

<span class="sd">    Returns:</span>
<span class="sd">        MD5 sum of the file&#39;s content</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">md5</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">md5</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">md5</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>


<div class="viewcode-block" id="remove_directory_contents">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.remove_directory_contents">[docs]</a>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">remove_directory_contents</span><span class="p">(</span><span class="nb">dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove all contents of a directory.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="nb">dir</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="nb">dir</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="ow">or</span> <span class="n">islink</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span></div>



<div class="viewcode-block" id="keep_modification_time">
<a class="viewcode-back" href="../../../llnl.util.html#llnl.util.filesystem.keep_modification_time">[docs]</a>
<span class="nd">@contextmanager</span>
<span class="nd">@system_path_filter</span>
<span class="k">def</span> <span class="nf">keep_modification_time</span><span class="p">(</span><span class="o">*</span><span class="n">filenames</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Context manager to keep the modification timestamps of the input files.</span>
<span class="sd">    Tolerates and has no effect on non-existent files and files that are</span>
<span class="sd">    deleted by the nested code.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        *filenames: one or more files that must have their modification</span>
<span class="sd">            timestamps unchanged</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mtimes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">mtimes</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">yield</span>
    <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">mtime</span> <span class="ow">in</span> <span class="n">mtimes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">utime</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getatime</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">mtime</span><span class="p">))</span></div>



<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">temporary_dir</span><span class="p">(</span>
    <span class="n">suffix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a temporary directory and cd&#39;s into it. Delete the directory</span>
<span class="sd">    on exit.</span>

<span class="sd">    Takes the same arguments as tempfile.mkdtemp()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tmp_dir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="nb">dir</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">working_dir</span><span class="p">(</span><span class="n">tmp_dir</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">tmp_dir</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">remove_directory_contents</span><span class="p">(</span><span class="n">tmp_dir</span><span class="p">)</span>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">edit_in_place_through_temporary_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context manager for modifying ``file_path`` in place, preserving its inode and hardlinks,</span>
<span class="sd">    for functions or external tools that do not support in-place editing. Notice that this function</span>
<span class="sd">    is unsafe in that it works with paths instead of a file descriptors, but this is by design,</span>
<span class="sd">    since we assume the call site will create a new inode at the same path.&quot;&quot;&quot;</span>
    <span class="n">tmp_fd</span><span class="p">,</span> <span class="n">tmp_path</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span>
        <span class="nb">dir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">file_path</span><span class="p">),</span> <span class="n">prefix</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="p">)</span>
    <span class="c1"># windows cannot replace a file with open fds, so close since the call site needs to replace.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">tmp_fd</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">tmp_path</span><span class="p">,</span> <span class="n">follow_symlinks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">tmp_path</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">follow_symlinks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">filesummary</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">print_bytes</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a small summary of the given file. Does not error</span>
<span class="sd">    when file does not exist.</span>

<span class="sd">    Args:</span>
<span class="sd">        print_bytes (int): Number of bytes to print from start/end of file</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of size and byte string containing first n .. last n bytes.</span>
<span class="sd">        Size is 0 if file cannot be read.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">print_bytes</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fstat</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span><span class="o">.</span><span class="n">st_size</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">short_contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">short_contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">short_contents</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">&quot;...&quot;</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">size</span><span class="p">,</span> <span class="n">short_contents</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>


<span class="k">class</span> <span class="nc">FindFirstFile</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Uses hybrid iterative deepening to locate the first matching</span>
<span class="sd">    file. Up to depth ``bfs_depth`` it uses iterative deepening, which</span>
<span class="sd">    mimics breadth-first with the same memory footprint as depth-first</span>
<span class="sd">    search, after which it switches to ordinary depth-first search using</span>
<span class="sd">    ``os.walk``.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">file_patterns</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">bfs_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a small summary of the given file. Does not error</span>
<span class="sd">        when file does not exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            root (str): directory in which to recursively search</span>
<span class="sd">            file_patterns (str): glob file patterns understood by fnmatch</span>
<span class="sd">            bfs_depth (int): until this depth breadth-first traversal is used,</span>
<span class="sd">                when no match is found, the mode is switched to depth-first search.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bfs_depth</span> <span class="o">=</span> <span class="n">bfs_depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">:</span> <span class="n">Callable</span>

        <span class="c1"># normcase is trivial on posix</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fnmatch</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normcase</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">file_patterns</span><span class="p">))</span>

        <span class="c1"># On case sensitive filesystems match against normcase&#39;d paths.</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span> <span class="ow">is</span> <span class="n">posixpath</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">match</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normcase</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run the file search</span>

<span class="sd">        Returns:</span>
<span class="sd">            str or None: path of the matching file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># First do iterative deepening (i.e. bfs through limited depth dfs)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bfs_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_at_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span>

        <span class="c1"># Then fall back to depth-first search</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_dfs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_find_at_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True when done. Notice search can be done</span>
<span class="sd">        either because a file was found, or because it recursed</span>
<span class="sd">        through all directories.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">entries</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">scandir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">with</span> <span class="n">entries</span><span class="p">:</span>
            <span class="c1"># At max depth we look for matching files.</span>
            <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="n">max_depth</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
                    <span class="c1"># Exit on match</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="k">return</span> <span class="kc">True</span>

                    <span class="c1"># is_dir should not require a stat call, so it&#39;s a good optimization.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_dir</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="n">done</span>

            <span class="c1"># At lower depth only recurse into subdirs</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_dir</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># If any subdir is not fully traversed, we&#39;re not done yet.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_at_depth</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># Early exit when we&#39;ve found something.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>

            <span class="k">return</span> <span class="n">done</span>

    <span class="k">def</span> <span class="nf">_is_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">DirEntry</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True when f is dir we can enter (and not a symlink).&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">is_dir</span><span class="p">(</span><span class="n">follow_symlinks</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_find_dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns match or None&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">filenames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2023, Lawrence Livermore National Laboratory..
      <span class="lastupdated">Last updated on Sep 20, 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>