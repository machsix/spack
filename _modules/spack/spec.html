

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spack.spec &mdash; Spack 0.23.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5f00b823" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=832b3b9f"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-S0PQ7WV75K"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-S0PQ7WV75K');
  </script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/spack-logo-white-text.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../features.html">Feature Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../basic_usage.html">Basic Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../replace_conda_homebrew.html">Spack for Homebrew/Conda Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../frequently_asked_questions.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://spack-tutorial.readthedocs.io">Tutorial (spack-tutorial.rtfd.io)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://packages.spack.io">Packages (packages.spack.io)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://cache.spack.io">Binaries (binaries.spack.io)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../configuration.html">Configuration Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config_yaml.html">Spack Settings (config.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../packages_yaml.html">Package Settings (packages.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../build_settings.html">Concretization Settings (concretizer.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../environments.html">Environments (spack.yaml, spack.lock)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../containers.html">Container Images</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mirrors.html">Mirrors (mirrors.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_file_support.html">Modules (modules.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../repositories.html">Package Repositories (repos.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../binary_caches.html">Build Caches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bootstrapping.html">Bootstrapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../command_index.html">Command Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chain.html">Chaining Spack Installations (upstreams.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../extensions.html">Custom Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pipelines.html">CI Pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../signing.html">Spack Package Signing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu_configuration.html">Using External GPU Support</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contribution_guide.html">Contribution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../packaging_guide.html">Packaging Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../build_systems.html">Build Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer_guide.html">Developer Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../spack.html">Spack API Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../llnl.html">LLNL API Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Spack</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../spack.html">spack</a></li>
      <li class="breadcrumb-item active">spack.spec</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spack.spec</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2013-2024 Lawrence Livermore National Security, LLC and other</span>
<span class="c1"># Spack Project Developers. See the top-level COPYRIGHT file for details.</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier: (Apache-2.0 OR MIT)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Spack allows very fine-grained control over how packages are installed and</span>
<span class="sd">over how they are built and configured.  To make this easy, it has its own</span>
<span class="sd">syntax for declaring a dependence.  We call a descriptor of a particular</span>
<span class="sd">package configuration a &quot;spec&quot;.</span>

<span class="sd">The syntax looks like this:</span>

<span class="sd">.. code-block:: sh</span>

<span class="sd">    $ spack install mpileaks ^openmpi @1.2:1.4 +debug %intel @12.1 target=zen</span>
<span class="sd">                    0        1        2        3      4      5     6</span>

<span class="sd">The first part of this is the command, &#39;spack install&#39;.  The rest of the</span>
<span class="sd">line is a spec for a particular installation of the mpileaks package.</span>

<span class="sd">0. The package to install</span>

<span class="sd">1. A dependency of the package, prefixed by ^</span>

<span class="sd">2. A version descriptor for the package.  This can either be a specific</span>
<span class="sd">   version, like &quot;1.2&quot;, or it can be a range of versions, e.g. &quot;1.2:1.4&quot;.</span>
<span class="sd">   If multiple specific versions or multiple ranges are acceptable, they</span>
<span class="sd">   can be separated by commas, e.g. if a package will only build with</span>
<span class="sd">   versions 1.0, 1.2-1.4, and 1.6-1.8 of mvapich, you could say:</span>

<span class="sd">       depends_on(&quot;mvapich@1.0,1.2:1.4,1.6:1.8&quot;)</span>

<span class="sd">3. A compile-time variant of the package.  If you need openmpi to be</span>
<span class="sd">   built in debug mode for your package to work, you can require it by</span>
<span class="sd">   adding +debug to the openmpi spec when you depend on it.  If you do</span>
<span class="sd">   NOT want the debug option to be enabled, then replace this with -debug.</span>
<span class="sd">   If you would like for the variant to be propagated through all your</span>
<span class="sd">   package&#39;s dependencies use &quot;++&quot; for enabling and &quot;--&quot; or &quot;~~&quot; for disabling.</span>

<span class="sd">4. The name of the compiler to build with.</span>

<span class="sd">5. The versions of the compiler to build with.  Note that the identifier</span>
<span class="sd">   for a compiler version is the same &#39;@&#39; that is used for a package version.</span>
<span class="sd">   A version list denoted by &#39;@&#39; is associated with the compiler only if</span>
<span class="sd">   if it comes immediately after the compiler name.  Otherwise it will be</span>
<span class="sd">   associated with the current package spec.</span>

<span class="sd">6. The architecture to build with.  This is needed on machines where</span>
<span class="sd">   cross-compilation is required</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">platform</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Match</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">archspec.cpu</span>

<span class="kn">import</span> <span class="nn">llnl.path</span>
<span class="kn">import</span> <span class="nn">llnl.string</span>
<span class="kn">import</span> <span class="nn">llnl.util.filesystem</span> <span class="k">as</span> <span class="nn">fs</span>
<span class="kn">import</span> <span class="nn">llnl.util.lang</span> <span class="k">as</span> <span class="nn">lang</span>
<span class="kn">import</span> <span class="nn">llnl.util.tty</span> <span class="k">as</span> <span class="nn">tty</span>
<span class="kn">import</span> <span class="nn">llnl.util.tty.color</span> <span class="k">as</span> <span class="nn">clr</span>

<span class="kn">import</span> <span class="nn">spack</span>
<span class="kn">import</span> <span class="nn">spack.compiler</span>
<span class="kn">import</span> <span class="nn">spack.compilers</span>
<span class="kn">import</span> <span class="nn">spack.config</span>
<span class="kn">import</span> <span class="nn">spack.deptypes</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">import</span> <span class="nn">spack.error</span>
<span class="kn">import</span> <span class="nn">spack.hash_types</span> <span class="k">as</span> <span class="nn">ht</span>
<span class="kn">import</span> <span class="nn">spack.parser</span>
<span class="kn">import</span> <span class="nn">spack.paths</span>
<span class="kn">import</span> <span class="nn">spack.platforms</span>
<span class="kn">import</span> <span class="nn">spack.provider_index</span>
<span class="kn">import</span> <span class="nn">spack.repo</span>
<span class="kn">import</span> <span class="nn">spack.solver</span>
<span class="kn">import</span> <span class="nn">spack.store</span>
<span class="kn">import</span> <span class="nn">spack.traverse</span> <span class="k">as</span> <span class="nn">traverse</span>
<span class="kn">import</span> <span class="nn">spack.util.executable</span>
<span class="kn">import</span> <span class="nn">spack.util.hash</span>
<span class="kn">import</span> <span class="nn">spack.util.module_cmd</span> <span class="k">as</span> <span class="nn">md</span>
<span class="kn">import</span> <span class="nn">spack.util.prefix</span>
<span class="kn">import</span> <span class="nn">spack.util.spack_json</span> <span class="k">as</span> <span class="nn">sjson</span>
<span class="kn">import</span> <span class="nn">spack.util.spack_yaml</span> <span class="k">as</span> <span class="nn">syaml</span>
<span class="kn">import</span> <span class="nn">spack.variant</span> <span class="k">as</span> <span class="nn">vt</span>
<span class="kn">import</span> <span class="nn">spack.version</span> <span class="k">as</span> <span class="nn">vn</span>
<span class="kn">import</span> <span class="nn">spack.version.git_ref_lookup</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;CompilerSpec&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Spec&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SpecParseError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;UnsupportedPropagationError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DuplicateDependencyError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DuplicateCompilerSpecError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;UnsupportedCompilerError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DuplicateArchitectureError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;InconsistentSpecError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;InvalidDependencyError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;NoProviderError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MultipleProviderError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;UnsatisfiableSpecNameError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;UnsatisfiableVersionSpecError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;UnsatisfiableCompilerSpecError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;UnsatisfiableCompilerFlagSpecError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;UnsatisfiableArchitectureSpecError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;UnsatisfiableProviderSpecError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;UnsatisfiableDependencySpecError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AmbiguousHashError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;InvalidHashError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SpecDeprecatedError&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="n">SPEC_FORMAT_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sa">r</span><span class="s2">&quot;(?:&quot;</span>  <span class="c1"># this is one big or, with matches ordered by priority</span>
    <span class="c1"># OPTION 1: escaped character (needs to be first to catch opening \{)</span>
    <span class="c1"># Note that an unterminated \ at the end of a string is left untouched</span>
    <span class="sa">r</span><span class="s2">&quot;(?:</span><span class="se">\\</span><span class="s2">(.))&quot;</span>
    <span class="sa">r</span><span class="s2">&quot;|&quot;</span>  <span class="c1"># or</span>
    <span class="c1"># OPTION 2: an actual format string</span>
    <span class="sa">r</span><span class="s2">&quot;{&quot;</span>  <span class="c1"># non-escaped open brace {</span>
    <span class="sa">r</span><span class="s2">&quot;([%@/]|[\w ][\w -]*=)?&quot;</span>  <span class="c1"># optional sigil (or identifier or space) to print sigil in color</span>
    <span class="sa">r</span><span class="s2">&quot;(?:\^([^}\.]+)\.)?&quot;</span>  <span class="c1"># optional ^depname. (to get attr from dependency)</span>
    <span class="c1"># after the sigil or depname, we can have a hash expression or another attribute</span>
    <span class="sa">r</span><span class="s2">&quot;(?:&quot;</span>  <span class="c1"># one of</span>
    <span class="sa">r</span><span class="s2">&quot;(hash\b)(?:\:(\d+))?&quot;</span>  <span class="c1"># hash followed by :&lt;optional length&gt;</span>
    <span class="sa">r</span><span class="s2">&quot;|&quot;</span>  <span class="c1"># or</span>
    <span class="sa">r</span><span class="s2">&quot;([^}]*)&quot;</span>  <span class="c1"># another attribute to format</span>
    <span class="sa">r</span><span class="s2">&quot;)&quot;</span>  <span class="c1"># end one of</span>
    <span class="sa">r</span><span class="s2">&quot;(})?&quot;</span>  <span class="c1"># finish format string with non-escaped close brace }, or missing if not present</span>
    <span class="sa">r</span><span class="s2">&quot;|&quot;</span>
    <span class="c1"># OPTION 3: mismatched close brace (option 2 would consume a matched open brace)</span>
    <span class="sa">r</span><span class="s2">&quot;(})&quot;</span>  <span class="c1"># brace</span>
    <span class="sa">r</span><span class="s2">&quot;)&quot;</span><span class="p">,</span>
    <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1">#: Valid pattern for an identifier in Spack</span>

<span class="n">IDENTIFIER_RE</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\w[\w-]*&quot;</span>

<span class="c1"># Coloring of specs when using color output. Fields are printed with</span>
<span class="c1"># different colors to enhance readability.</span>
<span class="c1"># See llnl.util.tty.color for descriptions of the color codes.</span>
<span class="n">COMPILER_COLOR</span> <span class="o">=</span> <span class="s2">&quot;@g&quot;</span>  <span class="c1">#: color for highlighting compilers</span>
<span class="n">VERSION_COLOR</span> <span class="o">=</span> <span class="s2">&quot;@c&quot;</span>  <span class="c1">#: color for highlighting versions</span>
<span class="n">ARCHITECTURE_COLOR</span> <span class="o">=</span> <span class="s2">&quot;@m&quot;</span>  <span class="c1">#: color for highlighting architectures</span>
<span class="n">VARIANT_COLOR</span> <span class="o">=</span> <span class="s2">&quot;@B&quot;</span>  <span class="c1">#: color for highlighting variants</span>
<span class="n">HASH_COLOR</span> <span class="o">=</span> <span class="s2">&quot;@K&quot;</span>  <span class="c1">#: color for highlighting package hashes</span>

<span class="c1">#: Default format for Spec.format(). This format can be round-tripped, so that:</span>
<span class="c1">#:     Spec(Spec(&quot;string&quot;).format()) == Spec(&quot;string)&quot;</span>
<span class="n">DEFAULT_FORMAT</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;</span><span class="si">{name}</span><span class="s2">{@versions}&quot;</span>
    <span class="s2">&quot;{</span><span class="si">%c</span><span class="s2">ompiler.name}{@compiler.versions}</span><span class="si">{compiler_flags}</span><span class="s2">&quot;</span>
    <span class="s2">&quot;</span><span class="si">{variants}</span><span class="s2">{ namespace=namespace_if_anonymous}{ arch=architecture}{/abstract_hash}&quot;</span>
<span class="p">)</span>

<span class="c1">#: Display format, which eliminates extra `@=` in the output, for readability.</span>
<span class="n">DISPLAY_FORMAT</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;</span><span class="si">{name}</span><span class="s2">{@version}&quot;</span>
    <span class="s2">&quot;{</span><span class="si">%c</span><span class="s2">ompiler.name}{@compiler.version}</span><span class="si">{compiler_flags}</span><span class="s2">&quot;</span>
    <span class="s2">&quot;</span><span class="si">{variants}</span><span class="s2">{ namespace=namespace_if_anonymous}{ arch=architecture}{/abstract_hash}&quot;</span>
<span class="p">)</span>

<span class="c1">#: Regular expression to pull spec contents out of clearsigned signature</span>
<span class="c1">#: file.</span>
<span class="n">CLEARSIGN_FILE_REGEX</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="p">(</span>
        <span class="sa">r</span><span class="s2">&quot;^-----BEGIN PGP SIGNED MESSAGE-----&quot;</span>
        <span class="sa">r</span><span class="s2">&quot;\s+Hash:\s+[^\s]+\s+(.+)-----BEGIN PGP SIGNATURE-----&quot;</span>
    <span class="p">),</span>
    <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1">#: specfile format version. Must increase monotonically</span>
<span class="n">SPECFILE_FORMAT_VERSION</span> <span class="o">=</span> <span class="mi">4</span>


<span class="k">class</span> <span class="nc">InstallStatus</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Maps install statuses to symbols for display.</span>

<span class="sd">    Options are artificially disjoint for display purposes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">installed</span> <span class="o">=</span> <span class="s2">&quot;@g{[+]}  &quot;</span>
    <span class="n">upstream</span> <span class="o">=</span> <span class="s2">&quot;@g{[^]}  &quot;</span>
    <span class="n">external</span> <span class="o">=</span> <span class="s2">&quot;@g{[e]}  &quot;</span>
    <span class="n">absent</span> <span class="o">=</span> <span class="s2">&quot;@K{ - }  &quot;</span>
    <span class="n">missing</span> <span class="o">=</span> <span class="s2">&quot;@r{[-]}  &quot;</span>


<span class="c1"># regexes used in spec formatting</span>
<span class="n">OLD_STYLE_FMT_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\${[A-Z]+}&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ensure_modern_format_string</span><span class="p">(</span><span class="n">fmt</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensure that the format string does not contain old ${...} syntax.&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">OLD_STYLE_FMT_RE</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">SpecFormatStringError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Format string `</span><span class="si">{</span><span class="n">fmt</span><span class="si">}</span><span class="s2">` contains old syntax `</span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="si">}</span><span class="s2">`. &quot;</span>
            <span class="s2">&quot;This is no longer supported.&quot;</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_microarchitecture</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">archspec</span><span class="o">.</span><span class="n">cpu</span><span class="o">.</span><span class="n">Microarchitecture</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">archspec</span><span class="o">.</span><span class="n">cpu</span><span class="o">.</span><span class="n">Microarchitecture</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">archspec</span><span class="o">.</span><span class="n">cpu</span><span class="o">.</span><span class="n">TARGETS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">archspec</span><span class="o">.</span><span class="n">cpu</span><span class="o">.</span><span class="n">generic_microarchitecture</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>


<span class="nd">@lang</span><span class="o">.</span><span class="n">lazy_lexicographic_ordering</span>
<span class="k">class</span> <span class="nc">ArchSpec</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Aggregate the target platform, the operating system and the target microarchitecture.&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_return_arch</span><span class="p">(</span><span class="n">os_tag</span><span class="p">,</span> <span class="n">target_tag</span><span class="p">):</span>
        <span class="n">platform</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">platforms</span><span class="o">.</span><span class="n">host</span><span class="p">()</span>
        <span class="n">default_os</span> <span class="o">=</span> <span class="n">platform</span><span class="o">.</span><span class="n">operating_system</span><span class="p">(</span><span class="n">os_tag</span><span class="p">)</span>
        <span class="n">default_target</span> <span class="o">=</span> <span class="n">platform</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="n">target_tag</span><span class="p">)</span>
        <span class="n">arch_tuple</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">platform</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">default_os</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">default_target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArchSpec</span><span class="p">(</span><span class="n">arch_tuple</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">default_arch</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the default architecture&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ArchSpec</span><span class="o">.</span><span class="n">_return_arch</span><span class="p">(</span><span class="s2">&quot;default_os&quot;</span><span class="p">,</span> <span class="s2">&quot;default_target&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">frontend_arch</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the frontend architecture&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ArchSpec</span><span class="o">.</span><span class="n">_return_arch</span><span class="p">(</span><span class="s2">&quot;frontend&quot;</span><span class="p">,</span> <span class="s2">&quot;frontend&quot;</span><span class="p">)</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s2">&quot;_platform&quot;</span><span class="p">,</span> <span class="s2">&quot;_os&quot;</span><span class="p">,</span> <span class="s2">&quot;_target&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec_or_platform_tuple</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Architecture specification a package should be built with.</span>

<span class="sd">        Each ArchSpec is comprised of three elements: a platform (e.g. Linux),</span>
<span class="sd">        an OS (e.g. RHEL6), and a target (e.g. x86_64).</span>

<span class="sd">        Args:</span>
<span class="sd">            spec_or_platform_tuple (ArchSpec or str or tuple): if an ArchSpec</span>
<span class="sd">                is passed it will be duplicated into the new instance.</span>
<span class="sd">                Otherwise information on platform, OS and target should be</span>
<span class="sd">                passed in either as a spec string or as a tuple.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the argument to __init__ is a spec string, parse it</span>
        <span class="c1"># and construct an ArchSpec</span>
        <span class="k">def</span> <span class="nf">_string_or_none</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">!=</span> <span class="s2">&quot;None&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># If another instance of ArchSpec was passed, duplicate it</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec_or_platform_tuple</span><span class="p">,</span> <span class="n">ArchSpec</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">spec_or_platform_tuple</span>
            <span class="n">platform_tuple</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">platform</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">os</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">target</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec_or_platform_tuple</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">spec_fields</span> <span class="o">=</span> <span class="n">spec_or_platform_tuple</span>

            <span class="c1"># Normalize the string to a tuple</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec_or_platform_tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">spec_fields</span> <span class="o">=</span> <span class="n">spec_or_platform_tuple</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_fields</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;cannot construct an ArchSpec from </span><span class="si">{0!s}</span><span class="s2">&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec_or_platform_tuple</span><span class="p">))</span>

            <span class="n">platform</span><span class="p">,</span> <span class="n">operating_system</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="n">spec_fields</span>
            <span class="n">platform_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">_string_or_none</span><span class="p">(</span><span class="n">platform</span><span class="p">),</span> <span class="n">_string_or_none</span><span class="p">(</span><span class="n">operating_system</span><span class="p">),</span> <span class="n">target</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">platform</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">platform_tuple</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">override</span><span class="p">(</span><span class="n">init_spec</span><span class="p">,</span> <span class="n">change_spec</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">init_spec</span><span class="p">:</span>
            <span class="n">new_spec</span> <span class="o">=</span> <span class="n">init_spec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_spec</span> <span class="o">=</span> <span class="n">ArchSpec</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">platform</span><span class="p">:</span>
            <span class="n">new_spec</span><span class="o">.</span><span class="n">platform</span> <span class="o">=</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">platform</span>
            <span class="c1"># TODO: if the platform is changed to something that is incompatible</span>
            <span class="c1"># with the current os, we should implicitly remove it</span>
        <span class="k">if</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">os</span><span class="p">:</span>
            <span class="n">new_spec</span><span class="o">.</span><span class="n">os</span> <span class="o">=</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">os</span>
        <span class="k">if</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">target</span><span class="p">:</span>
            <span class="n">new_spec</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">target</span>
        <span class="k">return</span> <span class="n">new_spec</span>

    <span class="k">def</span> <span class="nf">_autospec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec_like</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec_like</span><span class="p">,</span> <span class="n">ArchSpec</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">spec_like</span>
        <span class="k">return</span> <span class="n">ArchSpec</span><span class="p">(</span><span class="n">spec_like</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cmp_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">platform</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">platform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The platform of the architecture.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_platform</span>

    <span class="nd">@platform</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">platform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># The platform of the architecture spec will be verified as a</span>
        <span class="c1"># supported Spack platform before it&#39;s set to ensure all specs</span>
        <span class="c1"># refer to valid platforms.</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_platform</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">os</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The OS of this ArchSpec.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_os</span>

    <span class="nd">@os</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">os</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># The OS of the architecture spec will update the platform field</span>
        <span class="c1"># if the OS is set to one of the reserved OS types so that the</span>
        <span class="c1"># default OS type can be resolved.  Since the reserved OS</span>
        <span class="c1"># information is only available for the host machine, the platform</span>
        <span class="c1"># will assumed to be the host machine&#39;s platform.</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">spack</span><span class="o">.</span><span class="n">platforms</span><span class="o">.</span><span class="n">Platform</span><span class="o">.</span><span class="n">reserved_oss</span><span class="p">:</span>
            <span class="n">curr_platform</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">platforms</span><span class="o">.</span><span class="n">host</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">platform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">platform</span> <span class="ow">or</span> <span class="n">curr_platform</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="n">curr_platform</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Can&#39;t set arch spec OS to reserved value &#39;</span><span class="si">%s</span><span class="s2">&#39; when the &quot;</span>
                    <span class="s2">&quot;arch platform (</span><span class="si">%s</span><span class="s2">) isn&#39;t the current platform (</span><span class="si">%s</span><span class="s2">)&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">platform</span><span class="p">,</span> <span class="n">curr_platform</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="n">spec_platform</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">platforms</span><span class="o">.</span><span class="n">by_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">platform</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">spec_platform</span><span class="o">.</span><span class="n">operating_system</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_os</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">target</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The target of the architecture.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span>

    <span class="nd">@target</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># The target of the architecture spec will update the platform field</span>
        <span class="c1"># if the target is set to one of the reserved target types so that</span>
        <span class="c1"># the default target type can be resolved.  Since the reserved target</span>
        <span class="c1"># information is only available for the host machine, the platform</span>
        <span class="c1"># will assumed to be the host machine&#39;s platform.</span>

        <span class="k">def</span> <span class="nf">target_or_none</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">archspec</span><span class="o">.</span><span class="n">cpu</span><span class="o">.</span><span class="n">Microarchitecture</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">!=</span> <span class="s2">&quot;None&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_make_microarchitecture</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">target_or_none</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">spack</span><span class="o">.</span><span class="n">platforms</span><span class="o">.</span><span class="n">Platform</span><span class="o">.</span><span class="n">reserved_targets</span><span class="p">:</span>
            <span class="n">curr_platform</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">platforms</span><span class="o">.</span><span class="n">host</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">platform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">platform</span> <span class="ow">or</span> <span class="n">curr_platform</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="n">curr_platform</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Can&#39;t set arch spec target to reserved value &#39;</span><span class="si">%s</span><span class="s2">&#39; when &quot;</span>
                    <span class="s2">&quot;the arch platform (</span><span class="si">%s</span><span class="s2">) isn&#39;t the current platform (</span><span class="si">%s</span><span class="s2">)&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">platform</span><span class="p">,</span> <span class="n">curr_platform</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="n">spec_platform</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">platforms</span><span class="o">.</span><span class="n">by_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">platform</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">spec_platform</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_target</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">satisfies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;ArchSpec&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if all concrete specs matching self also match other, otherwise False.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: spec to be satisfied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autospec</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># Check platform and os</span>
        <span class="k">for</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;platform&quot;</span><span class="p">,</span> <span class="s2">&quot;os&quot;</span><span class="p">):</span>
            <span class="n">other_attribute</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>
            <span class="n">self_attribute</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">other_attribute</span> <span class="ow">and</span> <span class="n">self_attribute</span> <span class="o">!=</span> <span class="n">other_attribute</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_satisfies</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;ArchSpec&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if there exists at least one concrete spec that matches both</span>
<span class="sd">        self and other, otherwise False.</span>

<span class="sd">        This operation is commutative, and if two specs intersect it means that one</span>
<span class="sd">        can constrain the other.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: spec to be checked for compatibility</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autospec</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># Check platform and os</span>
        <span class="k">for</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;platform&quot;</span><span class="p">,</span> <span class="s2">&quot;os&quot;</span><span class="p">):</span>
            <span class="n">other_attribute</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>
            <span class="n">self_attribute</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">other_attribute</span> <span class="ow">and</span> <span class="n">self_attribute</span> <span class="ow">and</span> <span class="n">self_attribute</span> <span class="o">!=</span> <span class="n">other_attribute</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_satisfies</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_target_satisfies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;ArchSpec&quot;</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">strict</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">need_to_check</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">need_to_check</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">target</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">need_to_check</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># other_target is there and strict=True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_intersection</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_target_constrain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;ArchSpec&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_target_satisfies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnsatisfiableArchitectureSpecError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">target_concrete</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">target</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Compute the intersection of every combination of ranges in the lists</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_intersection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">attribute_str</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="n">intersection_target</span> <span class="o">=</span> <span class="n">_make_microarchitecture</span><span class="p">(</span><span class="n">attribute_str</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="n">intersection_target</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">intersection_target</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_target_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">results</span>

        <span class="k">for</span> <span class="n">s_target_range</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
            <span class="n">s_min</span><span class="p">,</span> <span class="n">s_sep</span><span class="p">,</span> <span class="n">s_max</span> <span class="o">=</span> <span class="n">s_target_range</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">o_target_range</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
                <span class="n">o_min</span><span class="p">,</span> <span class="n">o_sep</span><span class="p">,</span> <span class="n">o_max</span> <span class="o">=</span> <span class="n">o_target_range</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">s_sep</span><span class="p">:</span>
                    <span class="c1"># s_target_range is a concrete target</span>
                    <span class="c1"># get a microarchitecture reference for at least one side</span>
                    <span class="c1"># of each comparison so we can use archspec comparators</span>
                    <span class="n">s_comp</span> <span class="o">=</span> <span class="n">_make_microarchitecture</span><span class="p">(</span><span class="n">s_min</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">o_sep</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">s_min</span> <span class="o">==</span> <span class="n">o_min</span><span class="p">:</span>
                            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_min</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">o_min</span> <span class="ow">or</span> <span class="n">s_comp</span> <span class="o">&gt;=</span> <span class="n">o_min</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">o_max</span> <span class="ow">or</span> <span class="n">s_comp</span> <span class="o">&lt;=</span> <span class="n">o_max</span><span class="p">):</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_min</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">o_sep</span><span class="p">:</span>
                    <span class="c1"># &quot;cast&quot; to microarchitecture</span>
                    <span class="n">o_comp</span> <span class="o">=</span> <span class="n">_make_microarchitecture</span><span class="p">(</span><span class="n">o_min</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">s_min</span> <span class="ow">or</span> <span class="n">o_comp</span> <span class="o">&gt;=</span> <span class="n">s_min</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">s_max</span> <span class="ow">or</span> <span class="n">o_comp</span> <span class="o">&lt;=</span> <span class="n">s_max</span><span class="p">):</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o_min</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Take the &quot;min&quot; of the two max, if there is a partial ordering.</span>
                    <span class="n">n_max</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">s_max</span> <span class="ow">and</span> <span class="n">o_max</span><span class="p">:</span>
                        <span class="n">_s_max</span> <span class="o">=</span> <span class="n">_make_microarchitecture</span><span class="p">(</span><span class="n">s_max</span><span class="p">)</span>
                        <span class="n">_o_max</span> <span class="o">=</span> <span class="n">_make_microarchitecture</span><span class="p">(</span><span class="n">o_max</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">_s_max</span><span class="o">.</span><span class="n">family</span> <span class="o">!=</span> <span class="n">_o_max</span><span class="o">.</span><span class="n">family</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">_s_max</span> <span class="o">&lt;=</span> <span class="n">_o_max</span><span class="p">:</span>
                            <span class="n">n_max</span> <span class="o">=</span> <span class="n">s_max</span>
                        <span class="k">elif</span> <span class="n">_o_max</span> <span class="o">&lt;</span> <span class="n">_s_max</span><span class="p">:</span>
                            <span class="n">n_max</span> <span class="o">=</span> <span class="n">o_max</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">s_max</span><span class="p">:</span>
                        <span class="n">n_max</span> <span class="o">=</span> <span class="n">s_max</span>
                    <span class="k">elif</span> <span class="n">o_max</span><span class="p">:</span>
                        <span class="n">n_max</span> <span class="o">=</span> <span class="n">o_max</span>

                    <span class="c1"># Take the &quot;max&quot; of the two min.</span>
                    <span class="n">n_min</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">s_min</span> <span class="ow">and</span> <span class="n">o_min</span><span class="p">:</span>
                        <span class="n">_s_min</span> <span class="o">=</span> <span class="n">_make_microarchitecture</span><span class="p">(</span><span class="n">s_min</span><span class="p">)</span>
                        <span class="n">_o_min</span> <span class="o">=</span> <span class="n">_make_microarchitecture</span><span class="p">(</span><span class="n">o_min</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">_s_min</span><span class="o">.</span><span class="n">family</span> <span class="o">!=</span> <span class="n">_o_min</span><span class="o">.</span><span class="n">family</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">_s_min</span> <span class="o">&gt;=</span> <span class="n">_o_min</span><span class="p">:</span>
                            <span class="n">n_min</span> <span class="o">=</span> <span class="n">s_min</span>
                        <span class="k">elif</span> <span class="n">_o_min</span> <span class="o">&gt;</span> <span class="n">_s_min</span><span class="p">:</span>
                            <span class="n">n_min</span> <span class="o">=</span> <span class="n">o_min</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">s_min</span><span class="p">:</span>
                        <span class="n">n_min</span> <span class="o">=</span> <span class="n">s_min</span>
                    <span class="k">elif</span> <span class="n">o_min</span><span class="p">:</span>
                        <span class="n">n_min</span> <span class="o">=</span> <span class="n">o_min</span>

                    <span class="k">if</span> <span class="n">n_min</span> <span class="ow">and</span> <span class="n">n_max</span><span class="p">:</span>
                        <span class="n">_n_min</span> <span class="o">=</span> <span class="n">_make_microarchitecture</span><span class="p">(</span><span class="n">n_min</span><span class="p">)</span>
                        <span class="n">_n_max</span> <span class="o">=</span> <span class="n">_make_microarchitecture</span><span class="p">(</span><span class="n">n_max</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">_n_min</span><span class="o">.</span><span class="n">family</span> <span class="o">!=</span> <span class="n">_n_max</span><span class="o">.</span><span class="n">family</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_n_min</span> <span class="o">&lt;=</span> <span class="n">_n_max</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">n_min</span> <span class="o">==</span> <span class="n">n_max</span><span class="p">:</span>
                            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_min</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n_min</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">n_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">n_min</span><span class="p">:</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n_min</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">n_max</span><span class="p">:</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;:</span><span class="si">{</span><span class="n">n_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">constrain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;ArchSpec&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Projects all architecture fields that are specified in the given</span>
<span class="sd">        spec onto the instance spec if they&#39;re missing from the instance</span>
<span class="sd">        spec.</span>

<span class="sd">        This will only work if the two specs are compatible.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (ArchSpec or str): constraints to be added</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if the current instance was constrained, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autospec</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnsatisfiableArchitectureSpecError</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">constrained</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;platform&quot;</span><span class="p">,</span> <span class="s2">&quot;os&quot;</span><span class="p">):</span>
            <span class="n">svalue</span><span class="p">,</span> <span class="n">ovalue</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">svalue</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ovalue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">ovalue</span><span class="p">)</span>
                <span class="n">constrained</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">constrained</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_constrain</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">constrained</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy the current instance and returns the clone.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ArchSpec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">concrete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if the spec is concrete, False otherwise&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">platform</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_concrete</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">target_concrete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if the target is not a range or list.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;:&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;,&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Generic targets represent either an architecture family (like x86_64)</span>
        <span class="c1"># or a custom micro-architecture</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">vendor</span> <span class="o">==</span> <span class="s2">&quot;generic&quot;</span><span class="p">:</span>
            <span class="n">target_data</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get rid of compiler flag information before turning the uarch into a dict</span>
            <span class="n">uarch_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="n">uarch_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;compilers&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">target_data</span> <span class="o">=</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">(</span><span class="n">uarch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">(</span>
            <span class="p">[(</span><span class="s2">&quot;platform&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">platform</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;platform_os&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="n">target_data</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">([(</span><span class="s2">&quot;arch&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">)])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Import an ArchSpec from raw YAML/JSON data&quot;&quot;&quot;</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;arch&quot;</span><span class="p">]</span>
        <span class="n">target_name</span> <span class="o">=</span> <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">target_name</span> <span class="o">=</span> <span class="n">target_name</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_make_microarchitecture</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArchSpec</span><span class="p">((</span><span class="n">arch</span><span class="p">[</span><span class="s2">&quot;platform&quot;</span><span class="p">],</span> <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;platform_os&quot;</span><span class="p">],</span> <span class="n">target</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">platform</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;ArchSpec((</span><span class="si">{0.platform!r}</span><span class="s2">, </span><span class="si">{0.os!r}</span><span class="s2">, </span><span class="si">{1!r}</span><span class="s2">))&quot;</span>
        <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">string</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>


<div class="viewcode-block" id="CompilerSpec">
<a class="viewcode-back" href="../../spack.html#spack.spec.CompilerSpec">[docs]</a>
<span class="nd">@lang</span><span class="o">.</span><span class="n">lazy_lexicographic_ordering</span>
<span class="k">class</span> <span class="nc">CompilerSpec</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The CompilerSpec field represents the compiler or range of compiler</span>
<span class="sd">    versions that a package should be built with.  CompilerSpecs have a</span>
<span class="sd">    name and a version list.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;versions&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nargs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># If there is one argument, it&#39;s either another CompilerSpec</span>
            <span class="c1"># to copy or a string to parse</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse_one_or_raise</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;%</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">compiler</span><span class="o">.</span><span class="n">name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">versions</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">compiler</span><span class="o">.</span><span class="n">versions</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">CompilerSpec</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">versions</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Can only build CompilerSpec from string or &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;CompilerSpec. Found </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">nargs</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="n">args</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">versions</span> <span class="o">=</span> <span class="n">vn</span><span class="o">.</span><span class="n">VersionList</span><span class="p">([</span><span class="n">vn</span><span class="o">.</span><span class="n">ver</span><span class="p">(</span><span class="n">version</span><span class="p">)])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;__init__ takes 1 or 2 arguments. (</span><span class="si">%d</span><span class="s2"> given)&quot;</span> <span class="o">%</span> <span class="n">nargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_autospec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compiler_spec_like</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compiler_spec_like</span><span class="p">,</span> <span class="n">CompilerSpec</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">compiler_spec_like</span>
        <span class="k">return</span> <span class="n">CompilerSpec</span><span class="p">(</span><span class="n">compiler_spec_like</span><span class="p">)</span>

<div class="viewcode-block" id="CompilerSpec.intersects">
<a class="viewcode-back" href="../../spack.html#spack.spec.CompilerSpec.intersects">[docs]</a>
    <span class="k">def</span> <span class="nf">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;CompilerSpec&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if all concrete specs matching self also match other, otherwise False.</span>

<span class="sd">        For compiler specs this means that the name of the compiler must be the same for</span>
<span class="sd">        self and other, and that the versions ranges should intersect.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: spec to be satisfied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autospec</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">versions</span><span class="p">)</span></div>


<div class="viewcode-block" id="CompilerSpec.satisfies">
<a class="viewcode-back" href="../../spack.html#spack.spec.CompilerSpec.satisfies">[docs]</a>
    <span class="k">def</span> <span class="nf">satisfies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;CompilerSpec&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if all concrete specs matching self also match other, otherwise False.</span>

<span class="sd">        For compiler specs this means that the name of the compiler must be the same for</span>
<span class="sd">        self and other, and that the version range of self is a subset of that of other.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: spec to be satisfied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autospec</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">versions</span><span class="p">)</span></div>


<div class="viewcode-block" id="CompilerSpec.constrain">
<a class="viewcode-back" href="../../spack.html#spack.spec.CompilerSpec.constrain">[docs]</a>
    <span class="k">def</span> <span class="nf">constrain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;CompilerSpec&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Intersect self&#39;s versions with other.</span>

<span class="sd">        Return whether the CompilerSpec changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autospec</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># ensure that other will actually constrain this spec.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnsatisfiableCompilerSpecError</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">versions</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">concrete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A CompilerSpec is concrete if its versions are concrete and there</span>
<span class="sd">        is an available compiler with the right version.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">concrete</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span><span class="s2">&quot;Spec is not concrete: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="CompilerSpec.copy">
<a class="viewcode-back" href="../../spack.html#spack.spec.CompilerSpec.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="n">CompilerSpec</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">CompilerSpec</span><span class="p">)</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">versions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">clone</span></div>


    <span class="k">def</span> <span class="nf">_cmp_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span>

<div class="viewcode-block" id="CompilerSpec.to_dict">
<a class="viewcode-back" href="../../spack.html#spack.spec.CompilerSpec.to_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">([(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)])</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">([(</span><span class="s2">&quot;compiler&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">)])</span></div>


<div class="viewcode-block" id="CompilerSpec.from_dict">
<a class="viewcode-back" href="../../spack.html#spack.spec.CompilerSpec.from_dict">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;compiler&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">CompilerSpec</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">vn</span><span class="o">.</span><span class="n">VersionList</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">display_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to {compiler.name}{@compiler.version} for Specs, without extra</span>
<span class="sd">        @= for readability.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">@</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span> <span class="o">!=</span> <span class="n">vn</span><span class="o">.</span><span class="n">any_version</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">@</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span> <span class="o">!=</span> <span class="n">vn</span><span class="o">.</span><span class="n">any_version</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;@</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>



<span class="nd">@lang</span><span class="o">.</span><span class="n">lazy_lexicographic_ordering</span>
<span class="k">class</span> <span class="nc">DependencySpec</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;DependencySpecs represent an edge in the DAG, and contain dependency types</span>
<span class="sd">    and information on the virtuals being provided.</span>

<span class="sd">    Dependencies can be one (or more) of several types:</span>

<span class="sd">    - build: needs to be in the PATH at build time.</span>
<span class="sd">    - link: is linked to and added to compiler flags.</span>
<span class="sd">    - run: needs to be in the PATH for the package to run.</span>

<span class="sd">    Args:</span>
<span class="sd">        parent: starting node of the edge</span>
<span class="sd">        spec: ending node of the edge.</span>
<span class="sd">        depflag: represents dependency relationships.</span>
<span class="sd">        virtuals: virtual packages provided from child to parent node.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="s2">&quot;spec&quot;</span><span class="p">,</span> <span class="s2">&quot;depflag&quot;</span><span class="p">,</span> <span class="s2">&quot;virtuals&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="s2">&quot;Spec&quot;</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="s2">&quot;Spec&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">depflag</span><span class="p">:</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">,</span> <span class="n">virtuals</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depflag</span> <span class="o">=</span> <span class="n">depflag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">virtuals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">virtuals</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">update_deptypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depflag</span><span class="p">:</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the current dependency types&quot;&quot;&quot;</span>
        <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depflag</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">depflag</span> <span class="o">|</span> <span class="n">old</span>
        <span class="k">if</span> <span class="n">new</span> <span class="o">==</span> <span class="n">old</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depflag</span> <span class="o">=</span> <span class="n">new</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">update_virtuals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">virtuals</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the list of provided virtuals&quot;&quot;&quot;</span>
        <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtuals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">virtuals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">virtuals</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">virtuals</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">old</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtuals</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DependencySpec&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of this edge&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DependencySpec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">depflag</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">virtuals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cmp_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">depflag</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtuals</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">parent</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">depflag</span><span class="si">}</span><span class="s2">[virtuals=</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">virtuals</span><span class="p">)</span><span class="si">}</span><span class="s2">] --&gt; </span><span class="si">{</span><span class="n">child</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DependencySpec&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flip the dependency, and drop virtual information&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DependencySpec</span><span class="p">(</span>
            <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">,</span> <span class="n">spec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">depflag</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="p">()</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">CompilerFlag</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Will store a flag value and it&#39;s propagation value</span>

<span class="sd">    Args:</span>
<span class="sd">        value (str): the flag&#39;s value</span>
<span class="sd">        propagate (bool): if ``True`` the flag value will</span>
<span class="sd">            be passed to the package&#39;s dependencies. If</span>
<span class="sd">            ``False`` it will not</span>
<span class="sd">        flag_group (str): if this flag was introduced along</span>
<span class="sd">            with several flags via a single source, then</span>
<span class="sd">            this will store all such flags</span>
<span class="sd">        source (str): identifies the type of constraint that</span>
<span class="sd">            introduced this flag (e.g. if a package has</span>
<span class="sd">            ``depends_on(... cflags=-g)``, then the ``source``</span>
<span class="sd">            for &quot;-g&quot; would indicate ``depends_on``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">propagate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;propagate&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">flag_group</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;flag_group&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>


<span class="n">_valid_compiler_flags</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cflags&quot;</span><span class="p">,</span> <span class="s2">&quot;cxxflags&quot;</span><span class="p">,</span> <span class="s2">&quot;fflags&quot;</span><span class="p">,</span> <span class="s2">&quot;ldflags&quot;</span><span class="p">,</span> <span class="s2">&quot;ldlibs&quot;</span><span class="p">,</span> <span class="s2">&quot;cppflags&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_shared_subset_pair_iterate</span><span class="p">(</span><span class="n">container1</span><span class="p">,</span> <span class="n">container2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    [0, a, c, d, f]</span>
<span class="sd">    [a, d, e, f]</span>

<span class="sd">    yields [(a, a), (d, d), (f, f)]</span>

<span class="sd">    no repeated elements</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a_idx</span><span class="p">,</span> <span class="n">b_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="n">max_a</span><span class="p">,</span> <span class="n">max_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">container1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">container2</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">a_idx</span> <span class="o">&lt;</span> <span class="n">max_a</span> <span class="ow">and</span> <span class="n">b_idx</span> <span class="o">&lt;</span> <span class="n">max_b</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">container1</span><span class="p">[</span><span class="n">a_idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">container2</span><span class="p">[</span><span class="n">b_idx</span><span class="p">]:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">container1</span><span class="p">[</span><span class="n">a_idx</span><span class="p">],</span> <span class="n">container2</span><span class="p">[</span><span class="n">b_idx</span><span class="p">])</span>
            <span class="n">a_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">b_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">container1</span><span class="p">[</span><span class="n">a_idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">container2</span><span class="p">[</span><span class="n">b_idx</span><span class="p">]:</span>
                <span class="n">a_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">container1</span><span class="p">[</span><span class="n">a_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">container2</span><span class="p">[</span><span class="n">b_idx</span><span class="p">]:</span>
                <span class="n">b_idx</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">class</span> <span class="nc">FlagMap</span><span class="p">(</span><span class="n">lang</span><span class="o">.</span><span class="n">HashableMap</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;spec&quot;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="k">def</span> <span class="nf">satisfies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">constrain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add all flags in other that aren&#39;t in self to self.</span>

<span class="sd">        Return whether the spec changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">flag_type</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flag_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">flag_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">flag_type</span><span class="p">]</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extra_other</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">flag_type</span><span class="p">])</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">flag_type</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">extra_other</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">flag_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">flag_type</span><span class="p">])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">other</span><span class="p">[</span><span class="n">flag_type</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">extra_other</span>
                    <span class="p">)</span>
                    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># Next, if any flags in other propagate, we force them to propagate in our case</span>
                <span class="n">shared</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">flag_type</span><span class="p">])</span> <span class="o">-</span> <span class="n">extra_other</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">_shared_subset_pair_iterate</span><span class="p">(</span><span class="n">shared</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">flag_type</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">propagate</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">propagate</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">y</span><span class="o">.</span><span class="n">propagate</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># TODO: what happens if flag groups with a partial (but not complete)</span>
        <span class="c1"># intersection specify different behaviors for flag propagation?</span>

        <span class="k">return</span> <span class="n">changed</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">valid_compiler_flags</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">_valid_compiler_flags</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="n">FlagMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">compiler_flag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">clone</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">compiler_flag</span>
        <span class="k">return</span> <span class="n">clone</span>

    <span class="k">def</span> <span class="nf">add_flag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag_type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">propagation</span><span class="p">,</span> <span class="n">flag_group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stores the flag&#39;s value in CompilerFlag and adds it</span>
<span class="sd">        to the FlagMap</span>

<span class="sd">        Args:</span>
<span class="sd">            flag_type (str): the type of flag</span>
<span class="sd">            value (str): the flag&#39;s value that will be added to the flag_type&#39;s</span>
<span class="sd">                corresponding list</span>
<span class="sd">            propagation (bool): if ``True`` the flag value will be passed to</span>
<span class="sd">                the packages&#39; dependencies. If``False`` it will not be passed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag_group</span> <span class="o">=</span> <span class="n">flag_group</span> <span class="ow">or</span> <span class="n">value</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">CompilerFlag</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">propagate</span><span class="o">=</span><span class="n">propagation</span><span class="p">,</span> <span class="n">flag_group</span><span class="o">=</span><span class="n">flag_group</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">flag_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">flag_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">flag</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">flag_type</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">yaml_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the flag type and a list of the flag values since the</span>
<span class="sd">        propagation values aren&#39;t needed when writing to yaml</span>

<span class="sd">        Args:</span>
<span class="sd">            flag_type (str): the type of flag to get values from</span>

<span class="sd">        Returns the flag_type and a list of the corresponding flags in</span>
<span class="sd">            string format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">flag_type</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">flag_type</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">_cmp_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">yield</span> <span class="n">k</span>

            <span class="k">def</span> <span class="nf">flags</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">flag</span>
                    <span class="k">yield</span> <span class="n">flag</span><span class="o">.</span><span class="n">propagate</span>

            <span class="k">yield</span> <span class="n">flags</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="n">sorted_items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">flag_type</span><span class="p">,</span> <span class="n">flags</span> <span class="ow">in</span> <span class="n">sorted_items</span><span class="p">:</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">flags</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">propagate</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">normal</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">flag_type</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">spack</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">quote_if_needed</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">normal</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">propagated</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">flags</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">propagate</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">propagated</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">flag_type</span><span class="si">}</span><span class="s2">==</span><span class="si">{</span><span class="n">spack</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">quote_if_needed</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">propagated</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># TODO: somehow add this space only if something follows in Spec.format()</span>
        <span class="k">if</span> <span class="n">sorted_items</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span>

        <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_sort_by_dep_types</span><span class="p">(</span><span class="n">dspec</span><span class="p">:</span> <span class="n">DependencySpec</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dspec</span><span class="o">.</span><span class="n">depflag</span>


<span class="nd">@lang</span><span class="o">.</span><span class="n">lazy_lexicographic_ordering</span>
<span class="k">class</span> <span class="nc">_EdgeMap</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represent a collection of edges (DependencySpec objects) in the DAG.</span>

<span class="sd">    Objects of this class are used in Specs to track edges that are</span>
<span class="sd">    outgoing towards direct dependencies, or edges that are incoming</span>
<span class="sd">    from direct dependents.</span>

<span class="sd">    Edges are stored in a dictionary and keyed by package name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s2">&quot;edges&quot;</span><span class="p">,</span> <span class="s2">&quot;store_by_child&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store_by_child</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">DependencySpec</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_by_child</span> <span class="o">=</span> <span class="n">store_by_child</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">DependencySpec</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="n">DependencySpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_by_child</span> <span class="k">else</span> <span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="n">lst</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">_sort_by_dep_types</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="s2">deps: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">_cmp_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="k">yield</span> <span class="n">item</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copies this object and returns a clone&quot;&quot;&quot;</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)()</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">store_by_child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_by_child</span>

        <span class="c1"># Copy everything from this dict into it.</span>
        <span class="k">for</span> <span class="n">dspec</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">clone</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dspec</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">clone</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">child</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">depflag</span><span class="p">:</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">ALL</span><span class="p">,</span>
        <span class="n">virtuals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">DependencySpec</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Selects a list of edges and returns them.</span>

<span class="sd">        If an edge:</span>

<span class="sd">        - Has *any* of the dependency types passed as argument,</span>
<span class="sd">        - Matches the parent and/or child name</span>
<span class="sd">        - Provides *any* of the virtuals passed as argument</span>

<span class="sd">        then it is selected.</span>

<span class="sd">        The deptypes argument needs to be a flag, since the method won&#39;t</span>
<span class="sd">        convert it for performance reason.</span>

<span class="sd">        Args:</span>
<span class="sd">            parent: name of the parent package</span>
<span class="sd">            child: name of the child package</span>
<span class="sd">            depflag: allowed dependency types in flag form</span>
<span class="sd">            virtuals: list of virtuals on the edge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">depflag</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Start from all the edges we store</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="c1"># Filter by parent name</span>
        <span class="k">if</span> <span class="n">parent</span><span class="p">:</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">selected</span> <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">parent</span><span class="p">)</span>

        <span class="c1"># Filter by child name</span>
        <span class="k">if</span> <span class="n">child</span><span class="p">:</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">selected</span> <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">child</span><span class="p">)</span>

        <span class="c1"># Filter by allowed dependency types</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="p">(</span><span class="n">dep</span> <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">selected</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">dep</span><span class="o">.</span><span class="n">depflag</span> <span class="ow">or</span> <span class="p">(</span><span class="n">depflag</span> <span class="o">&amp;</span> <span class="n">dep</span><span class="o">.</span><span class="n">depflag</span><span class="p">))</span>

        <span class="c1"># Filter by virtuals</span>
        <span class="k">if</span> <span class="n">virtuals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="p">(</span><span class="n">dep</span> <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">selected</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">dep</span><span class="o">.</span><span class="n">virtuals</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">virtuals</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_command_default_handler</span><span class="p">(</span><span class="n">spec</span><span class="p">:</span> <span class="s2">&quot;Spec&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Default handler when looking for the &#39;command&#39; attribute.</span>

<span class="sd">    Tries to search for ``spec.name`` in the ``spec.home.bin`` directory.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        spec: spec that is being queried</span>

<span class="sd">    Returns:</span>
<span class="sd">        Executable: An executable of the command</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the command is not found</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">home</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">package</span><span class="p">,</span> <span class="s2">&quot;home&quot;</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home</span><span class="o">.</span><span class="n">bin</span><span class="p">,</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fs</span><span class="o">.</span><span class="n">is_exe</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spack</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">executable</span><span class="o">.</span><span class="n">Executable</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to locate </span><span class="si">{</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> command in </span><span class="si">{</span><span class="n">home</span><span class="o">.</span><span class="n">bin</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_headers_default_handler</span><span class="p">(</span><span class="n">spec</span><span class="p">:</span> <span class="s2">&quot;Spec&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Default handler when looking for the &#39;headers&#39; attribute.</span>

<span class="sd">    Tries to search for ``*.h`` files recursively starting from</span>
<span class="sd">    ``spec.package.home.include``.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        spec: spec that is being queried</span>

<span class="sd">    Returns:</span>
<span class="sd">        HeaderList: The headers in ``prefix.include``</span>

<span class="sd">    Raises:</span>
<span class="sd">        NoHeadersError: If no headers are found</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">home</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">package</span><span class="p">,</span> <span class="s2">&quot;home&quot;</span><span class="p">)</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">find_headers</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">home</span><span class="o">.</span><span class="n">include</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">headers</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">headers</span>
    <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">NoHeadersError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to locate </span><span class="si">{</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> headers in </span><span class="si">{</span><span class="n">home</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_libs_default_handler</span><span class="p">(</span><span class="n">spec</span><span class="p">:</span> <span class="s2">&quot;Spec&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Default handler when looking for the &#39;libs&#39; attribute.</span>

<span class="sd">    Tries to search for ``lib{spec.name}`` recursively starting from</span>
<span class="sd">    ``spec.package.home``. If ``spec.name`` starts with ``lib``, searches for</span>
<span class="sd">    ``{spec.name}`` instead.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        spec: spec that is being queried</span>

<span class="sd">    Returns:</span>
<span class="sd">        LibraryList: The libraries found</span>

<span class="sd">    Raises:</span>
<span class="sd">        NoLibrariesError: If no libraries are found</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Variable &#39;name&#39; is passed to function &#39;find_libraries&#39;, which supports</span>
    <span class="c1"># glob characters. For example, we have a package with a name &#39;abc-abc&#39;.</span>
    <span class="c1"># Now, we don&#39;t know if the original name of the package is &#39;abc_abc&#39;</span>
    <span class="c1"># (and it generates a library &#39;libabc_abc.so&#39;) or &#39;abc-abc&#39; (and it</span>
    <span class="c1"># generates a library &#39;libabc-abc.so&#39;). So, we tell the function</span>
    <span class="c1"># &#39;find_libraries&#39; to give us anything that matches &#39;libabc?abc&#39; and it</span>
    <span class="c1"># gives us either &#39;libabc-abc.so&#39; or &#39;libabc_abc.so&#39; (or an error)</span>
    <span class="c1"># depending on which one exists (there is a possibility, of course, to</span>
    <span class="c1"># get something like &#39;libabcXabc.so, but for now we consider this</span>
    <span class="c1"># unlikely).</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">)</span>
    <span class="n">home</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">package</span><span class="p">,</span> <span class="s2">&quot;home&quot;</span><span class="p">)</span>

    <span class="c1"># Avoid double &#39;lib&#39; for packages whose names already start with lib</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;lib&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">spec</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="s2">&quot;platform=windows&quot;</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;lib&quot;</span> <span class="o">+</span> <span class="n">name</span>

    <span class="c1"># If &#39;+shared&#39; search only for shared library; if &#39;~shared&#39; search only for</span>
    <span class="c1"># static library; otherwise, first search for shared and then for static.</span>
    <span class="n">search_shared</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;+shared&quot;</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">)</span> <span class="k">else</span> <span class="p">([</span><span class="kc">False</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;~shared&quot;</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">shared</span> <span class="ow">in</span> <span class="n">search_shared</span><span class="p">:</span>
        <span class="c1"># Since we are searching for link libraries, on Windows search only for</span>
        <span class="c1"># &quot;.Lib&quot; extensions by default as those represent import libraries for implicit links.</span>
        <span class="n">libs</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">find_libraries</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">home</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="n">shared</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">libs</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">libs</span>

    <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">NoLibrariesError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Unable to recursively locate </span><span class="si">{</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> libraries in </span><span class="si">{</span><span class="n">home</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">ForwardQueryToPackage</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Descriptor used to forward queries from Spec to Package&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attribute_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">default_handler</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;Spec&quot;</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_indirect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new descriptor.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            attribute_name: name of the attribute to be searched for in the Package instance</span>
<span class="sd">            default_handler: default function to be called if the attribute was not found in the</span>
<span class="sd">                Package instance</span>
<span class="sd">            _indirect: temporarily added to redirect a query to another package.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attribute_name</span> <span class="o">=</span> <span class="n">attribute_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">default_handler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indirect</span> <span class="o">=</span> <span class="n">_indirect</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="s2">&quot;SpecBuildInterface&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves the property from Package using a well defined chain</span>
<span class="sd">        of responsibility.</span>

<span class="sd">        The order of call is:</span>

<span class="sd">        1. if the query was through the name of a virtual package try to</span>
<span class="sd">            search for the attribute `{virtual_name}_{attribute_name}`</span>
<span class="sd">            in Package</span>

<span class="sd">        2. try to search for attribute `{attribute_name}` in Package</span>

<span class="sd">        3. try to call the default handler</span>

<span class="sd">        The first call that produces a value will stop the chain.</span>

<span class="sd">        If no call can handle the request then AttributeError is raised with a</span>
<span class="sd">        message indicating that no relevant attribute exists.</span>
<span class="sd">        If a call returns None, an AttributeError is raised with a message</span>
<span class="sd">        indicating a query failure, e.g. that library files were not found in a</span>
<span class="sd">        &#39;libs&#39; query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: this indirection exist solely for `spec[&quot;python&quot;].command` to actually return</span>
        <span class="c1"># spec[&quot;python-venv&quot;].command. It should be removed when `python` is a virtual.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indirect</span> <span class="ow">and</span> <span class="n">instance</span><span class="o">.</span><span class="n">indirect_spec</span><span class="p">:</span>
            <span class="n">pkg</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">indirect_spec</span><span class="o">.</span><span class="n">package</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pkg</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">wrapped_obj</span><span class="o">.</span><span class="n">package</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">last_query</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># There has been no query yet: this means</span>
            <span class="c1"># a spec is trying to access its own attributes</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">wrapped_obj</span><span class="p">[</span><span class="n">instance</span><span class="o">.</span><span class="n">wrapped_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>  <span class="c1"># NOQA: ignore=F841</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">last_query</span>

        <span class="n">callbacks_chain</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># First in the chain : specialized attribute for virtual packages</span>
        <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">isvirtual</span><span class="p">:</span>
            <span class="n">specialized_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">_</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute_name</span><span class="p">)</span>
            <span class="n">callbacks_chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pkg</span><span class="p">,</span> <span class="n">specialized_name</span><span class="p">))</span>
        <span class="c1"># Try to get the generic method from Package</span>
        <span class="n">callbacks_chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pkg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute_name</span><span class="p">))</span>
        <span class="c1"># Final resort : default callback</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>  <span class="c1"># make mypy happy</span>
            <span class="n">callbacks_chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">_default</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">wrapped_obj</span><span class="p">))</span>

        <span class="c1"># Trigger the callbacks in order, the first one producing a</span>
        <span class="c1"># value wins</span>
        <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">message</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">callbacks_chain</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>
                <span class="c1"># A callback can return None to trigger an error indicating</span>
                <span class="c1"># that the query failed.</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Query of package &#39;</span><span class="si">{name}</span><span class="s2">&#39; for &#39;</span><span class="si">{attrib}</span><span class="s2">&#39; failed</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">prefix : </span><span class="si">{spec.prefix}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">spec : </span><span class="si">{spec}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">queried as : </span><span class="si">{query.name}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">extra parameters : </span><span class="si">{query.extra_parameters}</span><span class="s2">&quot;</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">attrib</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attribute_name</span><span class="p">,</span>
                        <span class="n">spec</span><span class="o">=</span><span class="n">instance</span><span class="p">,</span>
                        <span class="n">query</span><span class="o">=</span><span class="n">instance</span><span class="o">.</span><span class="n">last_query</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">value</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1"># value is &#39;None&#39;</span>
        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Here we can use another type of exception. If we do that, the</span>
            <span class="c1"># unit test &#39;test_getitem_exceptional_paths&#39; in the file</span>
            <span class="c1"># lib/spack/spack/test/spec_dag.py will need to be updated to match</span>
            <span class="c1"># the type.</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="c1"># &#39;None&#39; value at this point means that there are no appropriate</span>
        <span class="c1"># properties defined and no default handler, or that all callbacks</span>
        <span class="c1"># raised AttributeError. In this case, we raise AttributeError with an</span>
        <span class="c1"># appropriate message.</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">{name}</span><span class="s2">&#39; package has no relevant attribute &#39;</span><span class="si">{query}</span><span class="s2">&#39;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">fmt</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">spec : &#39;</span><span class="si">{spec}</span><span class="s2">&#39;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">fmt</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">queried as : &#39;</span><span class="si">{spec.last_query.name}</span><span class="s2">&#39;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">fmt</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">extra parameters : &#39;</span><span class="si">{spec.last_query.extra_parameters}</span><span class="s2">&#39;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">pkg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attribute_name</span><span class="p">,</span> <span class="n">spec</span><span class="o">=</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">cls_name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">{0}</span><span class="s2">&#39; object attribute &#39;</span><span class="si">{1}</span><span class="s2">&#39; is read-only&quot;</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cls_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute_name</span><span class="p">))</span>


<span class="c1"># Represents a query state in a BuildInterface object</span>
<span class="n">QueryState</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;QueryState&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;extra_parameters&quot;</span><span class="p">,</span> <span class="s2">&quot;isvirtual&quot;</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">SpecBuildInterface</span><span class="p">(</span><span class="n">lang</span><span class="o">.</span><span class="n">ObjectWrapper</span><span class="p">):</span>
    <span class="c1"># home is available in the base Package so no default is needed</span>
    <span class="n">home</span> <span class="o">=</span> <span class="n">ForwardQueryToPackage</span><span class="p">(</span><span class="s2">&quot;home&quot;</span><span class="p">,</span> <span class="n">default_handler</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="n">ForwardQueryToPackage</span><span class="p">(</span><span class="s2">&quot;headers&quot;</span><span class="p">,</span> <span class="n">default_handler</span><span class="o">=</span><span class="n">_headers_default_handler</span><span class="p">)</span>
    <span class="n">libs</span> <span class="o">=</span> <span class="n">ForwardQueryToPackage</span><span class="p">(</span><span class="s2">&quot;libs&quot;</span><span class="p">,</span> <span class="n">default_handler</span><span class="o">=</span><span class="n">_libs_default_handler</span><span class="p">)</span>
    <span class="n">command</span> <span class="o">=</span> <span class="n">ForwardQueryToPackage</span><span class="p">(</span>
        <span class="s2">&quot;command&quot;</span><span class="p">,</span> <span class="n">default_handler</span><span class="o">=</span><span class="n">_command_default_handler</span><span class="p">,</span> <span class="n">_indirect</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="s2">&quot;Spec&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">query_parameters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">_parent</span><span class="p">:</span> <span class="s2">&quot;Spec&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="c1"># Adding new attributes goes after super() call since the ObjectWrapper</span>
        <span class="c1"># resets __dict__ to behave like the passed object</span>
        <span class="n">original_spec</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="s2">&quot;wrapped_obj&quot;</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_obj</span> <span class="o">=</span> <span class="n">original_spec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">=</span> <span class="n">original_spec</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">query_parameters</span><span class="p">,</span> <span class="n">_parent</span>
        <span class="n">is_virtual</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">is_virtual</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_query</span> <span class="o">=</span> <span class="n">QueryState</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">extra_parameters</span><span class="o">=</span><span class="n">query_parameters</span><span class="p">,</span> <span class="n">isvirtual</span><span class="o">=</span><span class="n">is_virtual</span>
        <span class="p">)</span>

        <span class="c1"># TODO: this ad-hoc logic makes `spec[&quot;python&quot;].command` return</span>
        <span class="c1"># `spec[&quot;python-venv&quot;].command` and should be removed when `python` is a virtual.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indirect_spec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;python&quot;</span><span class="p">:</span>
            <span class="n">python_venvs</span> <span class="o">=</span> <span class="n">_parent</span><span class="o">.</span><span class="n">dependencies</span><span class="p">(</span><span class="s2">&quot;python-venv&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">python_venvs</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indirect_spec</span> <span class="o">=</span> <span class="n">python_venvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SpecBuildInterface</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_obj</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">tree</span><span class="p">(</span>
    <span class="n">specs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Spec&quot;</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">hashes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">hashlen</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cover</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nodes&quot;</span><span class="p">,</span>
    <span class="n">indent</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DEFAULT_FORMAT</span><span class="p">,</span>
    <span class="n">deptypes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="n">show_types</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">depth_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">recurse_dependencies</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">status_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;Spec&quot;</span><span class="p">],</span> <span class="n">InstallStatus</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;Spec&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prints out specs and their dependencies, tree-formatted with indentation.</span>

<span class="sd">    Status function may either output a boolean or an InstallStatus</span>

<span class="sd">    Args:</span>
<span class="sd">        color: if True, always colorize the tree. If False, don&#39;t colorize the tree. If None,</span>
<span class="sd">            use the default from llnl.tty.color</span>
<span class="sd">        depth: print the depth from the root</span>
<span class="sd">        hashes: if True, print the hash of each node</span>
<span class="sd">        hashlen: length of the hash to be printed</span>
<span class="sd">        cover: either &quot;nodes&quot; or &quot;edges&quot;</span>
<span class="sd">        indent: extra indentation for the tree being printed</span>
<span class="sd">        format: format to be used to print each node</span>
<span class="sd">        deptypes: dependency types to be represented in the tree</span>
<span class="sd">        show_types: if True, show the (merged) dependency type of a node</span>
<span class="sd">        depth_first: if True, traverse the DAG depth first when representing it as a tree</span>
<span class="sd">        recurse_dependencies: if True, recurse on dependencies</span>
<span class="sd">        status_fn: optional callable that takes a node as an argument and return its</span>
<span class="sd">            installation status</span>
<span class="sd">        prefix: optional callable that takes a node as an argument and return its</span>
<span class="sd">            installation prefix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">clr</span><span class="o">.</span><span class="n">get_color_when</span><span class="p">()</span>

    <span class="c1"># reduce deptypes over all in-edges when covering nodes</span>
    <span class="k">if</span> <span class="n">show_types</span> <span class="ow">and</span> <span class="n">cover</span> <span class="o">==</span> <span class="s2">&quot;nodes&quot;</span><span class="p">:</span>
        <span class="n">deptype_lookup</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">traverse</span><span class="o">.</span><span class="n">traverse_edges</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">cover</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span> <span class="n">deptype</span><span class="o">=</span><span class="n">deptypes</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">deptype_lookup</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">()]</span> <span class="o">|=</span> <span class="n">edge</span><span class="o">.</span><span class="n">depflag</span>

    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">dep_spec</span> <span class="ow">in</span> <span class="n">traverse</span><span class="o">.</span><span class="n">traverse_tree</span><span class="p">(</span>
        <span class="nb">sorted</span><span class="p">(</span><span class="n">specs</span><span class="p">),</span> <span class="n">cover</span><span class="o">=</span><span class="n">cover</span><span class="p">,</span> <span class="n">deptype</span><span class="o">=</span><span class="n">deptypes</span><span class="p">,</span> <span class="n">depth_first</span><span class="o">=</span><span class="n">depth_first</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span>
    <span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">dep_spec</span><span class="o">.</span><span class="n">spec</span>

        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">prefix</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="n">indent</span>

        <span class="k">if</span> <span class="n">depth</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%-4d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">d</span>

        <span class="k">if</span> <span class="n">status_fn</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">status_fn</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">status</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">InstallStatus</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="n">clr</span><span class="o">.</span><span class="n">colorize</span><span class="p">(</span><span class="n">status</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">status</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="n">clr</span><span class="o">.</span><span class="n">colorize</span><span class="p">(</span><span class="s2">&quot;@g{[+]}  &quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="n">clr</span><span class="o">.</span><span class="n">colorize</span><span class="p">(</span><span class="s2">&quot;@r{[-]}  &quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hashes</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">clr</span><span class="o">.</span><span class="n">colorize</span><span class="p">(</span><span class="s2">&quot;@K{</span><span class="si">%s</span><span class="s2">}  &quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">(</span><span class="n">hashlen</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cover</span> <span class="o">==</span> <span class="s2">&quot;nodes&quot;</span><span class="p">:</span>
                <span class="n">depflag</span> <span class="o">=</span> <span class="n">deptype_lookup</span><span class="p">[</span><span class="n">dep_spec</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">()]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># when covering edges or paths, we show dependency</span>
                <span class="c1"># types only for the edge through which we visited</span>
                <span class="n">depflag</span> <span class="o">=</span> <span class="n">dep_spec</span><span class="o">.</span><span class="n">depflag</span>

            <span class="n">type_chars</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">flag_to_chars</span><span class="p">(</span><span class="n">depflag</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]  &quot;</span> <span class="o">%</span> <span class="n">type_chars</span>

        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;    &quot;</span> <span class="o">*</span> <span class="n">d</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;^&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="c1"># Check if we wanted just the first line</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">recurse_dependencies</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="Spec">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec">[docs]</a>
<span class="nd">@lang</span><span class="o">.</span><span class="n">lazy_lexicographic_ordering</span><span class="p">(</span><span class="n">set_hash</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Spec</span><span class="p">:</span>
    <span class="c1">#: Cache for spec&#39;s prefix, computed lazily in the corresponding property</span>
    <span class="n">_prefix</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">abstract_hash</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Spec.default_arch">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.default_arch">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">default_arch</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an anonymous spec for the default architecture&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Spec</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">architecture</span> <span class="o">=</span> <span class="n">ArchSpec</span><span class="o">.</span><span class="n">default_arch</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">s</span></div>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spec_like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">concrete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">external_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">external_modules</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new Spec.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            spec_like (optional string): if not provided, we initialize</span>
<span class="sd">                an anonymous Spec that matches any Spec object; if</span>
<span class="sd">                provided we parse this as a Spec string.</span>

<span class="sd">        Keyword arguments:</span>
<span class="sd">        # assign special fields from constructor</span>
<span class="sd">        self._normal = normal</span>
<span class="sd">        self._concrete = concrete</span>
<span class="sd">        self.external_path = external_path</span>
<span class="sd">        self.external_module = external_module</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Copy if spec_like is a Spec.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec_like</span><span class="p">,</span> <span class="n">Spec</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dup</span><span class="p">(</span><span class="n">spec_like</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># init an empty spec that matches anything.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">versions</span> <span class="o">=</span> <span class="n">vn</span><span class="o">.</span><span class="n">VersionList</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variants</span> <span class="o">=</span> <span class="n">VariantMap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span> <span class="o">=</span> <span class="n">FlagMap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dependents</span> <span class="o">=</span> <span class="n">_EdgeMap</span><span class="p">(</span><span class="n">store_by_child</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span> <span class="o">=</span> <span class="n">_EdgeMap</span><span class="p">(</span><span class="n">store_by_child</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># initial values for all spec hash types</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">hashes</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Python __hash__ is handled separately from the cached spec hashes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dunder_hash</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># cache of package for this spec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_package</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Most of these are internal implementation details that can be</span>
        <span class="c1"># set by internal Spack calls in the constructor.</span>
        <span class="c1">#</span>
        <span class="c1"># For example, Specs are by default not assumed to be normal, but</span>
        <span class="c1"># in some cases we&#39;ve read them from a file want to assume</span>
        <span class="c1"># normal.  This allows us to manipulate specs that Spack doesn&#39;t</span>
        <span class="c1"># have package.py files for.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span> <span class="o">=</span> <span class="n">normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_concrete</span> <span class="o">=</span> <span class="n">concrete</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_path</span> <span class="o">=</span> <span class="n">external_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external_modules</span> <span class="o">=</span> <span class="n">Spec</span><span class="o">.</span><span class="n">_format_module_list</span><span class="p">(</span><span class="n">external_modules</span><span class="p">)</span>

        <span class="c1"># This attribute is used to store custom information for external specs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_attributes</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># This attribute holds the original build copy of the spec if it is</span>
        <span class="c1"># deployed differently than it was built. None signals that the spec</span>
        <span class="c1"># is deployed &quot;as built.&quot;</span>
        <span class="c1"># Build spec should be the actual build spec unless marked dirty.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_spec</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec_like</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">spack</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse_one_or_raise</span><span class="p">(</span><span class="n">spec_like</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">spec_like</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t make spec out of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">spec_like</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_format_module_list</span><span class="p">(</span><span class="n">modules</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a module list that is suitable for YAML serialization</span>
<span class="sd">        and hash computation.</span>

<span class="sd">        Given a module list, possibly read from a configuration file,</span>
<span class="sd">        return an object that serializes to a consistent YAML string</span>
<span class="sd">        before/after round-trip serialization to/from a Spec dictionary</span>
<span class="sd">        (stored in JSON format): when read in, the module list may</span>
<span class="sd">        contain YAML formatting that is discarded (non-essential)</span>
<span class="sd">        when stored as a Spec dictionary; we take care in this function</span>
<span class="sd">        to discard such formatting such that the Spec hash does not</span>
<span class="sd">        change before/after storage in JSON.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">modules</span><span class="p">:</span>
            <span class="n">modules</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">modules</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">modules</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">external_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">llnl</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">path_to_os_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_external_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@external_path</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">external_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext_path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_path</span> <span class="o">=</span> <span class="n">ext_path</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">external</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">external_path</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">external_modules</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_develop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return whether the Spec represents a user-developed package</span>
<span class="sd">        in a Spack ``Environment`` (i.e. using `spack develop`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dev_path&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

<div class="viewcode-block" id="Spec.clear_dependencies">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.clear_dependencies">[docs]</a>
    <span class="k">def</span> <span class="nf">clear_dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Trim the dependencies of this spec.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>


<div class="viewcode-block" id="Spec.clear_edges">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.clear_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">clear_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Trim the dependencies and dependents of this spec.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dependents</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>


<div class="viewcode-block" id="Spec.detach">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.detach">[docs]</a>
    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deptype</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove any reference that dependencies have of this node.</span>

<span class="sd">        Args:</span>
<span class="sd">            deptype (str or tuple): dependency types tracked by the</span>
<span class="sd">                current spec</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">()</span>
        <span class="c1"># Go through the dependencies</span>
        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span><span class="p">(</span><span class="n">deptype</span><span class="o">=</span><span class="n">deptype</span><span class="p">):</span>
            <span class="c1"># Remove the spec from dependents</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">dep</span><span class="o">.</span><span class="n">_dependents</span><span class="p">:</span>
                <span class="n">dependents_copy</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">_dependents</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">dep</span><span class="o">.</span><span class="n">_dependents</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">dependents_copy</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">()</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">dep</span><span class="o">.</span><span class="n">_dependents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_dependency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># WARNING: This function is an implementation detail of the</span>
        <span class="c1"># WARNING: original concretizer. Since with that greedy</span>
        <span class="c1"># WARNING: algorithm we don&#39;t allow multiple nodes from</span>
        <span class="c1"># WARNING: the same package in a DAG, here we hard-code</span>
        <span class="c1"># WARNING: using index 0 i.e. we assume that we have only</span>
        <span class="c1"># WARNING: one edge from package &quot;name&quot;</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_to_dependencies</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s1">&#39;expected only 1 &quot;</span><span class="si">{0}</span><span class="s1">&quot; dependency, but got </span><span class="si">{1}</span><span class="s1">&#39;</span>
            <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span><span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">deps</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">deps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Spec.edges_from_dependents">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.edges_from_dependents">[docs]</a>
    <span class="k">def</span> <span class="nf">edges_from_dependents</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">depflag</span><span class="p">:</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">ALL</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">virtuals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">DependencySpec</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of edges connecting this node in the DAG</span>
<span class="sd">        to parents.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): filter dependents by package name</span>
<span class="sd">            depflag: allowed dependency types</span>
<span class="sd">            virtuals: allowed virtuals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependents</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="n">depflag</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="n">virtuals</span><span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Spec.edges_to_dependencies">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.edges_to_dependencies">[docs]</a>
    <span class="k">def</span> <span class="nf">edges_to_dependencies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">depflag</span><span class="p">:</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">ALL</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">virtuals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">DependencySpec</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of edges connecting this node in the DAG to children.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): filter dependencies by package name</span>
<span class="sd">            depflag: allowed dependency types</span>
<span class="sd">            virtuals: allowed virtuals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">child</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="n">depflag</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="n">virtuals</span><span class="p">)</span>
        <span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper method to print edge attributes in spec literals&quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_from_dependents</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="n">union</span> <span class="o">=</span> <span class="n">DependencySpec</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="n">Spec</span><span class="p">(),</span> <span class="n">spec</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">union</span><span class="o">.</span><span class="n">update_deptypes</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">depflag</span><span class="p">)</span>
            <span class="n">union</span><span class="o">.</span><span class="n">update_virtuals</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">virtuals</span><span class="p">)</span>
        <span class="n">deptypes_str</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;deptypes=</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">flag_to_tuple</span><span class="p">(</span><span class="n">union</span><span class="o">.</span><span class="n">depflag</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">union</span><span class="o">.</span><span class="n">depflag</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="p">)</span>
        <span class="n">virtuals_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;virtuals=</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">union</span><span class="o">.</span><span class="n">virtuals</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">union</span><span class="o">.</span><span class="n">virtuals</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">deptypes_str</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">virtuals_str</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">deptypes_str</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">virtuals_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">]&quot;</span>

<div class="viewcode-block" id="Spec.dependencies">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.dependencies">[docs]</a>
    <span class="k">def</span> <span class="nf">dependencies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">deptype</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">dt</span><span class="o">.</span><span class="n">DepTypes</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">ALL</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">virtuals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Spec&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of direct dependencies (nodes in the DAG)</span>

<span class="sd">        Args:</span>
<span class="sd">            name: filter dependencies by package name</span>
<span class="sd">            deptype: allowed dependency types</span>
<span class="sd">            virtuals: allowed virtuals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deptype</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">):</span>
            <span class="n">deptype</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">deptype</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">d</span><span class="o">.</span><span class="n">spec</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_to_dependencies</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="n">deptype</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="n">virtuals</span><span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Spec.dependents">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.dependents">[docs]</a>
    <span class="k">def</span> <span class="nf">dependents</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deptype</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">dt</span><span class="o">.</span><span class="n">DepTypes</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">ALL</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Spec&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of direct dependents (nodes in the DAG).</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): filter dependents by package name</span>
<span class="sd">            deptype: allowed dependency types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deptype</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">):</span>
            <span class="n">deptype</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">deptype</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">parent</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_from_dependents</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="n">deptype</span><span class="p">)]</span></div>


    <span class="k">def</span> <span class="nf">_dependencies_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depflag</span><span class="p">:</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">ALL</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dictionary, keyed by package name, of the direct</span>
<span class="sd">        dependencies.</span>

<span class="sd">        Each value in the dictionary is a list of edges.</span>

<span class="sd">        Args:</span>
<span class="sd">            deptype: allowed dependency types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_sort_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">_sort_by_dep_types</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">_group_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span>
        <span class="n">selected_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">depflag</span><span class="o">=</span><span class="n">depflag</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">selected_edges</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">_sort_fn</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">_group_fn</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_add_flag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">propagate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Called by the parser to add a known flag.</span>
<span class="sd">        Known flags currently include &quot;arch&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">propagate</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">vt</span><span class="o">.</span><span class="n">reserved_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedPropagationError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Propagation with &#39;==&#39; is not supported for &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="n">valid_flags</span> <span class="o">=</span> <span class="n">FlagMap</span><span class="o">.</span><span class="n">valid_compiler_flags</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;arch&quot;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;architecture&quot;</span><span class="p">:</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">))</span>
            <span class="n">plat</span><span class="p">,</span> <span class="n">os</span><span class="p">,</span> <span class="n">tgt</span> <span class="o">=</span> <span class="n">parts</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_architecture</span><span class="p">(</span><span class="n">platform</span><span class="o">=</span><span class="n">plat</span><span class="p">,</span> <span class="n">os</span><span class="o">=</span><span class="n">os</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">tgt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;platform&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_architecture</span><span class="p">(</span><span class="n">platform</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;os&quot;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;operating_system&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_architecture</span><span class="p">(</span><span class="n">os</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_architecture</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;namespace&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">valid_flags</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">flags_and_propagation</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">compiler</span><span class="o">.</span><span class="n">tokenize_flags</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">propagate</span><span class="p">)</span>
            <span class="n">flag_group</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">flags_and_propagation</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">flag</span><span class="p">,</span> <span class="n">propagation</span> <span class="ow">in</span> <span class="n">flags_and_propagation</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span><span class="o">.</span><span class="n">add_flag</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">propagation</span><span class="p">,</span> <span class="n">flag_group</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># FIXME:</span>
            <span class="c1"># All other flags represent variants. &#39;foo=true&#39; and &#39;foo=false&#39;</span>
            <span class="c1"># map to &#39;+foo&#39; and &#39;~foo&#39; respectively. As such they need a</span>
            <span class="c1"># BoolValuedVariant instance.</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;TRUE&quot;</span> <span class="ow">or</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;FALSE&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">BoolValuedVariant</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">propagate</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">AbstractVariant</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">propagate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_architecture</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Called by the parser to set the architecture.&quot;&quot;&quot;</span>
        <span class="n">arch_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;platform&quot;</span><span class="p">,</span> <span class="s2">&quot;os&quot;</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DuplicateArchitectureError</span><span class="p">(</span><span class="s2">&quot;Spec cannot have two architectures.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="p">:</span>
            <span class="n">new_vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">arch_attrs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span> <span class="o">=</span> <span class="n">ArchSpec</span><span class="p">(</span><span class="n">new_vals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_attrvals</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arch_attrs</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">new_attr</span><span class="p">,</span> <span class="n">new_value</span> <span class="ow">in</span> <span class="n">new_attrvals</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="p">,</span> <span class="n">new_attr</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">DuplicateArchitectureError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot specify &#39;</span><span class="si">{</span><span class="n">new_attr</span><span class="si">}</span><span class="s2">&#39; twice&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="p">,</span> <span class="n">new_attr</span><span class="p">,</span> <span class="n">new_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_dependency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="s2">&quot;Spec&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">depflag</span><span class="p">:</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">,</span> <span class="n">virtuals</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Called by the parser to add another spec as a dependency.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_dependency_edge</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="n">depflag</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="n">virtuals</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Keep the intersection of constraints when a dependency is added multiple times with</span>
        <span class="c1"># the same deptype. Add a new dependency if it is added with a compatible deptype</span>
        <span class="c1"># (for example, a build-only dependency is compatible with a link-only dependenyc).</span>
        <span class="c1"># The only restrictions, currently, are that we cannot add edges with overlapping</span>
        <span class="c1"># dependency types and we cannot add multiple edges that have link/run dependency types.</span>
        <span class="c1"># See ``spack.deptypes.compatible``.</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dspec</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">dspec</span> <span class="k">for</span> <span class="n">dspec</span> <span class="ow">in</span> <span class="n">orig</span> <span class="k">if</span> <span class="n">depflag</span> <span class="o">==</span> <span class="n">dspec</span><span class="o">.</span><span class="n">depflag</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="c1"># Error if we have overlapping or incompatible deptypes</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">dt</span><span class="o">.</span><span class="n">compatible</span><span class="p">(</span><span class="n">dspec</span><span class="o">.</span><span class="n">depflag</span><span class="p">,</span> <span class="n">depflag</span><span class="p">)</span> <span class="k">for</span> <span class="n">dspec</span> <span class="ow">in</span> <span class="n">orig</span><span class="p">):</span>
                <span class="n">edge_attrs</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;deptypes=</span><span class="si">{</span><span class="n">dt</span><span class="o">.</span><span class="n">flag_to_chars</span><span class="p">(</span><span class="n">depflag</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">required_dep_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;^[</span><span class="si">{</span><span class="n">edge_attrs</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="k">raise</span> <span class="n">DuplicateDependencyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is a duplicate dependency, with conflicting dependency types</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&#39;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; cannot depend on &#39;</span><span class="si">{</span><span class="n">required_dep_str</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">add_dependency_edge</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="n">depflag</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="n">virtuals</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">dspec</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
            <span class="n">dspec</span><span class="o">.</span><span class="n">update_virtuals</span><span class="p">(</span><span class="n">virtuals</span><span class="o">=</span><span class="n">virtuals</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">UnsatisfiableSpecError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DuplicateDependencyError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot depend on incompatible specs &#39;</span><span class="si">{</span><span class="n">dspec</span><span class="o">.</span><span class="n">spec</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">spec</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="Spec.add_dependency_edge">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.add_dependency_edge">[docs]</a>
    <span class="k">def</span> <span class="nf">add_dependency_edge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dependency_spec</span><span class="p">:</span> <span class="s2">&quot;Spec&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">depflag</span><span class="p">:</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">,</span> <span class="n">virtuals</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a dependency edge to this spec.</span>

<span class="sd">        Args:</span>
<span class="sd">            dependency_spec: spec of the dependency</span>
<span class="sd">            deptypes: dependency types for this edge</span>
<span class="sd">            virtuals: virtuals provided by this edge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if we need to update edges that are already present</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">child</span><span class="o">=</span><span class="n">dependency_spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">selected</span><span class="p">:</span>
            <span class="n">has_errors</span><span class="p">,</span> <span class="n">details</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[]</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;cannot update the edge from </span><span class="si">{</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="c1"># If the dependency is to an existing spec, we can update dependency</span>
            <span class="c1"># types. If it is to a new object, check deptype compatibility.</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">dependency_spec</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dt</span><span class="o">.</span><span class="n">compatible</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">depflag</span><span class="p">,</span> <span class="n">depflag</span><span class="p">):</span>
                <span class="n">has_errors</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">details</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> has already an edge matching any&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; of these types </span><span class="si">{</span><span class="n">depflag</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">virtuals</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">virtuals</span><span class="p">):</span>
                    <span class="n">details</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> has already an edge matching any&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; of these virtuals </span><span class="si">{</span><span class="n">virtuals</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="n">has_errors</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">details</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">selected</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">dependency_spec</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="p">):</span>
                <span class="c1"># If we are here, it means the edge object was previously added to</span>
                <span class="c1"># both the parent and the child. When we update this object they&#39;ll</span>
                <span class="c1"># both see the deptype modification.</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">update_deptypes</span><span class="p">(</span><span class="n">depflag</span><span class="o">=</span><span class="n">depflag</span><span class="p">)</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">update_virtuals</span><span class="p">(</span><span class="n">virtuals</span><span class="o">=</span><span class="n">virtuals</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">edge</span> <span class="o">=</span> <span class="n">DependencySpec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependency_spec</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="n">depflag</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="n">virtuals</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        <span class="n">dependency_spec</span><span class="o">.</span><span class="n">_dependents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span></div>


    <span class="c1">#</span>
    <span class="c1"># Public interface</span>
    <span class="c1">#</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fullname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namespace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span>
            <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">anonymous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_hash</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Follow dependent links and find the root of this spec&#39;s DAG.</span>

<span class="sd">        Spack specs have a single root (the package being installed).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: In the case of multiple parents this property does not</span>
        <span class="c1"># FIXME: make sense. Should we revisit the semantics?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependents</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">edges_by_package</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dependents</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">edges_by_package</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">root</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">package</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: Spec.package can only be called on concrete specs&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_package</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_package</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_package</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">package_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal package call gets only the class object for a package.</span>
<span class="sd">        Use this to just get package metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">get_pkg_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">virtual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">is_virtual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">concrete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A spec is concrete if it describes a single build of a package.</span>

<span class="sd">        More formally, a spec is concrete if concretize() has been called</span>
<span class="sd">        on it and it has been marked `_concrete`.</span>

<span class="sd">        Concrete specs either can be or have been built. All constraints</span>
<span class="sd">        have been resolved, optional dependencies have been added or</span>
<span class="sd">        removed, a compiler has been chosen, and all variants have</span>
<span class="sd">        values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concrete</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spliced</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns whether or not this Spec is being deployed as built i.e.</span>
<span class="sd">        whether or not this Spec has ever been spliced.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">build_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">installed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Installation status of a package.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if the package has been installed, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># If the spec is in the DB, check the installed</span>
            <span class="c1"># attribute of the record</span>
            <span class="k">return</span> <span class="n">spack</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">STORE</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">get_record</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">installed</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># If the spec is not in the DB, the method</span>
            <span class="c1">#  above raises a Key error</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">installed_upstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the spec is installed in an upstream repository.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if the package is installed in an upstream, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">upstream</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">STORE</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">query_by_spec_hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">upstream</span>

<div class="viewcode-block" id="Spec.traverse">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.traverse">[docs]</a>
    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shorthand for :meth:`~spack.traverse.traverse_nodes`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">traverse</span><span class="o">.</span><span class="n">traverse_nodes</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.traverse_edges">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.traverse_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">traverse_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shorthand for :meth:`~spack.traverse.traverse_edges`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">traverse</span><span class="o">.</span><span class="n">traverse_edges</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">short_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a version of the spec with the dependencies hashed</span>
<span class="sd">        instead of completely enumerated.&quot;&quot;&quot;</span>
        <span class="n">spec_format</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{name}</span><span class="s2">{@version}{</span><span class="si">%c</span><span class="s2">ompiler.name}{@compiler.version}&quot;</span>
        <span class="n">spec_format</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{variants}</span><span class="s2">{ arch=architecture}{/hash:7}&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec_format</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cshort_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an auto-colorized version of ``self.short_spec``.&quot;&quot;&quot;</span>
        <span class="n">spec_format</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{name}</span><span class="s2">{@version}{</span><span class="si">%c</span><span class="s2">ompiler.name}{@compiler.version}&quot;</span>
        <span class="n">spec_format</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{variants}</span><span class="s2">{ arch=architecture}{/hash:7}&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cformat</span><span class="p">(</span><span class="n">spec_format</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concrete</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span><span class="s2">&quot;Spec is not concrete: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upstream</span><span class="p">,</span> <span class="n">record</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">STORE</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">query_by_spec_hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">record</span> <span class="ow">and</span> <span class="n">record</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">path</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">STORE</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">path_for_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span>

    <span class="nd">@prefix</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">Prefix</span><span class="p">(</span><span class="n">llnl</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">convert_to_platform_path</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

<div class="viewcode-block" id="Spec.spec_hash">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.spec_hash">[docs]</a>
    <span class="k">def</span> <span class="nf">spec_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Utility method for computing different types of Spec hashes.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hash (spack.hash_types.SpecHashDescriptor): type of hash to generate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: currently we strip build dependencies by default.  Rethink</span>
        <span class="c1"># this when we move to using package hashing on all specs.</span>
        <span class="k">if</span> <span class="nb">hash</span><span class="o">.</span><span class="n">override</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="o">.</span><span class="n">override</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">node_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_node_dict</span><span class="p">(</span><span class="nb">hash</span><span class="o">=</span><span class="nb">hash</span><span class="p">)</span>
        <span class="n">json_text</span> <span class="o">=</span> <span class="n">sjson</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">node_dict</span><span class="p">)</span>
        <span class="c1"># This implements &quot;frankenhashes&quot;, preserving the last 7 characters of the</span>
        <span class="c1"># original hash when splicing so that we can avoid relocation issues</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">hash</span><span class="o">.</span><span class="n">b32_hash</span><span class="p">(</span><span class="n">json_text</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">[:</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_spec</span><span class="o">.</span><span class="n">spec_hash</span><span class="p">(</span><span class="nb">hash</span><span class="p">)[</span><span class="o">-</span><span class="mi">7</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="k">def</span> <span class="nf">_cached_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function for storing a cached hash on the spec.</span>

<span class="sd">        This will run spec_hash() with the deptype and package_hash</span>
<span class="sd">        parameters, and if this spec is concrete, it will store the value</span>
<span class="sd">        in the supplied attribute on this spec.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hash (spack.hash_types.SpecHashDescriptor): type of hash to generate.</span>
<span class="sd">            length (int): length of hash prefix to return (default is full hash string)</span>
<span class="sd">            force (bool): cache the hash even if spec is not concrete (default False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hash</span><span class="o">.</span><span class="n">attr</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_hash</span><span class="p">(</span><span class="nb">hash</span><span class="p">)[:</span><span class="n">length</span><span class="p">]</span>

        <span class="n">hash_string</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hash_string</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hash_string</span><span class="p">[:</span><span class="n">length</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hash_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_hash</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">force</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="n">hash_string</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">hash_string</span><span class="p">[:</span><span class="n">length</span><span class="p">]</span>

<div class="viewcode-block" id="Spec.package_hash">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.package_hash">[docs]</a>
    <span class="k">def</span> <span class="nf">package_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the hash of the contents of the package for this node&quot;&quot;&quot;</span>
        <span class="c1"># Concrete specs with the old DAG hash did not have the package hash, so we do</span>
        <span class="c1"># not know what the package looked like at concretization time</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_package_hash</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot call package_hash() on concrete specs with the old dag_hash()&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_hash</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">package_hash</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.dag_hash">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.dag_hash">[docs]</a>
    <span class="k">def</span> <span class="nf">dag_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This is Spack&#39;s default hash, used to identify installations.</span>

<span class="sd">        Same as the full hash (includes package hash and build/link/run deps).</span>
<span class="sd">        Tells us when package files and any dependencies have changes.</span>

<span class="sd">        NOTE: Versions of Spack prior to 0.18 only included link and run deps.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_hash</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.process_hash">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.process_hash">[docs]</a>
    <span class="k">def</span> <span class="nf">process_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hash used to transfer specs among processes.</span>

<span class="sd">        This hash includes build and test dependencies and is only used to</span>
<span class="sd">        serialize a spec and pass it around among processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_hash</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">process_hash</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.dag_hash_bit_prefix">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.dag_hash_bit_prefix">[docs]</a>
    <span class="k">def</span> <span class="nf">dag_hash_bit_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bits</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the first &lt;bits&gt; bits of the DAG hash as an integer type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">spack</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">hash</span><span class="o">.</span><span class="n">base32_prefix_bits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">(),</span> <span class="n">bits</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.process_hash_bit_prefix">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.process_hash_bit_prefix">[docs]</a>
    <span class="k">def</span> <span class="nf">process_hash_bit_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bits</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the first &lt;bits&gt; bits of the DAG hash as an integer type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">spack</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">hash</span><span class="o">.</span><span class="n">base32_prefix_bits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_hash</span><span class="p">(),</span> <span class="n">bits</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_lookup_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lookup just one spec with an abstract hash, returning a spec from the the environment,</span>
<span class="sd">        store, or finally, binary caches.&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">spack.binary_distribution</span>
        <span class="kn">import</span> <span class="nn">spack.environment</span>

        <span class="n">active_env</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">active_environment</span><span class="p">()</span>

        <span class="c1"># First env, then store, then binary cache</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">active_env</span><span class="o">.</span><span class="n">all_matching_specs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">active_env</span> <span class="k">else</span> <span class="p">[])</span>
            <span class="ow">or</span> <span class="n">spack</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">STORE</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">installed</span><span class="o">=</span><span class="nb">any</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">spack</span><span class="o">.</span><span class="n">binary_distribution</span><span class="o">.</span><span class="n">BinaryCacheQuery</span><span class="p">(</span><span class="kc">True</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidHashError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_hash</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AmbiguousHashError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Multiple packages specify hash beginning &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">abstract_hash</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">matches</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Spec.lookup_hash">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.lookup_hash">[docs]</a>
    <span class="k">def</span> <span class="nf">lookup_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given a spec with an abstract hash, return a copy of the spec with all properties and</span>
<span class="sd">        dependencies by looking up the hash in the environment, store, or finally, binary caches.</span>
<span class="sd">        This is non-destructive.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">abstract_hash</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">()):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># root spec is replaced</span>
        <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">abstract_hash</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">_dup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lookup_hash</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">spec</span>

        <span class="c1"># Get dependencies that need to be replaced</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">abstract_hash</span><span class="p">:</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">_add_dependency</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_lookup_hash</span><span class="p">(),</span> <span class="n">depflag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="p">())</span>

        <span class="c1"># reattach nodes that were not otherwise satisfied by new dependencies</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">traverse</span><span class="p">()):</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">_add_dependency</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">depflag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">spec</span></div>


<div class="viewcode-block" id="Spec.replace_hash">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.replace_hash">[docs]</a>
    <span class="k">def</span> <span class="nf">replace_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given a spec with an abstract hash, attempt to populate all properties and dependencies</span>
<span class="sd">        by looking up the hash in the environment, store, or finally, binary caches.</span>
<span class="sd">        This is destructive.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">abstract_hash</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lookup_hash</span><span class="p">())</span></div>


<div class="viewcode-block" id="Spec.to_node_dict">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.to_node_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">to_node_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a dictionary representing the state of this Spec.</span>

<span class="sd">        ``to_node_dict`` creates the content that is eventually hashed by</span>
<span class="sd">        Spack to create identifiers like the DAG hash (see</span>
<span class="sd">        ``dag_hash()``).  Example result of ``to_node_dict`` for the</span>
<span class="sd">        ``sqlite`` package::</span>

<span class="sd">            {</span>
<span class="sd">                &#39;sqlite&#39;: {</span>
<span class="sd">                    &#39;version&#39;: &#39;3.28.0&#39;,</span>
<span class="sd">                    &#39;arch&#39;: {</span>
<span class="sd">                        &#39;platform&#39;: &#39;darwin&#39;,</span>
<span class="sd">                        &#39;platform_os&#39;: &#39;mojave&#39;,</span>
<span class="sd">                        &#39;target&#39;: &#39;x86_64&#39;,</span>
<span class="sd">                    },</span>
<span class="sd">                    &#39;compiler&#39;: {</span>
<span class="sd">                        &#39;name&#39;: &#39;apple-clang&#39;,</span>
<span class="sd">                        &#39;version&#39;: &#39;10.0.0&#39;,</span>
<span class="sd">                    },</span>
<span class="sd">                    &#39;namespace&#39;: &#39;builtin&#39;,</span>
<span class="sd">                    &#39;parameters&#39;: {</span>
<span class="sd">                        &#39;fts&#39;: &#39;true&#39;,</span>
<span class="sd">                        &#39;functions&#39;: &#39;false&#39;,</span>
<span class="sd">                        &#39;cflags&#39;: [],</span>
<span class="sd">                        &#39;cppflags&#39;: [],</span>
<span class="sd">                        &#39;cxxflags&#39;: [],</span>
<span class="sd">                        &#39;fflags&#39;: [],</span>
<span class="sd">                        &#39;ldflags&#39;: [],</span>
<span class="sd">                        &#39;ldlibs&#39;: [],</span>
<span class="sd">                    },</span>
<span class="sd">                    &#39;dependencies&#39;: {</span>
<span class="sd">                        &#39;readline&#39;: {</span>
<span class="sd">                            &#39;hash&#39;: &#39;zvaa4lhlhilypw5quj3akyd3apbq5gap&#39;,</span>
<span class="sd">                            &#39;type&#39;: [&#39;build&#39;, &#39;link&#39;],</span>
<span class="sd">                        }</span>
<span class="sd">                    },</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        Note that the dictionary returned does *not* include the hash of</span>
<span class="sd">        the *root* of the spec, though it does include hashes for each</span>
<span class="sd">        dependency, and (optionally) the package file corresponding to</span>
<span class="sd">        each node.</span>

<span class="sd">        See ``to_dict()`` for a &quot;complete&quot; spec hash, with hashes for</span>
<span class="sd">        each node and nodes for each dependency (instead of just their</span>
<span class="sd">        hashes).</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hash (spack.hash_types.SpecHashDescriptor) type of hash to generate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">()</span>

        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compiler</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;namespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">yaml_entry</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

        <span class="c1"># Only need the string compiler flag for yaml file</span>
        <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span><span class="o">.</span><span class="n">yaml_entry</span><span class="p">(</span><span class="n">flag_type</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">flag_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span>

        <span class="k">if</span> <span class="n">params</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="n">flag_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">name</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">flags</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">propagate</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;propagate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">propagate</span><span class="p">],</span> <span class="n">flag_names</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">external</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;external&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="s2">&quot;path&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_path</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;module&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_modules</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;extra_attributes&quot;</span><span class="p">,</span> <span class="n">syaml</span><span class="o">.</span><span class="n">sorted_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extra_attributes</span><span class="p">)),</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concrete</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;concrete&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="s2">&quot;patches&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">:</span>
            <span class="n">variant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="s2">&quot;patches&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">variant</span><span class="p">,</span> <span class="s2">&quot;_patches_in_order_of_appearance&quot;</span><span class="p">):</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;patches&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">_patches_in_order_of_appearance</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_concrete</span>
            <span class="ow">and</span> <span class="nb">hash</span><span class="o">.</span><span class="n">package_hash</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_package_hash&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_package_hash</span>
        <span class="p">):</span>
            <span class="c1"># We use the attribute here instead of `self.package_hash()` because this</span>
            <span class="c1"># should *always* be assignhed at concretization time. We don&#39;t want to try</span>
            <span class="c1"># to compute a package hash for concrete spec where a) the package might not</span>
            <span class="c1"># exist, or b) the `dag_hash` didn&#39;t include the package hash when the spec</span>
            <span class="c1"># was concretized.</span>
            <span class="n">package_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_package_hash</span>

            <span class="c1"># Full hashes are in bytes</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">package_hash</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">package_hash</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                <span class="n">package_hash</span> <span class="o">=</span> <span class="n">package_hash</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;package_hash&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">package_hash</span>

        <span class="c1"># Note: Relies on sorting dict by keys later in algorithm.</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies_dict</span><span class="p">(</span><span class="n">depflag</span><span class="o">=</span><span class="nb">hash</span><span class="o">.</span><span class="n">depflag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="n">deps_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">edges_for_name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">deps</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">name_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dspec</span> <span class="ow">in</span> <span class="n">edges_for_name</span><span class="p">:</span>
                    <span class="n">hash_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="nb">hash</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dspec</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">_cached_hash</span><span class="p">(</span><span class="nb">hash</span><span class="p">))</span>
                    <span class="n">parameters_tuple</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;parameters&quot;</span><span class="p">,</span>
                        <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">(</span>
                            <span class="p">(</span>
                                <span class="p">(</span><span class="s2">&quot;deptypes&quot;</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">flag_to_tuple</span><span class="p">(</span><span class="n">dspec</span><span class="o">.</span><span class="n">depflag</span><span class="p">)),</span>
                                <span class="p">(</span><span class="s2">&quot;virtuals&quot;</span><span class="p">,</span> <span class="n">dspec</span><span class="o">.</span><span class="n">virtuals</span><span class="p">),</span>
                            <span class="p">)</span>
                        <span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">ordered_entries</span> <span class="o">=</span> <span class="p">[</span><span class="n">name_tuple</span><span class="p">,</span> <span class="n">hash_tuple</span><span class="p">,</span> <span class="n">parameters_tuple</span><span class="p">]</span>
                    <span class="n">deps_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">(</span><span class="n">ordered_entries</span><span class="p">))</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;dependencies&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deps_list</span>

        <span class="c1"># Name is included in case this is replacing a virtual.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_spec</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;build_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">(</span>
                <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_spec</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="p">(</span><span class="nb">hash</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_spec</span><span class="o">.</span><span class="n">_cached_hash</span><span class="p">(</span><span class="nb">hash</span><span class="p">))]</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>


<div class="viewcode-block" id="Spec.to_dict">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.to_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a dictionary suitable for writing this spec to YAML or JSON.</span>

<span class="sd">        This dictionaries like the one that is ultimately written to a</span>
<span class="sd">        ``spec.json`` file in each Spack installation directory.  For</span>
<span class="sd">        example, for sqlite::</span>

<span class="sd">            {</span>
<span class="sd">            &quot;spec&quot;: {</span>
<span class="sd">                &quot;_meta&quot;: {</span>
<span class="sd">                &quot;version&quot;: 2</span>
<span class="sd">                },</span>
<span class="sd">                &quot;nodes&quot;: [</span>
<span class="sd">                {</span>
<span class="sd">                    &quot;name&quot;: &quot;sqlite&quot;,</span>
<span class="sd">                    &quot;version&quot;: &quot;3.34.0&quot;,</span>
<span class="sd">                    &quot;arch&quot;: {</span>
<span class="sd">                    &quot;platform&quot;: &quot;darwin&quot;,</span>
<span class="sd">                    &quot;platform_os&quot;: &quot;catalina&quot;,</span>
<span class="sd">                    &quot;target&quot;: &quot;x86_64&quot;</span>
<span class="sd">                    },</span>
<span class="sd">                    &quot;compiler&quot;: {</span>
<span class="sd">                    &quot;name&quot;: &quot;apple-clang&quot;,</span>
<span class="sd">                    &quot;version&quot;: &quot;11.0.0&quot;</span>
<span class="sd">                    },</span>
<span class="sd">                    &quot;namespace&quot;: &quot;builtin&quot;,</span>
<span class="sd">                    &quot;parameters&quot;: {</span>
<span class="sd">                    &quot;column_metadata&quot;: true,</span>
<span class="sd">                    &quot;fts&quot;: true,</span>
<span class="sd">                    &quot;functions&quot;: false,</span>
<span class="sd">                    &quot;rtree&quot;: false,</span>
<span class="sd">                    &quot;cflags&quot;: [],</span>
<span class="sd">                    &quot;cppflags&quot;: [],</span>
<span class="sd">                    &quot;cxxflags&quot;: [],</span>
<span class="sd">                    &quot;fflags&quot;: [],</span>
<span class="sd">                    &quot;ldflags&quot;: [],</span>
<span class="sd">                    &quot;ldlibs&quot;: []</span>
<span class="sd">                    },</span>
<span class="sd">                    &quot;dependencies&quot;: [</span>
<span class="sd">                    {</span>
<span class="sd">                        &quot;name&quot;: &quot;readline&quot;,</span>
<span class="sd">                        &quot;hash&quot;: &quot;4f47cggum7p4qmp3xna4hi547o66unva&quot;,</span>
<span class="sd">                        &quot;type&quot;: [</span>
<span class="sd">                        &quot;build&quot;,</span>
<span class="sd">                        &quot;link&quot;</span>
<span class="sd">                        ]</span>
<span class="sd">                    },</span>
<span class="sd">                    {</span>
<span class="sd">                        &quot;name&quot;: &quot;zlib&quot;,</span>
<span class="sd">                        &quot;hash&quot;: &quot;uvgh6p7rhll4kexqnr47bvqxb3t33jtq&quot;,</span>
<span class="sd">                        &quot;type&quot;: [</span>
<span class="sd">                        &quot;build&quot;,</span>
<span class="sd">                        &quot;link&quot;</span>
<span class="sd">                        ]</span>
<span class="sd">                    }</span>
<span class="sd">                    ],</span>
<span class="sd">                    &quot;hash&quot;: &quot;tve45xfqkfgmzwcyfetze2z6syrg7eaf&quot;,</span>
<span class="sd">                },</span>
<span class="sd">                    # ... more node dicts for readline and its dependencies ...</span>
<span class="sd">                ]</span>
<span class="sd">            }</span>

<span class="sd">        Note that this dictionary starts with the &#39;spec&#39; key, and what</span>
<span class="sd">        follows is a list starting with the root spec, followed by its</span>
<span class="sd">        dependencies in preorder.  Each node in the list also has a</span>
<span class="sd">        &#39;hash&#39; key that contains the hash of the node *without* the hash</span>
<span class="sd">        field included.</span>

<span class="sd">        In the example, the package content hash is not included in the</span>
<span class="sd">        spec, but if ``package_hash`` were true there would be an</span>
<span class="sd">        additional field on each node called ``package_hash``.</span>

<span class="sd">        ``from_dict()`` can be used to read back in a spec that has been</span>
<span class="sd">        converted to a dictionary, serialized, and read back in.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            deptype (tuple or str): dependency types to include when</span>
<span class="sd">                traversing the spec.</span>
<span class="sd">            package_hash (bool): whether to include package content</span>
<span class="sd">                hashes in the dictionary.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Using a list to preserve preorder traversal for hash.</span>
        <span class="n">hash_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;pre&quot;</span><span class="p">,</span> <span class="n">deptype</span><span class="o">=</span><span class="nb">hash</span><span class="o">.</span><span class="n">depflag</span><span class="p">):</span>
            <span class="n">spec_hash</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_cached_hash</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">spec_hash</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hash_set</span><span class="p">:</span>
                <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">node_dict_with_hashes</span><span class="p">(</span><span class="nb">hash</span><span class="p">))</span>
                <span class="n">hash_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">spec_hash</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">build_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">build_spec_list</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">build_spec</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="nb">hash</span><span class="p">)[</span><span class="s2">&quot;spec&quot;</span><span class="p">][</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">build_spec_list</span><span class="p">:</span>
                    <span class="n">node_hash</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="nb">hash</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">node_hash</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hash_set</span><span class="p">:</span>
                        <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                        <span class="n">hash_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node_hash</span><span class="p">)</span>

        <span class="n">meta_dict</span> <span class="o">=</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">([(</span><span class="s2">&quot;version&quot;</span><span class="p">,</span> <span class="n">SPECFILE_FORMAT_VERSION</span><span class="p">)])</span>
        <span class="n">inner_dict</span> <span class="o">=</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">([(</span><span class="s2">&quot;_meta&quot;</span><span class="p">,</span> <span class="n">meta_dict</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;nodes&quot;</span><span class="p">,</span> <span class="n">node_list</span><span class="p">)])</span>
        <span class="n">spec_dict</span> <span class="o">=</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">([(</span><span class="s2">&quot;spec&quot;</span><span class="p">,</span> <span class="n">inner_dict</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">spec_dict</span></div>


<div class="viewcode-block" id="Spec.node_dict_with_hashes">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.node_dict_with_hashes">[docs]</a>
    <span class="k">def</span> <span class="nf">node_dict_with_hashes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a node_dict of this spec with the dag hash added.  If this</span>
<span class="sd">        spec is concrete, the full hash is added as well.  If &#39;build&#39; is in</span>
<span class="sd">        the hash_type, the build hash is also added.&quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_node_dict</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
        <span class="c1"># All specs have at least a DAG hash</span>
        <span class="n">node</span><span class="p">[</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="n">node</span><span class="p">[</span><span class="s2">&quot;concrete&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># we can also give them other hash types if we want</span>
        <span class="k">if</span> <span class="nb">hash</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">node</span><span class="p">[</span><span class="nb">hash</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_hash</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span></div>


<div class="viewcode-block" id="Spec.to_yaml">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.to_yaml">[docs]</a>
    <span class="k">def</span> <span class="nf">to_yaml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syaml</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="nb">hash</span><span class="p">),</span> <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span> <span class="n">default_flow_style</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.to_json">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.to_json">[docs]</a>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sjson</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="nb">hash</span><span class="p">),</span> <span class="n">stream</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.from_specfile">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.from_specfile">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_specfile</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a spec from a JSON or YAML spec file path&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
            <span class="n">file_content</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.json&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">Spec</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">file_content</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Spec</span><span class="o">.</span><span class="n">from_yaml</span><span class="p">(</span><span class="n">file_content</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.override">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.override">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">override</span><span class="p">(</span><span class="n">init_spec</span><span class="p">,</span> <span class="n">change_spec</span><span class="p">):</span>
        <span class="c1"># TODO: this doesn&#39;t account for the case where the changed spec</span>
        <span class="c1"># (and the user spec) have dependencies</span>
        <span class="n">new_spec</span> <span class="o">=</span> <span class="n">init_spec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">package_cls</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">get_pkg_class</span><span class="p">(</span><span class="n">new_spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">versions</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">versions</span> <span class="o">==</span> <span class="n">vn</span><span class="o">.</span><span class="n">any_version</span><span class="p">:</span>
            <span class="n">new_spec</span><span class="o">.</span><span class="n">versions</span> <span class="o">=</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">versions</span>

        <span class="k">for</span> <span class="n">vname</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">vname</span> <span class="ow">in</span> <span class="n">package_cls</span><span class="o">.</span><span class="n">variant_names</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">vname</span> <span class="ow">in</span> <span class="n">new_spec</span><span class="o">.</span><span class="n">variants</span><span class="p">:</span>
                    <span class="n">new_spec</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_spec</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="n">vname</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> is not a variant of </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vname</span><span class="p">,</span> <span class="n">new_spec</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">compiler</span><span class="p">:</span>
            <span class="n">new_spec</span><span class="o">.</span><span class="n">compiler</span> <span class="o">=</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">compiler</span>
        <span class="k">if</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">compiler_flags</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">flagname</span><span class="p">,</span> <span class="n">flagvals</span> <span class="ow">in</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">compiler_flags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_spec</span><span class="o">.</span><span class="n">compiler_flags</span><span class="p">[</span><span class="n">flagname</span><span class="p">]</span> <span class="o">=</span> <span class="n">flagvals</span>
        <span class="k">if</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">architecture</span><span class="p">:</span>
            <span class="n">new_spec</span><span class="o">.</span><span class="n">architecture</span> <span class="o">=</span> <span class="n">ArchSpec</span><span class="o">.</span><span class="n">override</span><span class="p">(</span>
                <span class="n">new_spec</span><span class="o">.</span><span class="n">architecture</span><span class="p">,</span> <span class="n">change_spec</span><span class="o">.</span><span class="n">architecture</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">new_spec</span></div>


<div class="viewcode-block" id="Spec.from_literal">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.from_literal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_literal</span><span class="p">(</span><span class="n">spec_dict</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Builds a Spec from a dictionary containing the spec literal.</span>

<span class="sd">        The dictionary must have a single top level key, representing the root,</span>
<span class="sd">        and as many secondary level keys as needed in the spec.</span>

<span class="sd">        The keys can be either a string or a Spec or a tuple containing the</span>
<span class="sd">        Spec and the dependency types.</span>

<span class="sd">        Args:</span>
<span class="sd">            spec_dict (dict): the dictionary containing the spec literal</span>
<span class="sd">            normal (bool): if True the same key appearing at different levels</span>
<span class="sd">                of the ``spec_dict`` will map to the same object in memory.</span>

<span class="sd">        Examples:</span>
<span class="sd">            A simple spec ``foo`` with no dependencies:</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                {&#39;foo&#39;: None}</span>

<span class="sd">            A spec ``foo`` with a ``(build, link)`` dependency ``bar``:</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                {&#39;foo&#39;:</span>
<span class="sd">                    {&#39;bar:build,link&#39;: None}}</span>

<span class="sd">            A spec with a diamond dependency and various build types:</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                {&#39;dt-diamond&#39;: {</span>
<span class="sd">                    &#39;dt-diamond-left:build,link&#39;: {</span>
<span class="sd">                        &#39;dt-diamond-bottom:build&#39;: None</span>
<span class="sd">                    },</span>
<span class="sd">                    &#39;dt-diamond-right:build,link&#39;: {</span>
<span class="sd">                        &#39;dt-diamond-bottom:build,link,run&#39;: None</span>
<span class="sd">                    }</span>
<span class="sd">                }}</span>

<span class="sd">            The same spec with a double copy of ``dt-diamond-bottom`` and</span>
<span class="sd">            no diamond structure:</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                {&#39;dt-diamond&#39;: {</span>
<span class="sd">                    &#39;dt-diamond-left:build,link&#39;: {</span>
<span class="sd">                        &#39;dt-diamond-bottom:build&#39;: None</span>
<span class="sd">                    },</span>
<span class="sd">                    &#39;dt-diamond-right:build,link&#39;: {</span>
<span class="sd">                        &#39;dt-diamond-bottom:build,link,run&#39;: None</span>
<span class="sd">                    }</span>
<span class="sd">                }, normal=False}</span>

<span class="sd">            Constructing a spec using a Spec object as key:</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                mpich = Spec(&#39;mpich&#39;)</span>
<span class="sd">                libelf = Spec(&#39;libelf@1.8.11&#39;)</span>
<span class="sd">                expected_normalized = Spec.from_literal({</span>
<span class="sd">                    &#39;mpileaks&#39;: {</span>
<span class="sd">                        &#39;callpath&#39;: {</span>
<span class="sd">                            &#39;dyninst&#39;: {</span>
<span class="sd">                                &#39;libdwarf&#39;: {libelf: None},</span>
<span class="sd">                                libelf: None</span>
<span class="sd">                            },</span>
<span class="sd">                            mpich: None</span>
<span class="sd">                        },</span>
<span class="sd">                        mpich: None</span>
<span class="sd">                    },</span>
<span class="sd">                })</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Maps a literal to a Spec, to be sure we are reusing the same object</span>
        <span class="n">spec_cache</span> <span class="o">=</span> <span class="n">LazySpecCache</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">spec_builder</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="c1"># The invariant is that the top level dictionary must have</span>
            <span class="c1"># only one key</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="c1"># Construct the top-level spec</span>
            <span class="n">spec_like</span><span class="p">,</span> <span class="n">dep_like</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

            <span class="c1"># If the requirements was for unique nodes (default)</span>
            <span class="c1"># then reuse keys from the local cache. Otherwise build</span>
            <span class="c1"># a new node every time.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec_like</span><span class="p">,</span> <span class="n">Spec</span><span class="p">):</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="n">spec_cache</span><span class="p">[</span><span class="n">spec_like</span><span class="p">]</span> <span class="k">if</span> <span class="n">normal</span> <span class="k">else</span> <span class="n">Spec</span><span class="p">(</span><span class="n">spec_like</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="n">spec_like</span>

            <span class="k">if</span> <span class="n">dep_like</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">spec</span>

            <span class="k">def</span> <span class="nf">name_and_dependency_types</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">]:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Given a key in the dictionary containing the literal,</span>
<span class="sd">                extracts the name of the spec and its dependency types.</span>

<span class="sd">                Args:</span>
<span class="sd">                    s: key in the dictionary containing the literal</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;more than one &quot;:&quot; separator in key &quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

                <span class="n">name</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">depflag</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">flag_from_strings</span><span class="p">(</span><span class="n">dep_str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">dep_str</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">depflag</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">depflag</span>

            <span class="k">def</span> <span class="nf">spec_and_dependency_types</span><span class="p">(</span>
                <span class="n">s</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Spec</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Spec</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Spec</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">]:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Given a non-string key in the literal, extracts the spec</span>
<span class="sd">                and its dependency types.</span>

<span class="sd">                Args:</span>
<span class="sd">                    s: either a Spec object, or a tuple of Spec and string of dependency types</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Spec</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span>

                <span class="n">spec_obj</span><span class="p">,</span> <span class="n">dtypes</span> <span class="o">=</span> <span class="n">s</span>
                <span class="k">return</span> <span class="n">spec_obj</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">flag_from_strings</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">))</span>

            <span class="c1"># Recurse on dependencies</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">s_dependencies</span> <span class="ow">in</span> <span class="n">dep_like</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">dag_node</span><span class="p">,</span> <span class="n">dep_flag</span> <span class="o">=</span> <span class="n">name_and_dependency_types</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dag_node</span><span class="p">,</span> <span class="n">dep_flag</span> <span class="o">=</span> <span class="n">spec_and_dependency_types</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

                <span class="n">dependency_spec</span> <span class="o">=</span> <span class="n">spec_builder</span><span class="p">({</span><span class="n">dag_node</span><span class="p">:</span> <span class="n">s_dependencies</span><span class="p">})</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">_add_dependency</span><span class="p">(</span><span class="n">dependency_spec</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="n">dep_flag</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="p">())</span>

            <span class="k">return</span> <span class="n">spec</span>

        <span class="k">return</span> <span class="n">spec_builder</span><span class="p">(</span><span class="n">spec_dict</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.from_dict">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.from_dict">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a spec from JSON/YAML.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: a nested dict/list data structure read from YAML or JSON.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Legacy specfile format</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;spec&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">SpecfileV1</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;spec&quot;</span><span class="p">][</span><span class="s2">&quot;_meta&quot;</span><span class="p">][</span><span class="s2">&quot;version&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">SpecfileV2</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;spec&quot;</span><span class="p">][</span><span class="s2">&quot;_meta&quot;</span><span class="p">][</span><span class="s2">&quot;version&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">SpecfileV3</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">SpecfileV4</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Any git version should</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="n">s</span><span class="o">.</span><span class="n">attach_git_version_lookup</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">spec</span></div>


<div class="viewcode-block" id="Spec.from_yaml">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.from_yaml">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_yaml</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a spec from YAML.</span>

<span class="sd">        Args:</span>
<span class="sd">            stream: string or file object to read from.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">syaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Spec</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.from_json">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.from_json">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a spec from JSON.</span>

<span class="sd">        Args:</span>
<span class="sd">            stream: string or file object to read from.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">sjson</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Spec</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sjson</span><span class="o">.</span><span class="n">SpackJSONError</span><span class="p">(</span><span class="s2">&quot;error parsing JSON spec:&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">e</span></div>


<div class="viewcode-block" id="Spec.extract_json_from_clearsig">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.extract_json_from_clearsig">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">extract_json_from_clearsig</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">CLEARSIGN_FILE_REGEX</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sjson</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">sjson</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.from_signed_json">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.from_signed_json">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_signed_json</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a spec from clearsigned json spec file.</span>

<span class="sd">        Args:</span>
<span class="sd">            stream: string or file object to read from.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s2">&quot;read&quot;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="n">extracted_json</span> <span class="o">=</span> <span class="n">Spec</span><span class="o">.</span><span class="n">extract_json_from_clearsig</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Spec</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">extracted_json</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.from_detection">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.from_detection">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_detection</span><span class="p">(</span>
        <span class="n">spec_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">external_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">external_modules</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_attributes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Spec&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a spec from a spec string determined during external</span>
<span class="sd">        detection and attach extra attributes to it.</span>

<span class="sd">        Args:</span>
<span class="sd">            spec_str: spec string</span>
<span class="sd">            external_path: prefix of the external spec</span>
<span class="sd">            external_modules: optional module files to be loaded when the external spec is used</span>
<span class="sd">            extra_attributes: dictionary containing extra attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Spec</span><span class="p">(</span><span class="n">spec_str</span><span class="p">,</span> <span class="n">external_path</span><span class="o">=</span><span class="n">external_path</span><span class="p">,</span> <span class="n">external_modules</span><span class="o">=</span><span class="n">external_modules</span><span class="p">)</span>
        <span class="n">extra_attributes</span> <span class="o">=</span> <span class="n">syaml</span><span class="o">.</span><span class="n">sorted_dict</span><span class="p">(</span><span class="n">extra_attributes</span> <span class="ow">or</span> <span class="p">{})</span>
        <span class="c1"># This is needed to be able to validate multi-valued variants,</span>
        <span class="c1"># otherwise they&#39;ll still be abstract in the context of detection.</span>
        <span class="n">substitute_abstract_variants</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">extra_attributes</span> <span class="o">=</span> <span class="n">extra_attributes</span>
        <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="Spec.validate_detection">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.validate_detection">[docs]</a>
    <span class="k">def</span> <span class="nf">validate_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate the detection of an external spec.</span>

<span class="sd">        This method is used as part of Spack&#39;s detection protocol, and is</span>
<span class="sd">        not meant for client code use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assert that _extra_attributes is a Mapping and not None,</span>
        <span class="c1"># which likely means the spec was created with Spec.from_detection</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;cannot validate &quot;</span><span class="si">{0}</span><span class="s1">&quot; since it was not created &#39;</span> <span class="s2">&quot;using Spec.from_detection&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extra_attributes</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">),</span> <span class="n">msg</span>

        <span class="c1"># Validate the spec calling a package specific method</span>
        <span class="n">pkg_cls</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">get_pkg_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">validate_fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pkg_cls</span><span class="p">,</span> <span class="s2">&quot;validate_detected_spec&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">validate_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_attributes</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_patches_assigned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether patches have been assigned to this spec by the concretizer.&quot;&quot;&quot;</span>
        <span class="c1"># FIXME: _patches_in_order_of_appearance is attached after concretization</span>
        <span class="c1"># FIXME: to store the order of patches.</span>
        <span class="c1"># FIXME: Probably needs to be refactored in a cleaner way.</span>
        <span class="k">if</span> <span class="s2">&quot;patches&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># ensure that patch state is consistent</span>
        <span class="n">patch_variant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="s2">&quot;patches&quot;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
            <span class="n">patch_variant</span><span class="p">,</span> <span class="s2">&quot;_patches_in_order_of_appearance&quot;</span>
        <span class="p">),</span> <span class="s2">&quot;patches should always be assigned with a patch variant.&quot;</span>

        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Spec.inject_patches_variant">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.inject_patches_variant">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">inject_patches_variant</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
        <span class="c1"># This dictionary will store object IDs rather than Specs as keys</span>
        <span class="c1"># since the Spec __hash__ will change as patches are added to them</span>
        <span class="n">spec_to_patches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="c1"># After concretizing, assign namespaces to anything left.</span>
            <span class="c1"># Note that this doesn&#39;t count as a &quot;change&quot;.  The repository</span>
            <span class="c1"># configuration is constant throughout a spack run, and</span>
            <span class="c1"># normalize and concretize evaluate Packages using Repo.get(),</span>
            <span class="c1"># which respects precedence.  So, a namespace assignment isn&#39;t</span>
            <span class="c1"># changing how a package name would have been interpreted and</span>
            <span class="c1"># we can do it as late as possible to allow as much</span>
            <span class="c1"># compatibility across repositories as possible.</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">repo_for_pkg</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">namespace</span>

            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Add any patches from the package to the spec.</span>
            <span class="n">patches</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">cond</span><span class="p">,</span> <span class="n">patch_list</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">package_class</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">patch</span> <span class="ow">in</span> <span class="n">patch_list</span><span class="p">:</span>
                        <span class="n">patches</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">patches</span><span class="p">:</span>
                <span class="n">spec_to_patches</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span> <span class="o">=</span> <span class="n">patches</span>

        <span class="c1"># Also record all patches required on dependencies by</span>
        <span class="c1"># depends_on(..., patch=...)</span>
        <span class="k">for</span> <span class="n">dspec</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">traverse_edges</span><span class="p">(</span><span class="n">deptype</span><span class="o">=</span><span class="nb">all</span><span class="p">,</span> <span class="n">cover</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dspec</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">pkg_deps</span> <span class="o">=</span> <span class="n">dspec</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">package_class</span><span class="o">.</span><span class="n">dependencies</span>

            <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cond</span><span class="p">,</span> <span class="n">deps_by_name</span> <span class="ow">in</span> <span class="n">pkg_deps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">dspec</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">dependency</span> <span class="o">=</span> <span class="n">deps_by_name</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dspec</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">dependency</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">pcond</span><span class="p">,</span> <span class="n">patch_list</span> <span class="ow">in</span> <span class="n">dependency</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">dspec</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">pcond</span><span class="p">):</span>
                        <span class="n">patches</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">patch_list</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">patches</span><span class="p">:</span>
                <span class="n">all_patches</span> <span class="o">=</span> <span class="n">spec_to_patches</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">dspec</span><span class="o">.</span><span class="n">spec</span><span class="p">),</span> <span class="nb">set</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">patch</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">:</span>
                    <span class="n">all_patches</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spec_to_patches</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">patches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lang</span><span class="o">.</span><span class="n">dedupe</span><span class="p">(</span><span class="n">spec_to_patches</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">spec</span><span class="p">)]))</span>
            <span class="n">mvar</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;patches&quot;</span><span class="p">,</span> <span class="n">vt</span><span class="o">.</span><span class="n">MultiValuedVariant</span><span class="p">(</span><span class="s2">&quot;patches&quot;</span><span class="p">,</span> <span class="p">()))</span>
            <span class="n">mvar</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">sha256</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">)</span>
            <span class="c1"># FIXME: Monkey patches mvar to store patches order</span>
            <span class="n">full_order_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ordering_key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">sha256</span><span class="p">,)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">)</span>
            <span class="n">ordered_hashes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">full_order_keys</span><span class="p">)</span>
            <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Ordered hashes [</span><span class="si">{0}</span><span class="s2">]: &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ordered_hashes</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">mvar</span><span class="o">.</span><span class="n">_patches_in_order_of_appearance</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ordered_hashes</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.ensure_external_path_if_external">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.ensure_external_path_if_external">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">ensure_external_path_if_external</span><span class="p">(</span><span class="n">external_spec</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">external_spec</span><span class="o">.</span><span class="n">external_modules</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">external_spec</span><span class="o">.</span><span class="n">external_path</span><span class="p">:</span>
            <span class="n">compiler</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">compilers</span><span class="o">.</span><span class="n">compiler_for_spec</span><span class="p">(</span>
                <span class="n">external_spec</span><span class="o">.</span><span class="n">compiler</span><span class="p">,</span> <span class="n">external_spec</span><span class="o">.</span><span class="n">architecture</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">mod</span> <span class="ow">in</span> <span class="n">compiler</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
                <span class="n">md</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>

            <span class="c1"># Get the path from the module the package can override the default</span>
            <span class="c1"># (this is mostly needed for Cray)</span>
            <span class="n">pkg_cls</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">get_pkg_class</span><span class="p">(</span><span class="n">external_spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">package</span> <span class="o">=</span> <span class="n">pkg_cls</span><span class="p">(</span><span class="n">external_spec</span><span class="p">)</span>
            <span class="n">external_spec</span><span class="o">.</span><span class="n">external_path</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
                <span class="n">package</span><span class="p">,</span> <span class="s2">&quot;external_prefix&quot;</span><span class="p">,</span> <span class="n">md</span><span class="o">.</span><span class="n">path_from_modules</span><span class="p">(</span><span class="n">external_spec</span><span class="o">.</span><span class="n">external_modules</span><span class="p">)</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Spec.ensure_no_deprecated">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.ensure_no_deprecated">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">ensure_no_deprecated</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise if a deprecated spec is in the dag.</span>

<span class="sd">        Args:</span>
<span class="sd">            root (Spec): root spec to be analyzed</span>

<span class="sd">        Raises:</span>
<span class="sd">            SpecDeprecatedError: if any deprecated spec is found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">spack</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">STORE</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">read_transaction</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">rec</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">STORE</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">query_by_spec_hash</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">rec</span> <span class="ow">and</span> <span class="n">rec</span><span class="o">.</span><span class="n">deprecated_for</span><span class="p">:</span>
                    <span class="n">deprecated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deprecated</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    The following specs have been deprecated&quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; in favor of specs with the hashes shown:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">deprecated</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;        </span><span class="si">%s</span><span class="s2">  --&gt; </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">spec</span><span class="p">,</span> <span class="n">rec</span><span class="o">.</span><span class="n">deprecated_for</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;    For each package listed, choose another spec</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="n">SpecDeprecatedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.concretize">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.concretize">[docs]</a>
    <span class="k">def</span> <span class="nf">concretize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tests</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Concretize the current spec.</span>

<span class="sd">        Args:</span>
<span class="sd">            tests: if False disregard &#39;test&#39; dependencies, if a list of names activate them for</span>
<span class="sd">                the packages in the list, if True activate &#39;test&#39; dependencies for all packages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">spack.solver.asp</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">replace_hash</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Spec </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2"> has no name; cannot concretize an anonymous spec&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concrete</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">allow_deprecated</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;config:deprecated&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">asp</span><span class="o">.</span><span class="n">Solver</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="n">tests</span><span class="o">=</span><span class="n">tests</span><span class="p">,</span> <span class="n">allow_deprecated</span><span class="o">=</span><span class="n">allow_deprecated</span><span class="p">)</span>

        <span class="c1"># take the best answer</span>
        <span class="n">opt</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">answer</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">answers</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="c1"># TODO: Consolidate this code with similar code in solve.py</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual</span><span class="p">:</span>
            <span class="n">providers</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">answer</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="n">provides</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">providers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">node</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">asp</span><span class="o">.</span><span class="n">SpecBuilder</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">pkg</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">node</span> <span class="ow">in</span> <span class="n">answer</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;cannot find </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> in the list of specs </span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">pkg</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">answer</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">concretized</span> <span class="o">=</span> <span class="n">answer</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dup</span><span class="p">(</span><span class="n">concretized</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_mark_root_concrete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mark just this spec (not dependencies) concrete.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">installed</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_concrete</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_version</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_validate_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Specs that were concretized with just a git sha as version, without associated</span>
        <span class="c1"># Spack version, get their Spack version mapped to develop. This should only apply</span>
        <span class="c1"># when reading specs concretized with Spack 0.19 or earlier. Currently Spack always</span>
        <span class="c1"># ensures that GitVersion specs have an associated Spack version.</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">concrete</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">vn</span><span class="o">.</span><span class="n">GitVersion</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">v</span><span class="o">.</span><span class="n">ref_version</span>
        <span class="k">except</span> <span class="n">vn</span><span class="o">.</span><span class="n">VersionLookupError</span><span class="p">:</span>
            <span class="n">before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cformat</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{name}</span><span class="s2">{@version}{/hash:7}&quot;</span><span class="p">)</span>
            <span class="n">v</span><span class="o">.</span><span class="n">_ref_version</span> <span class="o">=</span> <span class="n">vn</span><span class="o">.</span><span class="n">StandardVersion</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s2">&quot;develop&quot;</span><span class="p">)</span>
            <span class="n">tty</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;the git sha of </span><span class="si">{</span><span class="n">before</span><span class="si">}</span><span class="s2"> could not be resolved to spack version; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;it has been replaced by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cformat</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">{@version}{/hash:7}&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_mark_concrete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mark this spec and its dependencies as concrete.</span>

<span class="sd">        Only for internal use -- client code should use &quot;concretize&quot;</span>
<span class="sd">        unless there is a need to force a spec to be concrete.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if set to false, clear out all hashes (set to None or remove attr)</span>
        <span class="c1"># may need to change references to respect None</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">concrete</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">installed</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">clear_caches</span><span class="p">()</span>
            <span class="n">s</span><span class="o">.</span><span class="n">_mark_root_concrete</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_finalize_concretization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign hashes to this spec, and mark it concrete.</span>

<span class="sd">        There are special semantics to consider for `package_hash`, because we can&#39;t</span>
<span class="sd">        call it on *already* concrete specs, but we need to assign it *at concretization</span>
<span class="sd">        time* to just-concretized specs. So, the concretizer must assign the package</span>
<span class="sd">        hash *before* marking their specs concrete (so that we know which specs were</span>
<span class="sd">        already concrete before this latest concretization).</span>

<span class="sd">        `dag_hash` is also tricky, since it cannot compute `package_hash()` lazily.</span>
<span class="sd">        Because `package_hash` needs to be assigned *at concretization time*,</span>
<span class="sd">        `to_node_dict()` can&#39;t just assume that it can compute `package_hash` itself</span>
<span class="sd">        -- it needs to either see or not see a `_package_hash` attribute.</span>

<span class="sd">        Rules of thumb for `package_hash`:</span>
<span class="sd">          1. Old-style concrete specs from *before* `dag_hash` included `package_hash`</span>
<span class="sd">             will not have a `_package_hash` attribute at all.</span>
<span class="sd">          2. New-style concrete specs will have a `_package_hash` assigned at</span>
<span class="sd">             concretization time.</span>
<span class="sd">          3. Abstract specs will not have a `_package_hash` attribute at all.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="c1"># Already concrete specs either already have a package hash (new dag_hash())</span>
            <span class="c1"># or they never will b/c we can&#39;t know it (old dag_hash()). Skip them.</span>
            <span class="c1">#</span>
            <span class="c1"># We only assign package hash to not-yet-concrete specs, for which we know</span>
            <span class="c1"># we can compute the hash.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">spec</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
                <span class="c1"># we need force=True here because package hash assignment has to happen</span>
                <span class="c1"># before we mark concrete, so that we know what was *already* concrete.</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">_cached_hash</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">package_hash</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># keep this check here to ensure package hash is saved</span>
                <span class="k">assert</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">ht</span><span class="o">.</span><span class="n">package_hash</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>

        <span class="c1"># Mark everything in the spec as concrete</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mark_concrete</span><span class="p">()</span>

        <span class="c1"># Assign dag_hash (this *could* be done lazily, but it&#39;s assigned anyway in</span>
        <span class="c1"># ensure_no_deprecated, and it&#39;s clearer to see explicitly where it happens).</span>
        <span class="c1"># Any specs that were concrete before finalization will already have a cached</span>
        <span class="c1"># DAG hash.</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">_cached_hash</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">)</span>

<div class="viewcode-block" id="Spec.concretized">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.concretized">[docs]</a>
    <span class="k">def</span> <span class="nf">concretized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tests</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Spec&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This is a non-destructive version of concretize().</span>

<span class="sd">        First clones, then returns a concrete version of this package</span>
<span class="sd">        without modifying this package.</span>

<span class="sd">        Args:</span>
<span class="sd">            tests (bool or list): if False disregard &#39;test&#39; dependencies,</span>
<span class="sd">                if a list of names activate them for the packages in the list,</span>
<span class="sd">                if True activate &#39;test&#39; dependencies for all packages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">concretize</span><span class="p">(</span><span class="n">tests</span><span class="o">=</span><span class="n">tests</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clone</span></div>


<div class="viewcode-block" id="Spec.index">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.index">[docs]</a>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deptype</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dictionary that points to all the dependencies in this</span>
<span class="sd">        spec.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">deptype</span><span class="o">=</span><span class="n">deptype</span><span class="p">):</span>
            <span class="n">dm</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dm</span></div>


<div class="viewcode-block" id="Spec.validate_or_raise">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.validate_or_raise">[docs]</a>
    <span class="k">def</span> <span class="nf">validate_or_raise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks that names and values in this spec are real. If they&#39;re not,</span>
<span class="sd">        it will raise an appropriate exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: this function should be lazy, and collect all the errors</span>
        <span class="c1"># FIXME: before raising the exceptions, instead of being greedy and</span>
        <span class="c1"># FIXME: raise just the first one encountered</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="c1"># raise an UnknownPackageError if the spec&#39;s package isn&#39;t real.</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">spec</span><span class="o">.</span><span class="n">virtual</span><span class="p">)</span> <span class="ow">and</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">get_pkg_class</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span>

            <span class="c1"># validate compiler in addition to the package name.</span>
            <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">compiler</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">spack</span><span class="o">.</span><span class="n">compilers</span><span class="o">.</span><span class="n">supported</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">compiler</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">UnsupportedCompilerError</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">compiler</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="c1"># Ensure correctness of variants (if the spec is not virtual)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">spec</span><span class="o">.</span><span class="n">virtual</span><span class="p">:</span>
                <span class="n">Spec</span><span class="o">.</span><span class="n">ensure_valid_variants</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                <span class="n">substitute_abstract_variants</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec.ensure_valid_variants">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.ensure_valid_variants">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">ensure_valid_variants</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ensures that the variant attached to a spec are valid.</span>

<span class="sd">        Args:</span>
<span class="sd">            spec (Spec): spec to be analyzed</span>

<span class="sd">        Raises:</span>
<span class="sd">            spack.variant.UnknownVariantError: on the first unknown variant found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># concrete variants are always valid</span>
        <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">pkg_cls</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">package_class</span>
        <span class="n">pkg_variants</span> <span class="o">=</span> <span class="n">pkg_cls</span><span class="o">.</span><span class="n">variant_names</span><span class="p">()</span>
        <span class="c1"># reserved names are variants that may be set on any package</span>
        <span class="c1"># but are not necessarily recorded by the package&#39;s class</span>
        <span class="n">propagate_variants</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">variant</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">variant</span><span class="o">.</span><span class="n">propagate</span><span class="p">]</span>

        <span class="n">not_existing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">variants</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">pkg_variants</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">vt</span><span class="o">.</span><span class="n">reserved_names</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">propagate_variants</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">not_existing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">vt</span><span class="o">.</span><span class="n">UnknownVariantError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No such variant </span><span class="si">{</span><span class="n">not_existing</span><span class="si">}</span><span class="s2"> for spec: &#39;</span><span class="si">{</span><span class="n">spec</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">not_existing</span><span class="p">)</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Spec.constrain">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.constrain">[docs]</a>
    <span class="k">def</span> <span class="nf">constrain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Intersect self with other in-place. Return True if self changed, False otherwise.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: constraint to be added to self</span>
<span class="sd">            deps: if False, constrain only the root node, otherwise constrain dependencies</span>
<span class="sd">                as well.</span>

<span class="sd">        Raises:</span>
<span class="sd">             spack.error.UnsatisfiableSpecError: when self cannot be constrained</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If we are trying to constrain a concrete spec, either the spec</span>
        <span class="c1"># already satisfies the constraint (and the method returns False)</span>
        <span class="c1"># or it raises an exception</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">UnsatisfiableSpecError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="s2">&quot;constrain a concrete spec&quot;</span><span class="p">)</span>

        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autospec</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">concrete</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dup</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">abstract_hash</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_hash</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">abstract_hash</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abstract_hash</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">abstract_hash</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">abstract_hash</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_hash</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">abstract_hash</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">InvalidHashError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">abstract_hash</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">UnsatisfiableSpecNameError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">namespace</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnsatisfiableSpecNameError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">overlaps</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">versions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnsatisfiableVersionSpecError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">versions</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">variants</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">compatible</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="n">v</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="n">vt</span><span class="o">.</span><span class="n">UnsatisfiableVariantSpecError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>

        <span class="n">sarch</span><span class="p">,</span> <span class="n">oarch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">architecture</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">sarch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">oarch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">architecture</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnsatisfiableArchitectureSpecError</span><span class="p">(</span><span class="n">sarch</span><span class="p">,</span> <span class="n">oarch</span><span class="p">)</span>

        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">namespace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">namespace</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">compiler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">changed</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span><span class="o">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">compiler</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">changed</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">compiler</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">compiler</span>

        <span class="n">changed</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">versions</span><span class="p">)</span>
        <span class="n">changed</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">variants</span><span class="p">)</span>

        <span class="n">changed</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span><span class="o">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">compiler_flags</span><span class="p">)</span>

        <span class="n">sarch</span><span class="p">,</span> <span class="n">oarch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">architecture</span>
        <span class="k">if</span> <span class="n">sarch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">oarch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">changed</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="o">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">architecture</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">oarch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span> <span class="o">=</span> <span class="n">oarch</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="n">changed</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constrain_dependencies</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">concrete</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_finalize_concretization</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">changed</span></div>


    <span class="k">def</span> <span class="nf">_constrain_dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply constraints of other spec&#39;s dependencies to this spec.&quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autospec</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># TODO: might want more detail than this, e.g. specific deps</span>
        <span class="c1"># in violation. if this becomes a priority get rid of this</span>
        <span class="c1"># check and be more specific about what&#39;s wrong.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_intersects_dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnsatisfiableDependencySpecError</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">UnconstrainableDependencySpecError</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># Handle common first-order constraints directly</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">common_dependencies</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">changed</span> <span class="o">|=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">deps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">:</span>
                <span class="c1"># WARNING: This function is an implementation detail of the</span>
                <span class="c1"># WARNING: original concretizer. Since with that greedy</span>
                <span class="c1"># WARNING: algorithm we don&#39;t allow multiple nodes from</span>
                <span class="c1"># WARNING: the same package in a DAG, here we hard-code</span>
                <span class="c1"># WARNING: using index 0 i.e. we assume that we have only</span>
                <span class="c1"># WARNING: one edge from package &quot;name&quot;</span>
                <span class="n">edges_from_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">changed</span> <span class="o">|=</span> <span class="n">edges_from_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">update_deptypes</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">depflag</span><span class="p">)</span>
                <span class="n">changed</span> <span class="o">|=</span> <span class="n">edges_from_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">update_virtuals</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">virtuals</span>
                <span class="p">)</span>

        <span class="c1"># Update with additional constraints from other spec</span>
        <span class="c1"># operate on direct dependencies only, because a concrete dep</span>
        <span class="c1"># represented by hash may have structure that needs to be preserved</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">direct_dep_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">dep_spec_copy</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_dependency</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_dependency</span><span class="p">(</span>
                <span class="n">dep_spec_copy</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">depflag</span><span class="o">=</span><span class="n">dep_spec_copy</span><span class="o">.</span><span class="n">depflag</span><span class="p">,</span>
                <span class="n">virtuals</span><span class="o">=</span><span class="n">dep_spec_copy</span><span class="o">.</span><span class="n">virtuals</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">changed</span>

<div class="viewcode-block" id="Spec.common_dependencies">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.common_dependencies">[docs]</a>
    <span class="k">def</span> <span class="nf">common_dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return names of dependencies that self an other have in common.&quot;&quot;&quot;</span>
        <span class="n">common</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="n">common</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">common</span></div>


<div class="viewcode-block" id="Spec.constrained">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.constrained">[docs]</a>
    <span class="k">def</span> <span class="nf">constrained</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a constrained copy without modifying this spec.&quot;&quot;&quot;</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">deps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clone</span></div>


<div class="viewcode-block" id="Spec.direct_dep_difference">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.direct_dep_difference">[docs]</a>
    <span class="k">def</span> <span class="nf">direct_dep_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns dependencies in self that are not in other.&quot;&quot;&quot;</span>
        <span class="n">mine</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dname</span> <span class="k">for</span> <span class="n">dname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">)</span>
        <span class="n">mine</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">dname</span> <span class="k">for</span> <span class="n">dname</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mine</span></div>


    <span class="k">def</span> <span class="nf">_autospec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec_like</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to convert arguments to specs.  If spec_like is a spec, returns</span>
<span class="sd">        it.  If it&#39;s a string, tries to parse a string.  If that fails, tries</span>
<span class="sd">        to parse a local spec from it (i.e. name is assumed to be self&#39;s name).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec_like</span><span class="p">,</span> <span class="n">Spec</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">spec_like</span>
        <span class="k">return</span> <span class="n">Spec</span><span class="p">(</span><span class="n">spec_like</span><span class="p">)</span>

<div class="viewcode-block" id="Spec.intersects">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.intersects">[docs]</a>
    <span class="k">def</span> <span class="nf">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;Spec&quot;</span><span class="p">],</span> <span class="n">deps</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if there exists at least one concrete spec that matches both</span>
<span class="sd">        self and other, otherwise False.</span>

<span class="sd">        This operation is commutative, and if two specs intersect it means that one</span>
<span class="sd">        can constrain the other.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: spec to be checked for compatibility</span>
<span class="sd">            deps: if True check compatibility of dependency nodes too, if False only check root</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autospec</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">concrete</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">()</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># From here we know both self and other are not concrete</span>
        <span class="n">self_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_hash</span>
        <span class="n">other_hash</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">abstract_hash</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">self_hash</span>
            <span class="ow">and</span> <span class="n">other_hash</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">self_hash</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">other_hash</span><span class="p">)</span> <span class="ow">or</span> <span class="n">other_hash</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">self_hash</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If the names are different, we need to consider virtuals</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">virtual</span><span class="p">:</span>
                <span class="c1"># Two virtual specs intersect only if there are providers for both</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">providers_for</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">providers_for</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
                <span class="n">intersection</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lhs</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">rhs</span><span class="p">)]</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>

            <span class="c1"># A provider can satisfy a virtual dependency.</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">virtual</span><span class="p">:</span>
                <span class="n">virtual_spec</span><span class="p">,</span> <span class="n">non_virtual_spec</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual</span> <span class="k">else</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Here we might get an abstract spec</span>
                    <span class="n">pkg_cls</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">get_pkg_class</span><span class="p">(</span><span class="n">non_virtual_spec</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span>
                    <span class="n">pkg</span> <span class="o">=</span> <span class="n">pkg_cls</span><span class="p">(</span><span class="n">non_virtual_spec</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">UnknownEntityError</span><span class="p">:</span>
                    <span class="c1"># If we can&#39;t get package info on this spec, don&#39;t treat</span>
                    <span class="c1"># it as a provider of this vdep.</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">pkg</span><span class="o">.</span><span class="n">provides</span><span class="p">(</span><span class="n">virtual_spec</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">when_spec</span><span class="p">,</span> <span class="n">provided</span> <span class="ow">in</span> <span class="n">pkg</span><span class="o">.</span><span class="n">provided</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">non_virtual_spec</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">when_spec</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">vpkg</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">virtual_spec</span><span class="p">)</span> <span class="k">for</span> <span class="n">vpkg</span> <span class="ow">in</span> <span class="n">provided</span><span class="p">):</span>
                                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># namespaces either match, or other doesn&#39;t require one.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">namespace</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">versions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">versions</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">compiler</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">compiler</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">variants</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">architecture</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">architecture</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">compiler_flags</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If we need to descend into dependencies, do it, otherwise we&#39;re done.</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersects_dependencies</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span></div>


    <span class="k">def</span> <span class="nf">_intersects_dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_dependencies</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">:</span>
            <span class="c1"># one spec *could* eventually satisfy the other</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Handle first-order constraints directly</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">common_dependencies</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">deps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># For virtual dependencies, we need to dig a little deeper.</span>
        <span class="n">self_index</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">provider_index</span><span class="o">.</span><span class="n">ProviderIndex</span><span class="p">(</span>
            <span class="n">repository</span><span class="o">=</span><span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="p">,</span> <span class="n">specs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(),</span> <span class="n">restrict</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">other_index</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">provider_index</span><span class="o">.</span><span class="n">ProviderIndex</span><span class="p">(</span>
            <span class="n">repository</span><span class="o">=</span><span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="p">,</span> <span class="n">specs</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">traverse</span><span class="p">(),</span> <span class="n">restrict</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># These two loops handle cases where there is an overly restrictive</span>
        <span class="c1"># vpkg in one spec for a provider in the other (e.g., mpi@3: is not</span>
        <span class="c1"># compatible with mpich2)</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_dependencies</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">other_index</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other_index</span><span class="o">.</span><span class="n">providers_for</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">virtual_dependencies</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">self_index</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">self_index</span><span class="o">.</span><span class="n">providers_for</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Spec.satisfies">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.satisfies">[docs]</a>
    <span class="k">def</span> <span class="nf">satisfies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;Spec&quot;</span><span class="p">],</span> <span class="n">deps</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if all concrete specs matching self also match other, otherwise False.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: spec to be satisfied</span>
<span class="sd">            deps: if True descend to dependencies, otherwise only check root node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autospec</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="c1"># The left-hand side must be the same singleton with identical hash. Notice that</span>
            <span class="c1"># package hashes can be different for otherwise indistinguishable concrete Spec</span>
            <span class="c1"># objects.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">()</span>

        <span class="c1"># If the right-hand side has an abstract hash, make sure it&#39;s a prefix of the</span>
        <span class="c1"># left-hand side&#39;s (abstract) hash.</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">abstract_hash</span><span class="p">:</span>
            <span class="n">compare_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_hash</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">compare_hash</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">compare_hash</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">abstract_hash</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If the names are different, we need to consider virtuals</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="c1"># A concrete provider can satisfy a virtual dependency.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">virtual</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Here we might get an abstract spec</span>
                    <span class="n">pkg_cls</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">get_pkg_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span>
                    <span class="n">pkg</span> <span class="o">=</span> <span class="n">pkg_cls</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">UnknownEntityError</span><span class="p">:</span>
                    <span class="c1"># If we can&#39;t get package info on this spec, don&#39;t treat</span>
                    <span class="c1"># it as a provider of this vdep.</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">pkg</span><span class="o">.</span><span class="n">provides</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">when_spec</span><span class="p">,</span> <span class="n">provided</span> <span class="ow">in</span> <span class="n">pkg</span><span class="o">.</span><span class="n">provided</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">when_spec</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">vpkg</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">for</span> <span class="n">vpkg</span> <span class="ow">in</span> <span class="n">provided</span><span class="p">):</span>
                                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># namespaces either match, or other doesn&#39;t require one.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">namespace</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">versions</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">compiler</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">compiler</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">compiler</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">variants</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">architecture</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">architecture</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">architecture</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">compiler_flags</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If we need to descend into dependencies, do it, otherwise we&#39;re done.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># If there are no constraints to satisfy, we&#39;re done.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># If we have no dependencies, we can&#39;t satisfy any constraints.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If we arrived here, the lhs root node satisfies the rhs root node. Now we need to check</span>
        <span class="c1"># all the edges that have an abstract parent, and verify that they match some edge in the</span>
        <span class="c1"># lhs.</span>
        <span class="c1">#</span>
        <span class="c1"># It might happen that the rhs brings in concrete sub-DAGs. For those we don&#39;t need to</span>
        <span class="c1"># verify the edge properties, cause everything is encoded in the hash of the nodes that</span>
        <span class="c1"># will be verified later.</span>
        <span class="n">lhs_edges</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="n">DependencySpec</span><span class="p">]]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rhs_edge</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">traverse_edges</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cover</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">):</span>
            <span class="c1"># If we are checking for ^mpi we need to verify if there is any edge</span>
            <span class="k">if</span> <span class="n">rhs_edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">virtual</span><span class="p">:</span>
                <span class="n">rhs_edge</span><span class="o">.</span><span class="n">update_virtuals</span><span class="p">(</span><span class="n">virtuals</span><span class="o">=</span><span class="p">(</span><span class="n">rhs_edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">rhs_edge</span><span class="o">.</span><span class="n">virtuals</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Skip edges from a concrete sub-DAG</span>
            <span class="k">if</span> <span class="n">rhs_edge</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">lhs_edges</span><span class="p">:</span>
                <span class="c1"># Construct a map of the link/run subDAG + direct &quot;build&quot; edges,</span>
                <span class="c1"># keyed by dependency name</span>
                <span class="k">for</span> <span class="n">lhs_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse_edges</span><span class="p">(</span>
                    <span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cover</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span> <span class="n">deptype</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;link&quot;</span><span class="p">,</span> <span class="s2">&quot;run&quot;</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">lhs_edges</span><span class="p">[</span><span class="n">lhs_edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lhs_edge</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">virtual_name</span> <span class="ow">in</span> <span class="n">lhs_edge</span><span class="o">.</span><span class="n">virtuals</span><span class="p">:</span>
                        <span class="n">lhs_edges</span><span class="p">[</span><span class="n">virtual_name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lhs_edge</span><span class="p">)</span>

                <span class="n">build_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_to_dependencies</span><span class="p">(</span><span class="n">depflag</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">lhs_edge</span> <span class="ow">in</span> <span class="n">build_edges</span><span class="p">:</span>
                    <span class="n">lhs_edges</span><span class="p">[</span><span class="n">lhs_edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lhs_edge</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">virtual_name</span> <span class="ow">in</span> <span class="n">lhs_edge</span><span class="o">.</span><span class="n">virtuals</span><span class="p">:</span>
                        <span class="n">lhs_edges</span><span class="p">[</span><span class="n">virtual_name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lhs_edge</span><span class="p">)</span>

            <span class="c1"># We don&#39;t have edges to this dependency</span>
            <span class="n">current_dependency_name</span> <span class="o">=</span> <span class="n">rhs_edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="n">current_dependency_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lhs_edges</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">for</span> <span class="n">virtual</span> <span class="ow">in</span> <span class="n">rhs_edge</span><span class="o">.</span><span class="n">virtuals</span><span class="p">:</span>
                <span class="n">has_virtual</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="n">virtual</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">virtuals</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">lhs_edges</span><span class="p">[</span><span class="n">current_dependency_name</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">has_virtual</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Edges have been checked above already, hence deps=False</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">any</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">lhs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Spec.virtual_dependencies">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.virtual_dependencies">[docs]</a>
    <span class="k">def</span> <span class="nf">virtual_dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return list of any virtual deps in this spec.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">spec</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">virtual</span><span class="p">]</span></div>


    <span class="nd">@property</span>  <span class="c1"># type: ignore[misc] # decorated prop not supported in mypy</span>
    <span class="k">def</span> <span class="nf">patches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return patch objects for any patch sha256 sums on this Spec.</span>

<span class="sd">        This is for use after concretization to iterate over any patches</span>
<span class="sd">        associated with this spec.</span>

<span class="sd">        TODO: this only checks in the package; it doesn&#39;t resurrect old</span>
<span class="sd">        patches from install directories, but it probably should.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_patches&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_patches</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># translate patch sha256sums to patch objects by consulting the index</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patches_assigned</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">sha256</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="s2">&quot;patches&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">_patches_in_order_of_appearance</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">patch_index</span>
                    <span class="n">pkg_cls</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">PATH</span><span class="o">.</span><span class="n">get_pkg_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">patch</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">patch_for_package</span><span class="p">(</span><span class="n">sha256</span><span class="p">,</span> <span class="n">pkg_cls</span><span class="p">)</span>
                    <span class="k">except</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">PatchLookupError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. This usually means the patch was modified or removed. &quot;</span>
                            <span class="s2">&quot;To fix this, either reconcretize or use the original package &quot;</span>
                            <span class="s2">&quot;repository&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patches</span>

    <span class="k">def</span> <span class="nf">_dup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">deps</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepTypes</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">cleardeps</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy the spec other into self.  This is an overwriting</span>
<span class="sd">        copy. It does not copy any dependents (parents), but by default</span>
<span class="sd">        copies dependencies.</span>

<span class="sd">        To duplicate an entire DAG, call _dup() on the root of the DAG.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (Spec): spec to be copied onto ``self``</span>
<span class="sd">            deps: if True copies all the dependencies. If</span>
<span class="sd">                False copies None. If deptype/depflag, copy matching types.</span>
<span class="sd">            cleardeps (bool): if True clears the dependencies of ``self``,</span>
<span class="sd">                before possibly copying the dependencies of ``other`` onto</span>
<span class="sd">                ``self``</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if ``self`` changed because of the copy operation,</span>
<span class="sd">            False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We don&#39;t count dependencies as changes here</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">versions</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">architecture</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">compiler</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">variants</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_normal</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">concrete</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_path</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">external_path</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_modules</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">external_modules</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">compiler_flags</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_hash</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">abstract_hash</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_package</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Local node attributes get copied first.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">versions</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">architecture</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">architecture</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">compiler</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">compiler</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">cleardeps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dependents</span> <span class="o">=</span> <span class="n">_EdgeMap</span><span class="p">(</span><span class="n">store_by_child</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span> <span class="o">=</span> <span class="n">_EdgeMap</span><span class="p">(</span><span class="n">store_by_child</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">compiler_flags</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span><span class="o">.</span><span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variants</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_spec</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_build_spec</span>

        <span class="c1"># FIXME: we manage _patches_in_order_of_appearance specially here</span>
        <span class="c1"># to keep it from leaking out of spec.py, but we should figure</span>
        <span class="c1"># out how to handle it more elegantly in the Variant classes.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">patches</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;_patches_in_order_of_appearance&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">patches</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">_patches_in_order_of_appearance</span> <span class="o">=</span> <span class="n">patches</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external_path</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">external_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external_modules</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">external_modules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_attributes</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">extra_attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">namespace</span>

        <span class="c1"># If we copy dependencies, preserve DAG structure in the new spec</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="c1"># If caller restricted deptypes to be copied, adjust that here.</span>
            <span class="c1"># By default, just copy all deptypes</span>
            <span class="n">depflag</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">ALL</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deps</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                <span class="n">depflag</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dup_deps</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">depflag</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_concrete</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_concrete</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">abstract_hash</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">abstract_hash</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concrete</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dunder_hash</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_dunder_hash</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_normal</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">hashes</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dunder_hash</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># Note, we could use other._normal if we are copying all deps, but</span>
            <span class="c1"># always set it False here to avoid the complexity of checking</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">hashes</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">changed</span>

    <span class="k">def</span> <span class="nf">_dup_deps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">depflag</span><span class="p">:</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">spid</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

        <span class="n">new_specs</span> <span class="o">=</span> <span class="p">{</span><span class="n">spid</span><span class="p">(</span><span class="n">other</span><span class="p">):</span> <span class="bp">self</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">traverse_edges</span><span class="p">(</span><span class="n">cover</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">depflag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">depflag</span> <span class="o">&amp;</span> <span class="n">edge</span><span class="o">.</span><span class="n">depflag</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">spid</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_specs</span><span class="p">:</span>
                <span class="n">new_specs</span><span class="p">[</span><span class="n">spid</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">)]</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">spid</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_specs</span><span class="p">:</span>
                <span class="n">new_specs</span><span class="p">[</span><span class="n">spid</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="p">)]</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">new_specs</span><span class="p">[</span><span class="n">spid</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">)]</span><span class="o">.</span><span class="n">add_dependency_edge</span><span class="p">(</span>
                <span class="n">new_specs</span><span class="p">[</span><span class="n">spid</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="p">)],</span> <span class="n">depflag</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">depflag</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">virtuals</span>
            <span class="p">)</span>

<div class="viewcode-block" id="Spec.copy">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deps</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepTypes</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">DepFlag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a copy of this spec.</span>

<span class="sd">        Args:</span>
<span class="sd">            deps: Defaults to True. If boolean, controls</span>
<span class="sd">                whether dependencies are copied (copied if True). If a</span>
<span class="sd">                DepTypes or DepFlag is provided, *only* matching dependencies are copied.</span>
<span class="sd">            kwargs: additional arguments for internal use (passed to ``_dup``).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of this spec.</span>

<span class="sd">        Examples:</span>
<span class="sd">            Deep copy with dependencies::</span>

<span class="sd">                spec.copy()</span>
<span class="sd">                spec.copy(deps=True)</span>

<span class="sd">            Shallow copy (no dependencies)::</span>

<span class="sd">                spec.copy(deps=False)</span>

<span class="sd">            Only build and run dependencies::</span>

<span class="sd">                deps=(&#39;build&#39;, &#39;run&#39;):</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="n">Spec</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Spec</span><span class="p">)</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">_dup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clone</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span><span class="s2">&quot;Spec version is not concrete: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a dependency from the spec by its name. This call implicitly</span>
<span class="sd">        sets a query state in the package being retrieved. The behavior of</span>
<span class="sd">        packages may be influenced by additional query parameters that are</span>
<span class="sd">        passed after a colon symbol.</span>

<span class="sd">        Note that if a virtual package is queried a copy of the Spec is</span>
<span class="sd">        returned while for non-virtual a reference is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query_parameters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_parameters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;key has more than one &#39;:&#39; symbol. At most one is admitted.&quot;</span><span class="p">)</span>

        <span class="n">name</span><span class="p">,</span> <span class="n">query_parameters</span> <span class="o">=</span> <span class="n">query_parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">query_parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">query_parameters</span><span class="p">:</span>
            <span class="c1"># We have extra query parameters, which are comma separated</span>
            <span class="c1"># values</span>
            <span class="n">csv</span> <span class="o">=</span> <span class="n">query_parameters</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">query_parameters</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*,\s*&quot;</span><span class="p">,</span> <span class="n">csv</span><span class="p">)</span>

        <span class="n">order</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse_edges</span><span class="p">(</span><span class="n">deptype</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">LINK</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;breadth&quot;</span><span class="p">,</span> <span class="n">cover</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges_to_dependencies</span><span class="p">(</span><span class="n">depflag</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span> <span class="o">|</span> <span class="n">dt</span><span class="o">.</span><span class="n">RUN</span> <span class="o">|</span> <span class="n">dt</span><span class="o">.</span><span class="n">TEST</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse_edges</span><span class="p">(</span><span class="n">deptype</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">ALL</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;breadth&quot;</span><span class="p">,</span> <span class="n">cover</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Consider runtime dependencies and direct build/test deps before transitive dependencies,</span>
        <span class="c1"># and prefer matches closest to the root.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">child</span><span class="p">:</span> <span class="n">Spec</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                <span class="n">e</span><span class="o">.</span><span class="n">spec</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">order</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">virtuals</span><span class="p">),</span>
                    <span class="c1"># for historical reasons</span>
                    <span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">order</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">concrete</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="n">provides</span><span class="p">(</span><span class="n">name</span><span class="p">)),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No spec with name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SpecBuildInterface</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">query_parameters</span><span class="p">,</span> <span class="n">_parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">child</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if this spec or some dependency satisfies the spec.</span>

<span class="sd">        Note: If ``spec`` is anonymous, we ONLY check whether the root</span>
<span class="sd">        satisfies it, NOT dependencies.  This is because most anonymous</span>
<span class="sd">        specs (e.g., ``@1.2``) don&#39;t make sense when applied across an</span>
<span class="sd">        entire DAG -- we limit them to the root.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autospec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

        <span class="c1"># if anonymous or same name, we only have to look at the root</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

<div class="viewcode-block" id="Spec.eq_dag">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.eq_dag">[docs]</a>
    <span class="k">def</span> <span class="nf">eq_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">deptypes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if the full dependency DAGs of specs are equal.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vo</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">vs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">vo</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_node</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">ssorted</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">)]</span>
        <span class="n">osorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">s_dspec</span><span class="p">,</span> <span class="n">o_dspec</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">ssorted</span><span class="p">),</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">osorted</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">deptypes</span> <span class="ow">and</span> <span class="n">s_dspec</span><span class="o">.</span><span class="n">depflag</span> <span class="o">!=</span> <span class="n">o_dspec</span><span class="o">.</span><span class="n">depflag</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">s</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="n">s_dspec</span><span class="o">.</span><span class="n">spec</span><span class="p">,</span> <span class="n">o_dspec</span><span class="o">.</span><span class="n">spec</span>
            <span class="n">visited_s</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="n">vs</span>
            <span class="n">visited_o</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="ow">in</span> <span class="n">vo</span>

            <span class="c1"># Check for duplicate or non-equal dependencies</span>
            <span class="k">if</span> <span class="n">visited_s</span> <span class="o">!=</span> <span class="n">visited_o</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># Skip visited nodes</span>
            <span class="k">if</span> <span class="n">visited_s</span> <span class="ow">or</span> <span class="n">visited_o</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Recursive check for equality</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">eq_dag</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">deptypes</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">vo</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>


    <span class="k">def</span> <span class="nf">_cmp_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Yield comparable elements of just *this node* and not its deps.&quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiler_flags</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_hash</span>

        <span class="c1"># this is not present on older specs</span>
        <span class="k">yield</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_package_hash&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="Spec.eq_node">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.eq_node">[docs]</a>
    <span class="k">def</span> <span class="nf">eq_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equality with another spec, not including dependencies.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lang</span><span class="o">.</span><span class="n">lazy_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cmp_node</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_cmp_node</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_cmp_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lazily yield components of self for comparison.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_node</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">item</span>

        <span class="c1"># This needs to be in _cmp_iter so that no specs with different process hashes</span>
        <span class="c1"># are considered the same by `__hash__` or `__eq__`.</span>
        <span class="c1">#</span>
        <span class="c1"># TODO: We should eventually unify the `_cmp_*` methods with `to_node_dict` so</span>
        <span class="c1"># TODO: there aren&#39;t two sources of truth, but this needs some thought, since</span>
        <span class="c1"># TODO: they exist for speed.  We should benchmark whether it&#39;s really worth</span>
        <span class="c1"># TODO: having two types of hashing now that we use `json` instead of `yaml` for</span>
        <span class="c1"># TODO: spec hashing.</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_hash</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">deps</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
                <span class="k">yield</span> <span class="n">dep</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span>
                <span class="k">yield</span> <span class="n">dep</span><span class="o">.</span><span class="n">depflag</span>
                <span class="k">yield</span> <span class="nb">hash</span><span class="p">(</span><span class="n">dep</span><span class="o">.</span><span class="n">spec</span><span class="p">)</span>

        <span class="k">yield</span> <span class="n">deps</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">namespace_if_anonymous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="kc">None</span>

<div class="viewcode-block" id="Spec.format">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.format">[docs]</a>
    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DEFAULT_FORMAT</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Prints out attributes of a spec according to a format string.</span>

<span class="sd">        Using an ``{attribute}`` format specifier, any field of the spec can be</span>
<span class="sd">        selected. Those attributes can be recursive. For example,</span>
<span class="sd">        ``s.format({compiler.version})`` will print the version of the compiler.</span>

<span class="sd">        If the attribute in a format specifier evaluates to ``None``, then the format</span>
<span class="sd">        specifier will evaluate to the empty string, ``&quot;&quot;``.</span>

<span class="sd">        Commonly used attributes of the Spec for format strings include::</span>

<span class="sd">            name</span>
<span class="sd">            version</span>
<span class="sd">            compiler</span>
<span class="sd">            compiler.name</span>
<span class="sd">            compiler.version</span>
<span class="sd">            compiler_flags</span>
<span class="sd">            variants</span>
<span class="sd">            architecture</span>
<span class="sd">            architecture.platform</span>
<span class="sd">            architecture.os</span>
<span class="sd">            architecture.target</span>
<span class="sd">            prefix</span>
<span class="sd">            namespace</span>

<span class="sd">        Some additional special-case properties can be added::</span>

<span class="sd">            hash[:len]    The DAG hash with optional length argument</span>
<span class="sd">            spack_root    The spack root directory</span>
<span class="sd">            spack_install The spack install directory</span>

<span class="sd">        The ``^`` sigil can be used to access dependencies by name.</span>
<span class="sd">        ``s.format({^mpi.name})`` will print the name of the MPI implementation in the</span>
<span class="sd">        spec.</span>

<span class="sd">        The ``@``, ``%``, and ``/`` sigils can be used to include the sigil with the</span>
<span class="sd">        printed string. These sigils may only be used with the appropriate attributes,</span>
<span class="sd">        listed below::</span>

<span class="sd">            @        ``{@version}``, ``{@compiler.version}``</span>
<span class="sd">            %        ``{%compiler}``, ``{%compiler.name}``</span>
<span class="sd">            /        ``{/hash}``, ``{/hash:7}``, etc</span>

<span class="sd">        The ``@`` sigil may also be used for any other property named ``version``.</span>
<span class="sd">        Sigils printed with the attribute string are only printed if the attribute</span>
<span class="sd">        string is non-empty, and are colored according to the color of the attribute.</span>

<span class="sd">        Variants listed by name naturally print with their sigil. For example,</span>
<span class="sd">        ``spec.format(&#39;{variants.debug}&#39;)`` prints either ``+debug`` or ``~debug``</span>
<span class="sd">        depending on the name of the variant. Non-boolean variants print as</span>
<span class="sd">        ``name=value``. To print variant names or values independently, use</span>
<span class="sd">        ``spec.format(&#39;{variants.&lt;name&gt;.name}&#39;)`` or</span>
<span class="sd">        ``spec.format(&#39;{variants.&lt;name&gt;.value}&#39;)``.</span>

<span class="sd">        There are a few attributes on specs that can be specified as key-value pairs</span>
<span class="sd">        that are *not* variants, e.g.: ``os``, ``arch``, ``architecture``, ``target``,</span>
<span class="sd">        ``namespace``, etc. You can format these with an optional ``key=`` prefix, e.g.</span>
<span class="sd">        ``{namespace=namespace}`` or ``{arch=architecture}``, etc. The ``key=`` prefix</span>
<span class="sd">        will be colorized along with the value.</span>

<span class="sd">        When formatting specs, key-value pairs are separated from preceding parts of the</span>
<span class="sd">        spec by whitespace. To avoid printing extra whitespace when the formatted</span>
<span class="sd">        attribute is not set, you can add whitespace to the key *inside* the braces of</span>
<span class="sd">        the format string, e.g.:</span>

<span class="sd">            { namespace=namespace}</span>

<span class="sd">        This evaluates to `` namespace=builtin`` if ``namespace`` is set to ``builtin``,</span>
<span class="sd">        and to ``&quot;&quot;`` if ``namespace`` is ``None``.</span>

<span class="sd">        Spec format strings use ``\`` as the escape character. Use ``\{`` and ``\}`` for</span>
<span class="sd">        literal braces, and ``\\`` for the literal ``\`` character.</span>

<span class="sd">        Args:</span>
<span class="sd">            format_string: string containing the format to be expanded</span>
<span class="sd">            color: True for colorized result; False for no color; None for auto color.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ensure_modern_format_string</span><span class="p">(</span><span class="n">format_string</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">safe_color</span><span class="p">(</span><span class="n">sigil</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">color_fmt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># avoid colorizing if there is no color or the string is empty</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">color</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">color_fmt</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">string</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sigil</span> <span class="o">+</span> <span class="n">string</span>
            <span class="c1"># escape and add the sigil here to avoid multiple concatenations</span>
            <span class="k">if</span> <span class="n">sigil</span> <span class="o">==</span> <span class="s2">&quot;@&quot;</span><span class="p">:</span>
                <span class="n">sigil</span> <span class="o">=</span> <span class="s2">&quot;@@&quot;</span>
            <span class="k">return</span> <span class="n">clr</span><span class="o">.</span><span class="n">colorize</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">color_fmt</span><span class="si">}{</span><span class="n">sigil</span><span class="si">}{</span><span class="n">clr</span><span class="o">.</span><span class="n">cescape</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="si">}</span><span class="s2">@.&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">format_attribute</span><span class="p">(</span><span class="n">match_object</span><span class="p">:</span> <span class="n">Match</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="p">(</span><span class="n">esc</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">dep</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="n">hash_len</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">close_brace</span><span class="p">,</span> <span class="n">unmatched_close_brace</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">match_object</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">esc</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">esc</span>
            <span class="k">elif</span> <span class="n">unmatched_close_brace</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SpecFormatStringError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unmatched close brace: &#39;</span><span class="si">{</span><span class="n">format_string</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">close_brace</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SpecFormatStringError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing close brace: &#39;</span><span class="si">{</span><span class="n">format_string</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

            <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">dep</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="p">[</span><span class="n">dep</span><span class="p">]</span>

            <span class="c1"># Hash attributes can return early.</span>
            <span class="c1"># NOTE: we currently treat abstract_hash like an attribute and ignore</span>
            <span class="c1"># any length associated with it. We may want to change that.</span>
            <span class="k">if</span> <span class="nb">hash</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sig</span> <span class="ow">and</span> <span class="n">sig</span> <span class="o">!=</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SpecFormatSigilError</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="s2">&quot;DAG hashes&quot;</span><span class="p">,</span> <span class="nb">hash</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hash_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">hash_len</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SpecFormatStringError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid hash length: &#39;</span><span class="si">{</span><span class="n">hash_len</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">safe_color</span><span class="p">(</span><span class="n">sig</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">HASH_COLOR</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">attribute</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SpecFormatStringError</span><span class="p">(</span><span class="s2">&quot;Format string attributes must be non-empty&quot;</span><span class="p">)</span>

            <span class="n">attribute</span> <span class="o">=</span> <span class="n">attribute</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">attribute</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">parts</span>

            <span class="c1"># check that the sigil is valid for the attribute.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sig</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">elif</span> <span class="n">sig</span> <span class="o">==</span> <span class="s2">&quot;@&quot;</span> <span class="ow">and</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;versions&quot;</span><span class="p">,</span> <span class="s2">&quot;version&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">SpecFormatSigilError</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="s2">&quot;versions&quot;</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">sig</span> <span class="o">==</span> <span class="s2">&quot;%&quot;</span> <span class="ow">and</span> <span class="n">attribute</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;compiler&quot;</span><span class="p">,</span> <span class="s2">&quot;compiler.name&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">SpecFormatSigilError</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="s2">&quot;compilers&quot;</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">sig</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span> <span class="ow">and</span> <span class="n">attribute</span> <span class="o">!=</span> <span class="s2">&quot;abstract_hash&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SpecFormatSigilError</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="s2">&quot;DAG hashes&quot;</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>

            <span class="c1"># Iterate over components using getattr to get next element</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parts</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">part</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SpecFormatStringError</span><span class="p">(</span><span class="s2">&quot;Format string attributes must be non-empty&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">part</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">SpecFormatStringError</span><span class="p">(</span><span class="s2">&quot;Attempted to format private attribute&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">VariantMap</span><span class="p">):</span>
                    <span class="c1"># subscript instead of getattr for variant names</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">[</span><span class="n">part</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">SpecFormatStringError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variant &#39;</span><span class="si">{</span><span class="n">part</span><span class="si">}</span><span class="s2">&#39; does not exist&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># aliases</span>
                    <span class="k">if</span> <span class="n">part</span> <span class="o">==</span> <span class="s2">&quot;arch&quot;</span><span class="p">:</span>
                        <span class="n">part</span> <span class="o">=</span> <span class="s2">&quot;architecture&quot;</span>
                    <span class="k">elif</span> <span class="n">part</span> <span class="o">==</span> <span class="s2">&quot;version&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">current</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
                        <span class="c1"># version (singular) requires a concrete versions list. Avoid</span>
                        <span class="c1"># pedantic errors by using versions (plural) when not concrete.</span>
                        <span class="c1"># These two are not entirely equivalent for pkg@=1.2.3:</span>
                        <span class="c1"># - version prints &#39;1.2.3&#39;</span>
                        <span class="c1"># - versions prints &#39;=1.2.3&#39;</span>
                        <span class="n">part</span> <span class="o">=</span> <span class="s2">&quot;versions&quot;</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">current</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">SpecFormatStringError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Attempted to format attribute </span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">. &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Spec </span><span class="si">{</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[:</span><span class="n">idx</span><span class="p">])</span><span class="si">}</span><span class="s2"> has no attribute </span><span class="si">{</span><span class="n">part</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">vn</span><span class="o">.</span><span class="n">VersionList</span><span class="p">)</span> <span class="ow">and</span> <span class="n">current</span> <span class="o">==</span> <span class="n">vn</span><span class="o">.</span><span class="n">any_version</span><span class="p">:</span>
                        <span class="c1"># don&#39;t print empty version lists</span>
                        <span class="k">return</span> <span class="s2">&quot;&quot;</span>

                <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">SpecFormatStringError</span><span class="p">(</span><span class="s2">&quot;Attempted to format callable object&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># not printing anything</span>
                    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

            <span class="c1"># Set color codes for various attributes</span>
            <span class="n">color</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s2">&quot;architecture&quot;</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">ARCHITECTURE_COLOR</span>
            <span class="k">elif</span> <span class="s2">&quot;variants&quot;</span> <span class="ow">in</span> <span class="n">parts</span> <span class="ow">or</span> <span class="n">sig</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">):</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">VARIANT_COLOR</span>
            <span class="k">elif</span> <span class="s2">&quot;compiler&quot;</span> <span class="ow">in</span> <span class="n">parts</span> <span class="ow">or</span> <span class="s2">&quot;compiler_flags&quot;</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">COMPILER_COLOR</span>
            <span class="k">elif</span> <span class="s2">&quot;version&quot;</span> <span class="ow">in</span> <span class="n">parts</span> <span class="ow">or</span> <span class="s2">&quot;versions&quot;</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">VERSION_COLOR</span>

            <span class="c1"># return empty string if the value of the attribute is None.</span>
            <span class="k">if</span> <span class="n">current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;&quot;</span>

            <span class="c1"># return colored output</span>
            <span class="k">return</span> <span class="n">safe_color</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">color</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SPEC_FORMAT_RE</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">format_attribute</span><span class="p">,</span> <span class="n">format_string</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span></div>


<div class="viewcode-block" id="Spec.cformat">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.cformat">[docs]</a>
    <span class="k">def</span> <span class="nf">cformat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Same as format, but color defaults to auto instead of False.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spack_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Special field for using ``{spack_root}`` in Spec.format().&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">spack</span><span class="o">.</span><span class="n">paths</span><span class="o">.</span><span class="n">spack_root</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spack_install</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Special field for using ``{spack_install}`` in Spec.format().&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">spack</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">STORE</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">root</span>

<div class="viewcode-block" id="Spec.format_path">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.format_path">[docs]</a>
    <span class="k">def</span> <span class="nf">format_path</span><span class="p">(</span>
        <span class="c1"># self, format_string: str, _path_ctor: Optional[pathlib.PurePath] = None</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">format_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">_path_ctor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">PurePath</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given a `format_string` that is intended as a path, generate a string</span>
<span class="sd">        like from `Spec.format`, but eliminate extra path separators introduced by</span>
<span class="sd">        formatting of Spec properties.</span>

<span class="sd">        Path separators explicitly added to the string are preserved, so for example</span>
<span class="sd">        &quot;{name}/{version}&quot; would generate a directory based on the Spec&#39;s name, and</span>
<span class="sd">        a subdirectory based on its version; this function guarantees though that</span>
<span class="sd">        the resulting string would only have two directories (i.e. that if under</span>
<span class="sd">        normal circumstances that `str(Spec.version)` would contain a path</span>
<span class="sd">        separator, it would not in this case).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">format_component_with_sep</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\{[^}]*[/</span><span class="se">\\</span><span class="s2">][^}]*}&quot;</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">format_component_with_sep</span><span class="p">,</span> <span class="n">format_string</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SpecFormatPathError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid path format string: cannot contain </span><span class="se">{{</span><span class="s2">/...</span><span class="se">}}\n\t</span><span class="si">{</span><span class="n">format_string</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">path_ctor</span> <span class="o">=</span> <span class="n">_path_ctor</span> <span class="ow">or</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">PurePath</span>
        <span class="n">format_string_as_path</span> <span class="o">=</span> <span class="n">path_ctor</span><span class="p">(</span><span class="n">format_string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">format_string_as_path</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="c1"># Paths that begin with a single &quot;\&quot; on windows are relative, but we still</span>
            <span class="c1"># want to preserve the initial &quot;\\&quot; to be consistent with PureWindowsPath.</span>
            <span class="c1"># Ensure that this &#39;\&#39; is not passed to polite_filename() so it&#39;s not converted to &#39;_&#39;</span>
            <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;nt&quot;</span> <span class="ow">or</span> <span class="n">path_ctor</span> <span class="o">==</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">PureWindowsPath</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">format_string_as_path</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span>
        <span class="p">):</span>
            <span class="n">output_path_components</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_string_as_path</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">input_path_components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">format_string_as_path</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_path_components</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">input_path_components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">format_string_as_path</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span>

        <span class="n">output_path_components</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">polite_filename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">part</span><span class="p">))</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">input_path_components</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">path_ctor</span><span class="p">(</span><span class="o">*</span><span class="n">output_path_components</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{name}</span><span class="s2">{@version}{/hash}&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>

        <span class="n">root_str</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">()]</span>
        <span class="n">sorted_dependencies</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">abstract_hash</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">sorted_dependencies</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">d</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{edge_attributes}</span><span class="s2"> &quot;</span> <span class="o">+</span> <span class="n">DEFAULT_FORMAT</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sorted_dependencies</span>
        <span class="p">]</span>
        <span class="n">spec_str</span> <span class="o">=</span> <span class="s2">&quot; ^&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_str</span> <span class="o">+</span> <span class="n">sorted_dependencies</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spec_str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">colored_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">root_str</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cformat</span><span class="p">()]</span>
        <span class="n">sorted_dependencies</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">abstract_hash</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">sorted_dependencies</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">d</span><span class="o">.</span><span class="n">cformat</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{edge_attributes}</span><span class="s2"> &quot;</span> <span class="o">+</span> <span class="n">DISPLAY_FORMAT</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sorted_dependencies</span>
        <span class="p">]</span>
        <span class="n">spec_str</span> <span class="o">=</span> <span class="s2">&quot; ^&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_str</span> <span class="o">+</span> <span class="n">sorted_dependencies</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spec_str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

<div class="viewcode-block" id="Spec.install_status">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.install_status">[docs]</a>
    <span class="k">def</span> <span class="nf">install_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InstallStatus</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper for tree to print DB install status.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">InstallStatus</span><span class="o">.</span><span class="n">absent</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">external</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">InstallStatus</span><span class="o">.</span><span class="n">external</span>

        <span class="n">upstream</span><span class="p">,</span> <span class="n">record</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">STORE</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">query_by_spec_hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">record</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">InstallStatus</span><span class="o">.</span><span class="n">absent</span>
        <span class="k">elif</span> <span class="n">upstream</span> <span class="ow">and</span> <span class="n">record</span><span class="o">.</span><span class="n">installed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">InstallStatus</span><span class="o">.</span><span class="n">upstream</span>
        <span class="k">elif</span> <span class="n">record</span><span class="o">.</span><span class="n">installed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">InstallStatus</span><span class="o">.</span><span class="n">installed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">InstallStatus</span><span class="o">.</span><span class="n">missing</span></div>


    <span class="k">def</span> <span class="nf">_installed_explicitly</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper for tree to print DB install status.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">record</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">STORE</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">get_record</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">record</span><span class="o">.</span><span class="n">explicit</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Spec.tree">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.tree">[docs]</a>
    <span class="k">def</span> <span class="nf">tree</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">depth</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">hashes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">hashlen</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cover</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nodes&quot;</span><span class="p">,</span>
        <span class="n">indent</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DEFAULT_FORMAT</span><span class="p">,</span>
        <span class="n">deptypes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">show_types</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">depth_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">recurse_dependencies</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">status_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;Spec&quot;</span><span class="p">],</span> <span class="n">InstallStatus</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;Spec&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">key</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prints out this spec and its dependencies, tree-formatted with indentation.</span>

<span class="sd">        See multi-spec ``spack.spec.tree()`` function for details.</span>

<span class="sd">        Args:</span>
<span class="sd">            specs: List of specs to format.</span>
<span class="sd">            color: if True, always colorize the tree. If False, don&#39;t colorize the tree. If None,</span>
<span class="sd">                use the default from llnl.tty.color</span>
<span class="sd">            depth: print the depth from the root</span>
<span class="sd">            hashes: if True, print the hash of each node</span>
<span class="sd">            hashlen: length of the hash to be printed</span>
<span class="sd">            cover: either &quot;nodes&quot; or &quot;edges&quot;</span>
<span class="sd">            indent: extra indentation for the tree being printed</span>
<span class="sd">            format: format to be used to print each node</span>
<span class="sd">            deptypes: dependency types to be represented in the tree</span>
<span class="sd">            show_types: if True, show the (merged) dependency type of a node</span>
<span class="sd">            depth_first: if True, traverse the DAG depth first when representing it as a tree</span>
<span class="sd">            recurse_dependencies: if True, recurse on dependencies</span>
<span class="sd">            status_fn: optional callable that takes a node as an argument and return its</span>
<span class="sd">                installation status</span>
<span class="sd">            prefix: optional callable that takes a node as an argument and return its</span>
<span class="sd">                installation prefix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">tree</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span>
            <span class="n">hashes</span><span class="o">=</span><span class="n">hashes</span><span class="p">,</span>
            <span class="n">hashlen</span><span class="o">=</span><span class="n">hashlen</span><span class="p">,</span>
            <span class="n">cover</span><span class="o">=</span><span class="n">cover</span><span class="p">,</span>
            <span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="p">,</span>
            <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span>
            <span class="n">deptypes</span><span class="o">=</span><span class="n">deptypes</span><span class="p">,</span>
            <span class="n">show_types</span><span class="o">=</span><span class="n">show_types</span><span class="p">,</span>
            <span class="n">depth_first</span><span class="o">=</span><span class="n">depth_first</span><span class="p">,</span>
            <span class="n">recurse_dependencies</span><span class="o">=</span><span class="n">recurse_dependencies</span><span class="p">,</span>
            <span class="n">status_fn</span><span class="o">=</span><span class="n">status_fn</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">platform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="o">.</span><span class="n">platform</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">os</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="o">.</span><span class="n">os</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">target</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">architecture</span><span class="o">.</span><span class="n">target</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">build_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_spec</span> <span class="ow">or</span> <span class="bp">self</span>

    <span class="nd">@build_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">build_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_spec</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="Spec.trim">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.trim">[docs]</a>
    <span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dep_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove any package that is or provides `dep_name` transitively</span>
<span class="sd">        from this tree. This can also remove other dependencies if</span>
<span class="sd">        they are only present because of `dep_name`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">()):</span>
            <span class="n">new_dependencies</span> <span class="o">=</span> <span class="n">_EdgeMap</span><span class="p">()</span>  <span class="c1"># A new _EdgeMap</span>
            <span class="k">for</span> <span class="n">pkg_name</span><span class="p">,</span> <span class="n">edge_list</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">_dependencies</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">dep_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">virtuals</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">dep_name</span> <span class="o">==</span> <span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                        <span class="n">new_dependencies</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">_dependencies</span> <span class="o">=</span> <span class="n">new_dependencies</span></div>


    <span class="k">def</span> <span class="nf">_virtuals_provided</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return set of virtuals provided by self in the context of root&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># Could be using any virtual the package can provide</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="n">virtuals_provided</span><span class="p">)</span>

        <span class="n">hashes</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">traverse</span><span class="p">()]</span>
        <span class="n">in_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span><span class="n">edge</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_from_dependents</span><span class="p">()</span> <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">()</span> <span class="ow">in</span> <span class="n">hashes</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">virtuals</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">in_edges</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_splice_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">self_root</span><span class="p">,</span> <span class="n">other_root</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if other is a match for self in a splice of other_root into self_root</span>

<span class="sd">        Other is a splice match for self if it shares a name, or if self is a virtual provider</span>
<span class="sd">        and other provides a superset of the virtuals provided by self. Virtuals provided are</span>
<span class="sd">        evaluated in the context of a root spec (self_root for self, other_root for other).</span>

<span class="sd">        This is a slight oversimplification. Other could be a match for self in the context of</span>
<span class="sd">        one edge in self_root and not in the context of another edge. This method could be</span>
<span class="sd">        expanded in the future to account for these cases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span>
            <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_virtuals_provided</span><span class="p">(</span><span class="n">self_root</span><span class="p">))</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtuals_provided</span><span class="p">(</span><span class="n">self_root</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">_virtuals_provided</span><span class="p">(</span><span class="n">other_root</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_splice_detach_and_add_dependents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replacement</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper method for Spec._splice_helper.</span>

<span class="sd">        replacement is a node to splice in, context is the scope of dependents to consider relevant</span>
<span class="sd">        to this splice.&quot;&quot;&quot;</span>
        <span class="c1"># Update build_spec attributes for all transitive dependents</span>
        <span class="c1"># before we start changing their dependencies</span>
        <span class="n">ancestors_in_context</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;parents&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">deptype</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">LINK</span> <span class="o">|</span> <span class="n">dt</span><span class="o">.</span><span class="n">RUN</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">ancestor</span> <span class="ow">in</span> <span class="n">ancestors_in_context</span><span class="p">:</span>
            <span class="c1"># Only set it if it hasn&#39;t been spliced before</span>
            <span class="n">ancestor</span><span class="o">.</span><span class="n">_build_spec</span> <span class="o">=</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">_build_spec</span> <span class="ow">or</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ancestor</span><span class="o">.</span><span class="n">clear_caches</span><span class="p">(</span><span class="n">ignore</span><span class="o">=</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">package_hash</span><span class="o">.</span><span class="n">attr</span><span class="p">,))</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">edges_to_dependencies</span><span class="p">(</span><span class="n">depflag</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">depflag</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span><span class="p">:</span>
                    <span class="n">edge</span><span class="o">.</span><span class="n">depflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ancestor</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                    <span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">_dependents</span><span class="p">[</span><span class="n">ancestor</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="c1"># For each direct dependent in the link/run graph, replace the dependency on</span>
        <span class="c1"># node with one on replacement</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_from_dependents</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ancestors_in_context</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">_dependencies</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dependents</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">_add_dependency</span><span class="p">(</span><span class="n">replacement</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">depflag</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">virtuals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_splice_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replacement</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Main loop of a transitive splice.</span>

<span class="sd">        The while loop around a traversal of self ensures that changes to self from previous</span>
<span class="sd">        iterations are reflected in the traversal. This avoids evaluating irrelevant nodes</span>
<span class="sd">        using topological traversal (all incoming edges traversed before any outgoing edge).</span>
<span class="sd">        If any node will not be in the end result, its parent will be spliced and it will not</span>
<span class="sd">        ever be considered.</span>
<span class="sd">        For each node in self, find any analogous node in replacement and swap it in.</span>
<span class="sd">        We assume all build deps are handled outside of this method</span>

<span class="sd">        Arguments:</span>
<span class="sd">            replacement: The node that will replace any equivalent node in self</span>
<span class="sd">            self_root: The root of the spec that self comes from. This provides the context for</span>
<span class="sd">                evaluating whether ``replacement`` is a match for each node of ``self``. See</span>
<span class="sd">                ``Spec._splice_match`` and ``Spec._virtuals_provided`` for details.</span>
<span class="sd">            other_root: The root of the spec that replacement comes from. This provides the context</span>
<span class="sd">                for evaluating whether ``replacement`` is a match for each node of ``self``. See</span>
<span class="sd">                ``Spec._splice_match`` and ``Spec._virtuals_provided`` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">replacement</span><span class="o">.</span><span class="n">traverse</span><span class="p">())</span>

        <span class="c1"># Sort all possible replacements by name and virtual for easy access later</span>
        <span class="n">replacements_by_name</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">replacement</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="n">replacements_by_name</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">virtuals</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_virtuals_provided</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">replacement</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">virtual</span> <span class="ow">in</span> <span class="n">virtuals</span><span class="p">:</span>
                <span class="n">replacements_by_name</span><span class="p">[</span><span class="n">virtual</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Intentionally allowing traversal to change on each iteration</span>
            <span class="c1"># using breadth-first traversal to ensure we only reach nodes that will</span>
            <span class="c1"># be in final result</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;topo&quot;</span><span class="p">,</span> <span class="n">deptype</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">ALL</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span><span class="p">):</span>
                <span class="c1"># If this node has already been swapped in, don&#39;t consider it again</span>
                <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">analogs</span> <span class="o">=</span> <span class="n">replacements_by_name</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">analogs</span><span class="p">:</span>
                    <span class="c1"># If we have to check for matching virtuals, then we need to check that it</span>
                    <span class="c1"># matches all virtuals. Use `_splice_match` to validate possible matches</span>
                    <span class="k">for</span> <span class="n">virtual</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">_virtuals_provided</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="bp">self</span><span class="p">):</span>
                        <span class="n">analogs</span> <span class="o">+=</span> <span class="p">[</span>
                            <span class="n">r</span>
                            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">replacements_by_name</span><span class="p">[</span><span class="n">virtual</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">_splice_match</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">self_root</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_root</span><span class="o">=</span><span class="n">replacement</span><span class="p">)</span>
                        <span class="p">]</span>

                    <span class="c1"># No match, keep iterating over self</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">analogs</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="c1"># If there are multiple analogs, this package must satisfy the constraint</span>
                <span class="c1"># that a newer version can always replace a lesser version.</span>
                <span class="n">analog</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">analogs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>

                <span class="c1"># No splice needed here, keep checking</span>
                <span class="k">if</span> <span class="n">analog</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">node</span><span class="o">.</span><span class="n">_splice_detach_and_add_dependents</span><span class="p">(</span><span class="n">analog</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

<div class="viewcode-block" id="Spec.splice">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.splice">[docs]</a>
    <span class="k">def</span> <span class="nf">splice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Spec&quot;</span><span class="p">,</span> <span class="n">transitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Spec&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new, spliced concrete Spec with the &quot;other&quot; dependency and,</span>
<span class="sd">        optionally, its dependencies.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: alternate dependency</span>
<span class="sd">            transitive: include other&#39;s dependencies</span>

<span class="sd">        Returns: a concrete, spliced version of the current Spec</span>

<span class="sd">        When transitive is &quot;True&quot;, use the dependencies from &quot;other&quot; to reconcile</span>
<span class="sd">        conflicting dependencies. When transitive is &quot;False&quot;, use dependencies from self.</span>

<span class="sd">        For example, suppose we have the following dependency graph:</span>

<span class="sd">            T</span>
<span class="sd">            | \</span>
<span class="sd">            Z&lt;-H</span>

<span class="sd">        Spec T depends on H and Z, and H also depends on Z. Now we want to use</span>
<span class="sd">        a different H, called H&#39;. This function can be used to splice in H&#39; to</span>
<span class="sd">        create a new spec, called T*. If H&#39; was built with Z&#39;, then transitive</span>
<span class="sd">        &quot;True&quot; will ensure H&#39; and T* both depend on Z&#39;:</span>

<span class="sd">            T*</span>
<span class="sd">            | \</span>
<span class="sd">            Z&#39;&lt;-H&#39;</span>

<span class="sd">        If transitive is &quot;False&quot;, then H&#39; and T* will both depend on</span>
<span class="sd">        the original Z, resulting in a new H&#39;*</span>

<span class="sd">            T*</span>
<span class="sd">            | \</span>
<span class="sd">            Z&lt;-H&#39;*</span>

<span class="sd">        Provenance of the build is tracked through the &quot;build_spec&quot; property</span>
<span class="sd">        of the spliced spec and any correspondingly modified dependency specs.</span>
<span class="sd">        The build specs are set to that of the original spec, so the original</span>
<span class="sd">        spec&#39;s provenance is preserved unchanged.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span>
        <span class="k">assert</span> <span class="n">other</span><span class="o">.</span><span class="n">concrete</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_splice_match</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">self_root</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_root</span><span class="o">=</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">_splice_match</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">self_root</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_root</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">deptype</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">LINK</span> <span class="o">|</span> <span class="n">dt</span><span class="o">.</span><span class="n">RUN</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">other_str</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{name}</span><span class="s2">/</span><span class="si">{hash:7}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">self_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{name}</span><span class="s2">/</span><span class="si">{hash:7}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Cannot splice </span><span class="si">{</span><span class="n">other_str</span><span class="si">}</span><span class="s2"> into </span><span class="si">{</span><span class="n">self_str</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; Either </span><span class="si">{</span><span class="n">self_str</span><span class="si">}</span><span class="s2"> cannot depend on </span><span class="si">{</span><span class="n">other_str</span><span class="si">}</span><span class="s2">,&quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; or </span><span class="si">{</span><span class="n">other_str</span><span class="si">}</span><span class="s2"> fails to provide a virtual used in </span><span class="si">{</span><span class="n">self_str</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="n">SpliceError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Copies of all non-build deps, build deps will get added at the end</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deps</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">ALL</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span><span class="p">)</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deps</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">ALL</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">make_node_pairs</span><span class="p">(</span><span class="n">orig_spec</span><span class="p">,</span> <span class="n">copied_spec</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">orig_spec</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">deptype</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">ALL</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span><span class="p">),</span>
                    <span class="n">copied_spec</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">deptype</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">ALL</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">mask_build_deps</span><span class="p">(</span><span class="n">in_spec</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">in_spec</span><span class="o">.</span><span class="n">traverse_edges</span><span class="p">(</span><span class="n">cover</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">):</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">depflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span>

        <span class="k">if</span> <span class="n">transitive</span><span class="p">:</span>
            <span class="c1"># These pairs will allow us to reattach all direct build deps</span>
            <span class="c1"># We need the list of pairs while the two specs still match</span>
            <span class="n">node_pairs</span> <span class="o">=</span> <span class="n">make_node_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>

            <span class="c1"># Ignore build deps in the modified spec while doing the splice</span>
            <span class="c1"># They will be added back in at the end</span>
            <span class="n">mask_build_deps</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

            <span class="c1"># Transitively splice any relevant nodes from new into base</span>
            <span class="c1"># This handles all shared dependencies between self and other</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">_splice_helper</span><span class="p">(</span><span class="n">replacement</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Do the same thing as the transitive splice, but reversed</span>
            <span class="n">node_pairs</span> <span class="o">=</span> <span class="n">make_node_pairs</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">replacement</span><span class="p">)</span>
            <span class="n">mask_build_deps</span><span class="p">(</span><span class="n">replacement</span><span class="p">)</span>
            <span class="n">replacement</span><span class="o">.</span><span class="n">_splice_helper</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

            <span class="c1"># Intransitively splice replacement into spec</span>
            <span class="c1"># This is very simple now that all shared dependencies have been handled</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;topo&quot;</span><span class="p">,</span> <span class="n">deptype</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">LINK</span> <span class="o">|</span> <span class="n">dt</span><span class="o">.</span><span class="n">RUN</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">_splice_match</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">self_root</span><span class="o">=</span><span class="n">spec</span><span class="p">,</span> <span class="n">other_root</span><span class="o">=</span><span class="n">other</span><span class="p">):</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">_splice_detach_and_add_dependents</span><span class="p">(</span><span class="n">replacement</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">spec</span><span class="p">)</span>

        <span class="c1"># For nodes that were spliced, modify the build spec to ensure build deps are preserved</span>
        <span class="c1"># For nodes that were not spliced, replace the build deps on the spec itself</span>
        <span class="k">for</span> <span class="n">orig</span><span class="p">,</span> <span class="n">copy</span> <span class="ow">in</span> <span class="n">node_pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span><span class="o">.</span><span class="n">_build_spec</span><span class="p">:</span>
                <span class="n">copy</span><span class="o">.</span><span class="n">_build_spec</span> <span class="o">=</span> <span class="n">orig</span><span class="o">.</span><span class="n">build_spec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">orig</span><span class="o">.</span><span class="n">edges_to_dependencies</span><span class="p">(</span><span class="n">depflag</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span><span class="p">):</span>
                    <span class="n">copy</span><span class="o">.</span><span class="n">_add_dependency</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="p">,</span> <span class="n">depflag</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">BUILD</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">virtuals</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span></div>


<div class="viewcode-block" id="Spec.clear_caches">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.clear_caches">[docs]</a>
    <span class="k">def</span> <span class="nf">clear_caches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears all cached hashes in a Spec, while preserving other properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">hashes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">attr</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;_dunder_hash&quot;</span><span class="p">,</span> <span class="s2">&quot;_prefix&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If the spec is concrete, we leverage the process hash and just use</span>
        <span class="c1"># a 64-bit prefix of it. The process hash has the advantage that it&#39;s</span>
        <span class="c1"># computed once per concrete spec, and it&#39;s saved -- so if we read</span>
        <span class="c1"># concrete specs we don&#39;t need to recompute the whole hash. This is</span>
        <span class="c1"># good for large, unchanging specs.</span>
        <span class="c1">#</span>
        <span class="c1"># We use the process hash instead of the DAG hash here because the DAG</span>
        <span class="c1"># hash includes the package hash, which can cause infinite recursion,</span>
        <span class="c1"># and which isn&#39;t defined unless the spec has a known package.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dunder_hash</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dunder_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_hash_bit_prefix</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dunder_hash</span>

        <span class="c1"># This is the normal hash for lazy_lexicographic_ordering. It&#39;s</span>
        <span class="c1"># slow for large specs because it traverses the whole spec graph,</span>
        <span class="c1"># so we hope it only runs on abstract specs, which are small.</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">lang</span><span class="o">.</span><span class="n">tuplify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cmp_iter</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Spec</span><span class="o">.</span><span class="n">from_dict</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="nb">hash</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">process_hash</span><span class="p">),)</span>

<div class="viewcode-block" id="Spec.attach_git_version_lookup">
<a class="viewcode-back" href="../../spack.html#spack.spec.Spec.attach_git_version_lookup">[docs]</a>
    <span class="k">def</span> <span class="nf">attach_git_version_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Add a git lookup method for GitVersions</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">versions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">vn</span><span class="o">.</span><span class="n">GitVersion</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">_ref_version</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">attach_lookup</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">git_ref_lookup</span><span class="o">.</span><span class="n">GitRefLookup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">))</span></div>
</div>



<span class="k">class</span> <span class="nc">VariantMap</span><span class="p">(</span><span class="n">lang</span><span class="o">.</span><span class="n">HashableMap</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Map containing variant instances. New values can be added only</span>
<span class="sd">    if the key is not already present.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Spec</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">vspec</span><span class="p">):</span>
        <span class="c1"># Raise a TypeError if vspec is not of the right type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vspec</span><span class="p">,</span> <span class="n">vt</span><span class="o">.</span><span class="n">AbstractVariant</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;VariantMap accepts only values of variant types &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;[got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">vspec</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> instead]&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Raise an error if the variant was already in this map</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot specify variant &quot;</span><span class="si">{0}</span><span class="s1">&quot; twice&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">vt</span><span class="o">.</span><span class="n">DuplicateVariantError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Raise an error if name and vspec.name don&#39;t match</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">vspec</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Inconsistent key &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot;, must be &quot;</span><span class="si">{</span><span class="n">vspec</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; to &#39;</span> <span class="s2">&quot;match VariantSpec&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Set the item</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">vspec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">substitute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vspec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Substitutes the entry under ``vspec.name`` with ``vspec``.</span>

<span class="sd">        Args:</span>
<span class="sd">            vspec: variant spec to be substituted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vspec</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot substitute a key that does not exist [</span><span class="si">{</span><span class="n">vspec</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="c1"># Set the item</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">vspec</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">vspec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">partition_variants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">non_prop</span><span class="p">,</span> <span class="n">prop</span> <span class="o">=</span> <span class="n">lang</span><span class="o">.</span><span class="n">stable_partition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">propagate</span><span class="p">)</span>
        <span class="c1"># Just return the names</span>
        <span class="n">non_prop</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">non_prop</span><span class="p">]</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">prop</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">non_prop</span><span class="p">,</span> <span class="n">prop</span>

    <span class="k">def</span> <span class="nf">satisfies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;VariantMap&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_satisfies_when_self_concrete</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_satisfies_when_self_abstract</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_satisfies_when_self_concrete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;VariantMap&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">non_propagating</span><span class="p">,</span> <span class="n">propagating</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">partition_variants</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">non_propagating</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">propagating</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">propagating</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">variants</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_satisfies_when_self_abstract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;VariantMap&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">other_non_propagating</span><span class="p">,</span> <span class="n">other_propagating</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">partition_variants</span><span class="p">()</span>
        <span class="n">self_non_propagating</span><span class="p">,</span> <span class="n">self_propagating</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_variants</span><span class="p">()</span>

        <span class="c1"># First check variants without propagation set</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">name</span> <span class="ow">in</span> <span class="n">self_non_propagating</span>
            <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">propagate</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">name</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">other_non_propagating</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">other_propagating</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">self_propagating</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># Check that self doesn&#39;t contradict variants propagated by other</span>
        <span class="k">if</span> <span class="n">other_propagating</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">other_propagating</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">variants</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Check that other doesn&#39;t contradict variants propagated by self</span>
        <span class="k">if</span> <span class="n">self_propagating</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">self_propagating</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">variants</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">constrain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;VariantMap&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add all variants in other that aren&#39;t in self to self. Also constrain all multi-valued</span>
<span class="sd">        variants that are already present. Return True iff self changed&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">_concrete</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">vt</span><span class="o">.</span><span class="n">UnsatisfiableVariantSpecError</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="s2">&quot;&lt;absent&gt;&quot;</span><span class="p">)</span>

        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="c1"># If they are not compatible raise an error</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">compatible</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="n">vt</span><span class="o">.</span><span class="n">UnsatisfiableVariantSpecError</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">other</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="c1"># If they are compatible merge them</span>
                <span class="n">changed</span> <span class="o">|=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If it is not present copy it straight away</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">changed</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">concrete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the spec is concrete in terms of variants.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True or False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">_concrete</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">package_class</span><span class="o">.</span><span class="n">variant_names</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;VariantMap&quot;</span><span class="p">:</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="n">VariantMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">variant</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">clone</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">clone</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># print keys in order</span>
        <span class="n">sorted_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Separate boolean variants from key-value pairs as they print</span>
        <span class="c1"># differently. All booleans go first to avoid &#39; ~foo&#39; strings that</span>
        <span class="c1"># break spec reuse in zsh.</span>
        <span class="n">bool_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">kv_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sorted_keys</span><span class="p">:</span>
            <span class="n">bool_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">else</span> <span class="n">kv_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># add spaces before and after key/value variants.</span>
        <span class="n">string</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">bool_keys</span><span class="p">:</span>
            <span class="n">string</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kv_keys</span><span class="p">:</span>
            <span class="n">string</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="n">string</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">string</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">substitute_abstract_variants</span><span class="p">(</span><span class="n">spec</span><span class="p">:</span> <span class="n">Spec</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Uses the information in `spec.package` to turn any variant that needs</span>
<span class="sd">    it into a SingleValuedVariant or BoolValuedVariant.</span>

<span class="sd">    This method is best effort. All variants that can be substituted will be</span>
<span class="sd">    substituted before any error is raised.</span>

<span class="sd">    Args:</span>
<span class="sd">        spec: spec on which to operate the substitution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This method needs to be best effort so that it works in matrix exclusion</span>
    <span class="c1"># in $spack/lib/spack/spack/spec_list.py</span>
    <span class="n">unknown</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;dev_path&quot;</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">vt</span><span class="o">.</span><span class="n">SingleValuedVariant</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">_original_value</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">vt</span><span class="o">.</span><span class="n">reserved_names</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">variant_defs</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">package_class</span><span class="o">.</span><span class="n">variant_definitions</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">valid_defs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">when</span><span class="p">,</span> <span class="n">vdef</span> <span class="ow">in</span> <span class="n">variant_defs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">when</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
                <span class="n">valid_defs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vdef</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_defs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">package_class</span><span class="o">.</span><span class="n">variant_names</span><span class="p">():</span>
                <span class="n">unknown</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">whens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">when</span><span class="p">)</span> <span class="k">for</span> <span class="n">when</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">variant_defs</span><span class="p">]</span>
                <span class="k">raise</span> <span class="n">InvalidVariantForSpecError</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">whens</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">pkg_variant</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">valid_defs</span>
        <span class="k">if</span> <span class="n">rest</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">new_variant</span> <span class="o">=</span> <span class="n">pkg_variant</span><span class="o">.</span><span class="n">make_variant</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_original_value</span><span class="p">)</span>
        <span class="n">pkg_variant</span><span class="o">.</span><span class="n">validate_or_raise</span><span class="p">(</span><span class="n">new_variant</span><span class="p">,</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">new_variant</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">unknown</span><span class="p">:</span>
        <span class="n">variants</span> <span class="o">=</span> <span class="n">llnl</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">plural</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unknown</span><span class="p">),</span> <span class="s2">&quot;variant&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">vt</span><span class="o">.</span><span class="n">UnknownVariantError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Tried to set </span><span class="si">{</span><span class="n">variants</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">llnl</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">comma_and</span><span class="p">(</span><span class="n">unknown</span><span class="p">)</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> has no such </span><span class="si">{</span><span class="n">variants</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">unknown_variants</span><span class="o">=</span><span class="n">unknown</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">parse_with_version_concrete</span><span class="p">(</span><span class="n">spec_like</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Spec</span><span class="p">],</span> <span class="n">compiler</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as Spec(string), but interprets @x as @=x&quot;&quot;&quot;</span>
    <span class="n">s</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">CompilerSpec</span><span class="p">,</span> <span class="n">Spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">CompilerSpec</span><span class="p">(</span><span class="n">spec_like</span><span class="p">)</span> <span class="k">if</span> <span class="n">compiler</span> <span class="k">else</span> <span class="n">Spec</span><span class="p">(</span><span class="n">spec_like</span><span class="p">)</span>
    <span class="n">interpreted_version</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">versions</span><span class="o">.</span><span class="n">concrete_range_as_version</span>
    <span class="k">if</span> <span class="n">interpreted_version</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">versions</span> <span class="o">=</span> <span class="n">vn</span><span class="o">.</span><span class="n">VersionList</span><span class="p">([</span><span class="n">interpreted_version</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">s</span>


<span class="k">def</span> <span class="nf">merge_abstract_anonymous_specs</span><span class="p">(</span><span class="o">*</span><span class="n">abstract_specs</span><span class="p">:</span> <span class="n">Spec</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge the abstracts specs passed as input and return the result.</span>

<span class="sd">    The root specs must be anonymous, and it&#39;s duty of the caller to ensure that.</span>

<span class="sd">    This function merge the abstract specs based on package names. In particular</span>
<span class="sd">    it doesn&#39;t try to resolve virtual dependencies.</span>

<span class="sd">    Args:</span>
<span class="sd">        *abstract_specs: abstract specs to be merged</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">merged_spec</span> <span class="o">=</span> <span class="n">Spec</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">current_spec_constraint</span> <span class="ow">in</span> <span class="n">abstract_specs</span><span class="p">:</span>
        <span class="n">merged_spec</span><span class="o">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">current_spec_constraint</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">merged_spec</span><span class="o">.</span><span class="n">common_dependencies</span><span class="p">(</span><span class="n">current_spec_constraint</span><span class="p">):</span>
            <span class="n">merged_spec</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">current_spec_constraint</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">deps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Update with additional constraints from other spec</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">current_spec_constraint</span><span class="o">.</span><span class="n">direct_dep_difference</span><span class="p">(</span><span class="n">merged_spec</span><span class="p">):</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">current_spec_constraint</span><span class="o">.</span><span class="n">edges_to_dependencies</span><span class="p">(</span><span class="n">name</span><span class="p">)))</span>

            <span class="n">merged_spec</span><span class="o">.</span><span class="n">_add_dependency</span><span class="p">(</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">spec</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">depflag</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">depflag</span><span class="p">,</span> <span class="n">virtuals</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">virtuals</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">merged_spec</span>


<span class="k">def</span> <span class="nf">reconstruct_virtuals_on_edges</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruct virtuals on edges. Used to read from old DB and reindex.</span>

<span class="sd">    Args:</span>
<span class="sd">        spec: spec on which we want to reconstruct virtuals</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Collect all possible virtuals</span>
    <span class="n">possible_virtuals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">possible_virtuals</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="n">dependencies</span> <span class="k">if</span> <span class="n">Spec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">virtual</span><span class="p">})</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot reconstruct virtual dependencies on package </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

    <span class="c1"># Assume all incoming edges to provider are marked with virtuals=</span>
    <span class="k">for</span> <span class="n">vspec</span> <span class="ow">in</span> <span class="n">possible_virtuals</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">provider</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[</span><span class="n">vspec</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Virtual not in the DAG</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">provider</span><span class="o">.</span><span class="n">edges_from_dependents</span><span class="p">():</span>
            <span class="n">edge</span><span class="o">.</span><span class="n">update_virtuals</span><span class="p">([</span><span class="n">vspec</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">SpecfileReaderBase</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_node_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">Spec</span><span class="p">()</span>

        <span class="n">name</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">name_and_data</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">hashes</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="n">spec</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;namespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;version&quot;</span> <span class="ow">in</span> <span class="n">node</span> <span class="ow">or</span> <span class="s2">&quot;versions&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">versions</span> <span class="o">=</span> <span class="n">vn</span><span class="o">.</span><span class="n">VersionList</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">attach_git_version_lookup</span><span class="p">()</span>

        <span class="k">if</span> <span class="s2">&quot;arch&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">architecture</span> <span class="o">=</span> <span class="n">ArchSpec</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;compiler&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">compiler</span> <span class="o">=</span> <span class="n">CompilerSpec</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">compiler</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">propagated_names</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;propagate&quot;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parameters&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">propagate</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">propagated_names</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_valid_compiler_flags</span><span class="p">:</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">compiler_flags</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="n">spec</span><span class="o">.</span><span class="n">compiler_flags</span><span class="o">.</span><span class="n">add_flag</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">propagate</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">variants</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">MultiValuedVariant</span><span class="o">.</span><span class="n">from_node_dict</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">propagate</span><span class="o">=</span><span class="n">propagate</span>
                <span class="p">)</span>

        <span class="n">spec</span><span class="o">.</span><span class="n">external_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">external_modules</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;external&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="c1"># This conditional is needed because sometimes this function is</span>
            <span class="c1"># called with a node already constructed that contains a &#39;versions&#39;</span>
            <span class="c1"># and &#39;external&#39; field. Related to virtual packages provider</span>
            <span class="c1"># indexes.</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;external&quot;</span><span class="p">]:</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">external_path</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;external&quot;</span><span class="p">][</span><span class="s2">&quot;path&quot;</span><span class="p">]</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">external_modules</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;external&quot;</span><span class="p">][</span><span class="s2">&quot;module&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">external_modules</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">spec</span><span class="o">.</span><span class="n">external_modules</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">extra_attributes</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">node</span><span class="p">[</span><span class="s2">&quot;external&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;extra_attributes&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">syaml</span><span class="o">.</span><span class="n">syaml_dict</span><span class="p">()</span>
                <span class="p">)</span>

        <span class="c1"># specs read in are concrete unless marked abstract</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;concrete&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">_mark_root_concrete</span><span class="p">()</span>

        <span class="k">if</span> <span class="s2">&quot;patches&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">patches</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;patches&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">patches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mvar</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;patches&quot;</span><span class="p">,</span> <span class="n">vt</span><span class="o">.</span><span class="n">MultiValuedVariant</span><span class="p">(</span><span class="s2">&quot;patches&quot;</span><span class="p">,</span> <span class="p">()))</span>
                <span class="n">mvar</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">patches</span>
                <span class="c1"># FIXME: Monkey patches mvar to store patches order</span>
                <span class="n">mvar</span><span class="o">.</span><span class="n">_patches_in_order_of_appearance</span> <span class="o">=</span> <span class="n">patches</span>

        <span class="c1"># Don&#39;t read dependencies here; from_dict() is used by</span>
        <span class="c1"># from_yaml() and from_json() to read the root *and* each dependency</span>
        <span class="c1"># spec.</span>

        <span class="k">return</span> <span class="n">spec</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a spec from JSON/YAML using the format version 2.</span>

<span class="sd">        This format is used in Spack v0.17, was introduced in</span>
<span class="sd">        https://github.com/spack/spack/pull/22845</span>

<span class="sd">        Args:</span>
<span class="sd">            data: a nested dict/list data structure read from YAML or JSON.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Current specfile format</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;spec&quot;</span><span class="p">][</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span>
        <span class="n">hash_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">any_deps</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Pass 0: Determine hash type</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dhash_type</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">dependencies_from_node_dict</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="n">any_deps</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">dhash_type</span><span class="p">:</span>
                    <span class="n">hash_type</span> <span class="o">=</span> <span class="n">dhash_type</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">any_deps</span><span class="p">:</span>  <span class="c1"># If we never see a dependency...</span>
            <span class="n">hash_type</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="o">.</span><span class="n">name</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">hash_type</span><span class="p">:</span>  <span class="c1"># Seen a dependency, still don&#39;t know hash_type</span>
            <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span>
                <span class="s2">&quot;Spec dictionary contains malformed dependencies. Old format?&quot;</span>
            <span class="p">)</span>

        <span class="n">hash_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">root_spec_hash</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Pass 1: Create a single lookup dictionary by hash</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">node_hash</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="n">hash_type</span><span class="p">]</span>
            <span class="n">node_spec</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_node_dict</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">hash_dict</span><span class="p">[</span><span class="n">node_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">hash_dict</span><span class="p">[</span><span class="n">node_hash</span><span class="p">][</span><span class="s2">&quot;node_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_spec</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">root_spec_hash</span> <span class="o">=</span> <span class="n">node_hash</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">root_spec_hash</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span><span class="s2">&quot;Spec dictionary contains no nodes.&quot;</span><span class="p">)</span>

        <span class="c1"># Pass 2: Finish construction of all DAG edges (including build specs)</span>
        <span class="k">for</span> <span class="n">node_hash</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">hash_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">node_spec</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;node_spec&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">dhash</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">virtuals</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">dependencies_from_node_dict</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="n">node_spec</span><span class="o">.</span><span class="n">_add_dependency</span><span class="p">(</span>
                    <span class="n">hash_dict</span><span class="p">[</span><span class="n">dhash</span><span class="p">][</span><span class="s2">&quot;node_spec&quot;</span><span class="p">],</span>
                    <span class="n">depflag</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span>
                    <span class="n">virtuals</span><span class="o">=</span><span class="n">virtuals</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;build_spec&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">bhash</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">extract_build_spec_info_from_node_dict</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">hash_type</span><span class="o">=</span><span class="n">hash_type</span><span class="p">)</span>
                <span class="n">node_spec</span><span class="o">.</span><span class="n">_build_spec</span> <span class="o">=</span> <span class="n">hash_dict</span><span class="p">[</span><span class="n">bhash</span><span class="p">][</span><span class="s2">&quot;node_spec&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">hash_dict</span><span class="p">[</span><span class="n">root_spec_hash</span><span class="p">][</span><span class="s2">&quot;node_spec&quot;</span><span class="p">]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_specfile_dep_specs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">deps</span><span class="p">,</span> <span class="n">hash_type</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses must implement this method.&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SpecfileV1</span><span class="p">(</span><span class="n">SpecfileReaderBase</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a spec from JSON/YAML using the format version 1.</span>

<span class="sd">        Note: Version 1 format has no notion of a build_spec, and names are</span>
<span class="sd">        guaranteed to be unique. This function is guaranteed to read specs as</span>
<span class="sd">        old as v0.10 - while it was not checked for older formats.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: a nested dict/list data structure read from YAML or JSON.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;spec&quot;</span><span class="p">]</span>

        <span class="c1"># Read nodes out of list.  Root spec is the first element;</span>
        <span class="c1"># dependencies are the following elements.</span>
        <span class="n">dep_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">from_node_dict</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dep_list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span><span class="s2">&quot;specfile contains no nodes.&quot;</span><span class="p">)</span>

        <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">spec</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">dep_list</span><span class="p">}</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">dep_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="c1"># get dependency dict from the node.</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">name_and_data</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dname</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">virtuals</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">dependencies_from_node_dict</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="n">deps</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_add_dependency</span><span class="p">(</span>
                    <span class="n">deps</span><span class="p">[</span><span class="n">dname</span><span class="p">],</span> <span class="n">depflag</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">dtypes</span><span class="p">),</span> <span class="n">virtuals</span><span class="o">=</span><span class="n">virtuals</span>
                <span class="p">)</span>

        <span class="n">reconstruct_virtuals_on_edges</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">name_and_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">node</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">dependencies_from_node_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;dependencies&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">read_specfile_dep_specs</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s2">&quot;dependencies&quot;</span><span class="p">]):</span>
            <span class="k">yield</span> <span class="n">t</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_specfile_dep_specs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">deps</span><span class="p">,</span> <span class="n">hash_type</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the DependencySpec portion of a YAML-formatted Spec.</span>
<span class="sd">        This needs to be backward-compatible with older spack spec</span>
<span class="sd">        formats so that reindex will work on old specs/databases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dep_name</span><span class="p">,</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">deps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">hashes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">elt</span><span class="p">:</span>
                        <span class="n">dep_hash</span><span class="p">,</span> <span class="n">deptypes</span> <span class="o">=</span> <span class="n">elt</span><span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">elt</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
                        <span class="n">hash_type</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">name</span>
                        <span class="n">virtuals</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># We never determined a hash type...</span>
                    <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t parse dependency spec.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t parse dependency types in spec.&quot;</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">dep_name</span><span class="p">,</span> <span class="n">dep_hash</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">deptypes</span><span class="p">),</span> <span class="n">hash_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">virtuals</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SpecfileV2</span><span class="p">(</span><span class="n">SpecfileReaderBase</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">reconstruct_virtuals_on_edges</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">name_and_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">node</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">dependencies_from_node_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">read_specfile_dep_specs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dependencies&quot;</span><span class="p">,</span> <span class="p">[]))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_specfile_dep_specs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">deps</span><span class="p">,</span> <span class="n">hash_type</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the DependencySpec portion of a YAML-formatted Spec.</span>
<span class="sd">        This needs to be backward-compatible with older spack spec</span>
<span class="sd">        formats so that reindex will work on old specs/databases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deps</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span><span class="s2">&quot;Spec dictionary contains malformed dependencies&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">:</span>
            <span class="n">elt</span> <span class="o">=</span> <span class="n">dep</span>
            <span class="n">dep_name</span> <span class="o">=</span> <span class="n">dep</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="c1"># new format: elements of dependency spec are keyed.</span>
                <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">hashes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">elt</span><span class="p">:</span>
                        <span class="n">dep_hash</span><span class="p">,</span> <span class="n">deptypes</span><span class="p">,</span> <span class="n">hash_type</span><span class="p">,</span> <span class="n">virtuals</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">extract_info_from_dep</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># We never determined a hash type...</span>
                    <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t parse dependency spec.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t parse dependency types in spec.&quot;</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dep_name</span><span class="p">,</span> <span class="n">dep_hash</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">deptypes</span><span class="p">),</span> <span class="n">hash_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">virtuals</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">extract_info_from_dep</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">elt</span><span class="p">,</span> <span class="nb">hash</span><span class="p">):</span>
        <span class="n">dep_hash</span><span class="p">,</span> <span class="n">deptypes</span> <span class="o">=</span> <span class="n">elt</span><span class="p">[</span><span class="nb">hash</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">elt</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
        <span class="n">hash_type</span> <span class="o">=</span> <span class="nb">hash</span><span class="o">.</span><span class="n">name</span>
        <span class="n">virtuals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">dep_hash</span><span class="p">,</span> <span class="n">deptypes</span><span class="p">,</span> <span class="n">hash_type</span><span class="p">,</span> <span class="n">virtuals</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">extract_build_spec_info_from_node_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">hash_type</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
        <span class="n">build_spec_dict</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;build_spec&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">build_spec_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">build_spec_dict</span><span class="p">[</span><span class="n">hash_type</span><span class="p">],</span> <span class="n">hash_type</span>


<span class="k">class</span> <span class="nc">SpecfileV3</span><span class="p">(</span><span class="n">SpecfileV2</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">SpecfileV4</span><span class="p">(</span><span class="n">SpecfileV2</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">extract_info_from_dep</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">elt</span><span class="p">,</span> <span class="nb">hash</span><span class="p">):</span>
        <span class="n">dep_hash</span> <span class="o">=</span> <span class="n">elt</span><span class="p">[</span><span class="nb">hash</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="n">deptypes</span> <span class="o">=</span> <span class="n">elt</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">][</span><span class="s2">&quot;deptypes&quot;</span><span class="p">]</span>
        <span class="n">hash_type</span> <span class="o">=</span> <span class="nb">hash</span><span class="o">.</span><span class="n">name</span>
        <span class="n">virtuals</span> <span class="o">=</span> <span class="n">elt</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">][</span><span class="s2">&quot;virtuals&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dep_hash</span><span class="p">,</span> <span class="n">deptypes</span><span class="p">,</span> <span class="n">hash_type</span><span class="p">,</span> <span class="n">virtuals</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">LazySpecCache</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cache for Specs that uses a spec_like as key, and computes lazily</span>
<span class="sd">    the corresponding value ``Spec(spec_like``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Spec</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_factory</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">save_dependency_specfiles</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Spec</span><span class="p">,</span> <span class="n">output_directory</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dependencies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Spec</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a root spec (represented as a yaml object), index it with a subset</span>
<span class="sd">    of its dependencies, and write each dependency to a separate yaml file</span>
<span class="sd">    in the output directory.  By default, all dependencies will be written</span>
<span class="sd">    out.  To choose a smaller subset of dependencies to be written, pass a</span>
<span class="sd">    list of package names in the dependencies parameter. If the format of the</span>
<span class="sd">    incoming spec is not json, that can be specified with the spec_format</span>
<span class="sd">    parameter. This can be used to convert from yaml specfiles to the</span>
<span class="sd">    json format.&quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">satisfies</span><span class="p">(</span><span class="n">dep</span><span class="p">)</span> <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">dependencies</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">json_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_directory</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.json&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
            <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="nb">hash</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">dag_hash</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">get_host_environment_metadata</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the host environment, reduce to a subset that we can store in</span>
<span class="sd">    the install directory, and add the spack version.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">environ</span> <span class="o">=</span> <span class="n">get_host_environment</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;host_os&quot;</span><span class="p">:</span> <span class="n">environ</span><span class="p">[</span><span class="s2">&quot;os&quot;</span><span class="p">],</span>
        <span class="s2">&quot;platform&quot;</span><span class="p">:</span> <span class="n">environ</span><span class="p">[</span><span class="s2">&quot;platform&quot;</span><span class="p">],</span>
        <span class="s2">&quot;host_target&quot;</span><span class="p">:</span> <span class="n">environ</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">],</span>
        <span class="s2">&quot;hostname&quot;</span><span class="p">:</span> <span class="n">environ</span><span class="p">[</span><span class="s2">&quot;hostname&quot;</span><span class="p">],</span>
        <span class="s2">&quot;spack_version&quot;</span><span class="p">:</span> <span class="n">spack</span><span class="o">.</span><span class="n">get_version</span><span class="p">(),</span>
        <span class="s2">&quot;kernel_version&quot;</span><span class="p">:</span> <span class="n">platform</span><span class="o">.</span><span class="n">version</span><span class="p">(),</span>
    <span class="p">}</span>


<span class="k">def</span> <span class="nf">get_host_environment</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a dictionary (lookup) with host information (not including the</span>
<span class="sd">    os.environ).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">host_platform</span> <span class="o">=</span> <span class="n">spack</span><span class="o">.</span><span class="n">platforms</span><span class="o">.</span><span class="n">host</span><span class="p">()</span>
    <span class="n">host_target</span> <span class="o">=</span> <span class="n">host_platform</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="s2">&quot;default_target&quot;</span><span class="p">)</span>
    <span class="n">host_os</span> <span class="o">=</span> <span class="n">host_platform</span><span class="o">.</span><span class="n">operating_system</span><span class="p">(</span><span class="s2">&quot;default_os&quot;</span><span class="p">)</span>
    <span class="n">arch_fmt</span> <span class="o">=</span> <span class="s2">&quot;platform=</span><span class="si">{0}</span><span class="s2"> os=</span><span class="si">{1}</span><span class="s2"> target=</span><span class="si">{2}</span><span class="s2">&quot;</span>
    <span class="n">arch_spec</span> <span class="o">=</span> <span class="n">Spec</span><span class="p">(</span><span class="n">arch_fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">host_platform</span><span class="p">,</span> <span class="n">host_os</span><span class="p">,</span> <span class="n">host_target</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">host_target</span><span class="p">),</span>
        <span class="s2">&quot;os&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">host_os</span><span class="p">),</span>
        <span class="s2">&quot;platform&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">host_platform</span><span class="p">),</span>
        <span class="s2">&quot;arch&quot;</span><span class="p">:</span> <span class="n">arch_spec</span><span class="p">,</span>
        <span class="s2">&quot;architecture&quot;</span><span class="p">:</span> <span class="n">arch_spec</span><span class="p">,</span>
        <span class="s2">&quot;arch_str&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">arch_spec</span><span class="p">),</span>
        <span class="s2">&quot;hostname&quot;</span><span class="p">:</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">(),</span>
    <span class="p">}</span>


<div class="viewcode-block" id="SpecParseError">
<a class="viewcode-back" href="../../spack.html#spack.spec.SpecParseError">[docs]</a>
<span class="k">class</span> <span class="nc">SpecParseError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper for ParseError for when we&#39;re parsing specs.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parse_error</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parse_error</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">parse_error</span><span class="o">.</span><span class="n">string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">parse_error</span><span class="o">.</span><span class="n">pos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">long_message</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="s2">&quot;  Encountered when parsing spec:&quot;</span><span class="p">,</span>
                <span class="s2">&quot;    </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span>
                <span class="s2">&quot;    </span><span class="si">%s</span><span class="s2">^&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span></div>



<span class="k">class</span> <span class="nc">InvalidVariantForSpecError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when an invalid conditional variant is specified.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variant</span><span class="p">,</span> <span class="n">when</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Invalid variant </span><span class="si">{</span><span class="n">variant</span><span class="si">}</span><span class="s2"> for spec </span><span class="si">{</span><span class="n">spec</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variant</span><span class="si">}</span><span class="s2"> is only available for </span><span class="si">{</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> when satisfying one of </span><span class="si">{</span><span class="n">when</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<div class="viewcode-block" id="UnsupportedPropagationError">
<a class="viewcode-back" href="../../spack.html#spack.spec.UnsupportedPropagationError">[docs]</a>
<span class="k">class</span> <span class="nc">UnsupportedPropagationError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when propagation (==) is used with reserved variant names.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="DuplicateDependencyError">
<a class="viewcode-back" href="../../spack.html#spack.spec.DuplicateDependencyError">[docs]</a>
<span class="k">class</span> <span class="nc">DuplicateDependencyError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when the same dependency occurs in a spec twice.&quot;&quot;&quot;</span></div>



<span class="k">class</span> <span class="nc">MultipleVersionError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when version constraints occur in a spec twice.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="DuplicateCompilerSpecError">
<a class="viewcode-back" href="../../spack.html#spack.spec.DuplicateCompilerSpecError">[docs]</a>
<span class="k">class</span> <span class="nc">DuplicateCompilerSpecError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when the same compiler occurs in a spec twice.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="UnsupportedCompilerError">
<a class="viewcode-back" href="../../spack.html#spack.spec.UnsupportedCompilerError">[docs]</a>
<span class="k">class</span> <span class="nc">UnsupportedCompilerError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when the user asks for a compiler spack doesn&#39;t know about.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compiler_name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;The &#39;</span><span class="si">%s</span><span class="s2">&#39; compiler is not yet supported.&quot;</span> <span class="o">%</span> <span class="n">compiler_name</span><span class="p">)</span></div>



<div class="viewcode-block" id="DuplicateArchitectureError">
<a class="viewcode-back" href="../../spack.html#spack.spec.DuplicateArchitectureError">[docs]</a>
<span class="k">class</span> <span class="nc">DuplicateArchitectureError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when the same architecture occurs in a spec twice.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="InconsistentSpecError">
<a class="viewcode-back" href="../../spack.html#spack.spec.InconsistentSpecError">[docs]</a>
<span class="k">class</span> <span class="nc">InconsistentSpecError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when two nodes in the same spec DAG have inconsistent</span>
<span class="sd">    constraints.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="InvalidDependencyError">
<a class="viewcode-back" href="../../spack.html#spack.spec.InvalidDependencyError">[docs]</a>
<span class="k">class</span> <span class="nc">InvalidDependencyError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when a dependency in a spec is not actually a dependency</span>
<span class="sd">    of the package.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pkg</span><span class="p">,</span> <span class="n">deps</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalid_deps</span> <span class="o">=</span> <span class="n">deps</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="s2">&quot;Package </span><span class="si">{0}</span><span class="s2"> does not depend on </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pkg</span><span class="p">,</span> <span class="n">llnl</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">comma_or</span><span class="p">(</span><span class="n">deps</span><span class="p">))</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="NoProviderError">
<a class="viewcode-back" href="../../spack.html#spack.spec.NoProviderError">[docs]</a>
<span class="k">class</span> <span class="nc">NoProviderError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when there is no package that provides a particular</span>
<span class="sd">    virtual dependency.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vpkg</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;No providers found for virtual package: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">vpkg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vpkg</span> <span class="o">=</span> <span class="n">vpkg</span></div>



<div class="viewcode-block" id="MultipleProviderError">
<a class="viewcode-back" href="../../spack.html#spack.spec.MultipleProviderError">[docs]</a>
<span class="k">class</span> <span class="nc">MultipleProviderError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when there is no package that provides a particular</span>
<span class="sd">    virtual dependency.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vpkg</span><span class="p">,</span> <span class="n">providers</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes the name of the vpkg&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="s2">&quot;Multiple providers found for &#39;</span><span class="si">%s</span><span class="s2">&#39;: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vpkg</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">providers</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vpkg</span> <span class="o">=</span> <span class="n">vpkg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">providers</span> <span class="o">=</span> <span class="n">providers</span></div>



<div class="viewcode-block" id="UnsatisfiableSpecNameError">
<a class="viewcode-back" href="../../spack.html#spack.spec.UnsatisfiableSpecNameError">[docs]</a>
<span class="k">class</span> <span class="nc">UnsatisfiableSpecNameError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">UnsatisfiableSpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when two specs aren&#39;t even for the same package.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="UnsatisfiableVersionSpecError">
<a class="viewcode-back" href="../../spack.html#spack.spec.UnsatisfiableVersionSpecError">[docs]</a>
<span class="k">class</span> <span class="nc">UnsatisfiableVersionSpecError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">UnsatisfiableSpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when a spec version conflicts with package constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">,</span> <span class="s2">&quot;version&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="UnsatisfiableCompilerSpecError">
<a class="viewcode-back" href="../../spack.html#spack.spec.UnsatisfiableCompilerSpecError">[docs]</a>
<span class="k">class</span> <span class="nc">UnsatisfiableCompilerSpecError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">UnsatisfiableSpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when a spec compiler conflicts with package constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">,</span> <span class="s2">&quot;compiler&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="UnsatisfiableCompilerFlagSpecError">
<a class="viewcode-back" href="../../spack.html#spack.spec.UnsatisfiableCompilerFlagSpecError">[docs]</a>
<span class="k">class</span> <span class="nc">UnsatisfiableCompilerFlagSpecError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">UnsatisfiableSpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when a spec variant conflicts with package constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">,</span> <span class="s2">&quot;compiler_flags&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="UnsatisfiableArchitectureSpecError">
<a class="viewcode-back" href="../../spack.html#spack.spec.UnsatisfiableArchitectureSpecError">[docs]</a>
<span class="k">class</span> <span class="nc">UnsatisfiableArchitectureSpecError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">UnsatisfiableSpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when a spec architecture conflicts with package constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">,</span> <span class="s2">&quot;architecture&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="UnsatisfiableProviderSpecError">
<a class="viewcode-back" href="../../spack.html#spack.spec.UnsatisfiableProviderSpecError">[docs]</a>
<span class="k">class</span> <span class="nc">UnsatisfiableProviderSpecError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">UnsatisfiableSpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when a provider is supplied but constraints don&#39;t match</span>
<span class="sd">    a vpkg requirement&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">,</span> <span class="s2">&quot;provider&quot;</span><span class="p">)</span></div>



<span class="c1"># TODO: get rid of this and be more specific about particular incompatible</span>
<span class="c1"># dep constraints</span>
<div class="viewcode-block" id="UnsatisfiableDependencySpecError">
<a class="viewcode-back" href="../../spack.html#spack.spec.UnsatisfiableDependencySpecError">[docs]</a>
<span class="k">class</span> <span class="nc">UnsatisfiableDependencySpecError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">UnsatisfiableSpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when some dependency of constrained specs are incompatible&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">provided</span><span class="p">,</span> <span class="n">required</span><span class="p">,</span> <span class="s2">&quot;dependency&quot;</span><span class="p">)</span></div>



<span class="k">class</span> <span class="nc">UnconstrainableDependencySpecError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when attempting to constrain by an anonymous dependency spec&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot constrain by spec &#39;</span><span class="si">%s</span><span class="s2">&#39;. Cannot constrain by a&quot;</span> <span class="o">%</span> <span class="n">spec</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; spec containing anonymous dependencies&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<div class="viewcode-block" id="AmbiguousHashError">
<a class="viewcode-back" href="../../spack.html#spack.spec.AmbiguousHashError">[docs]</a>
<span class="k">class</span> <span class="nc">AmbiguousHashError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">specs</span><span class="p">):</span>
        <span class="n">spec_fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{namespace}</span><span class="s2">.</span><span class="si">{name}</span><span class="s2">{@version}{</span><span class="si">%c</span><span class="s2">ompiler}</span><span class="si">{compiler_flags}</span><span class="s2">&quot;</span>
        <span class="n">spec_fmt</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{variants}</span><span class="s2">{ arch=architecture}{/hash:7}&quot;</span>
        <span class="n">specs_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  &quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec_fmt</span><span class="p">)</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span> <span class="n">specs_str</span><span class="p">)</span></div>



<div class="viewcode-block" id="InvalidHashError">
<a class="viewcode-back" href="../../spack.html#spack.spec.InvalidHashError">[docs]</a>
<span class="k">class</span> <span class="nc">InvalidHashError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="nb">hash</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;No spec with hash </span><span class="si">{</span><span class="nb">hash</span><span class="si">}</span><span class="s2"> could be found to match </span><span class="si">{</span><span class="n">spec</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; Either the hash does not exist, or it does not match other spec constraints.&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>



<span class="k">class</span> <span class="nc">SpecFilenameError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when a spec file name is invalid.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">NoSuchSpecFileError</span><span class="p">(</span><span class="n">SpecFilenameError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when a spec file doesn&#39;t exist.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">SpecFormatStringError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Called for errors in Spec format strings.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">SpecFormatPathError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Called for errors in Spec path-format strings.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">SpecFormatSigilError</span><span class="p">(</span><span class="n">SpecFormatStringError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Called for mismatched sigils and attributes in format strings&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigil</span><span class="p">,</span> <span class="n">requirement</span><span class="p">,</span> <span class="n">used</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The sigil </span><span class="si">%s</span><span class="s2"> may only be used for </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sigil</span><span class="p">,</span> <span class="n">requirement</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; It was used with the attribute </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">used</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ConflictsInSpecError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">matches</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Conflicts in concretized spec &quot;</span><span class="si">{0}</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">short_spec</span><span class="p">)</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">long_message</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">match_fmt_default</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">. &quot;</span><span class="si">{1}</span><span class="s1">&quot; conflicts with &quot;</span><span class="si">{2}</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">match_fmt_custom</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">. &quot;</span><span class="si">{1}</span><span class="s1">&quot; conflicts with &quot;</span><span class="si">{2}</span><span class="s1">&quot; [</span><span class="si">{3}</span><span class="s1">]</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">matches</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">long_message</span> <span class="o">+=</span> <span class="s2">&quot;List of matching conflicts for spec:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="n">long_message</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">tree</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

            <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">long_message</span> <span class="o">+=</span> <span class="n">match_fmt_default</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">long_message</span> <span class="o">+=</span> <span class="n">match_fmt_custom</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">long_message</span><span class="p">)</span>


<div class="viewcode-block" id="SpecDeprecatedError">
<a class="viewcode-back" href="../../spack.html#spack.spec.SpecDeprecatedError">[docs]</a>
<span class="k">class</span> <span class="nc">SpecDeprecatedError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when a spec concretizes to a deprecated spec or dependency.&quot;&quot;&quot;</span></div>



<span class="k">class</span> <span class="nc">InvalidSpecDetected</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when a detected spec doesn&#39;t pass validation checks.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">SpliceError</span><span class="p">(</span><span class="n">spack</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SpecError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when a splice is not possible due to dependency or provider</span>
<span class="sd">    satisfaction mismatch. The resulting splice would be unusable.&quot;&quot;&quot;</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2023, Lawrence Livermore National Laboratory..
      <span class="lastupdated">Last updated on Sep 20, 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>